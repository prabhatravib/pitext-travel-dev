C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\main.py:
# Root main.py - imports and runs the router app
import sys
import importlib.util
from pathlib import Path

# Get the path to router_app.py
router_app_path = Path(__file__).parent / 'router-backend' / 'router_app.py'

# Load the module dynamically
spec = importlib.util.spec_from_file_location("router_app", router_app_path)
router_module = importlib.util.module_from_spec(spec)
sys.modules["router_app"] = router_module
spec.loader.exec_module(router_module)

# Get the app from the module
app = router_module.app

# This allows Render to find the app at the root level
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\main.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travelCode Folder compiled_folder_content.txt:
C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\.env.example:
OPENAI_API_KEY=your_api_key_here
# Google Maps Authentication - use either API key OR Client ID (not both)
GOOGLE_MAPS_API_KEY=your_google_maps_api_key_here
maps_client_id=your_google_maps_client_id_here
maps_client_secret=your_google_maps_client_secret_here
PORT=3000
RENDER_MODE=html
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\.env.example ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\main.py:
"""Entry point for the pitext_travel micro-service.
Minimal setup that delegates route registration to routes module.
"""
import os
import secrets
from flask import Flask
from pitext_travel.routes.travel import create_travel_blueprint
from pitext_travel.api.chat import bp_chat

# Get the absolute path to the directory where this file is located
base_dir = os.path.abspath(os.path.dirname(__file__))

# Create the main Flask app
app = Flask(
    __name__,
    static_url_path="/travel/static",
    static_folder=os.path.join(base_dir, 'static')
)

# Generate secret key dynamically
app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY', secrets.token_hex(32))
app.config['SESSION_COOKIE_NAME'] = 'pitext_travel_session'
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['PERMANENT_SESSION_LIFETIME'] = 3600  # 1 hour

# Register blueprints
app.register_blueprint(create_travel_blueprint(base_dir))
app.register_blueprint(bp_chat)

# Optional: ASGI shim
# pitext_travel/main.py  (only the new bits are shown)

from flask_socketio import SocketIO
from pitext_travel.routes.websocket import TravelVoiceNS   # <-- the namespace class you already wrote

# ... existing Flask app creation code ...

# NEW: create SocketIO wrapper (async_mode 'asgi' lets you keep WsgiToAsgi below)
socketio = SocketIO(app, async_mode="asgi", cors_allowed_origins="*")

# NEW: register your namespace
socketio.on_namespace(TravelVoiceNS('/travel/voice'))

# ------------------------------------------------------------------
# keep the ASGI export (Render uses it) – just switch to socketio’s:
try:
    asgi_app = socketio.asgi_app        # <-- replaces WsgiToAsgi(app)
except ImportError:
    asgi_app = app                      # fallback – shouldn’t happen

# Optional: local dev runner
if __name__ == "__main__":
    socketio.run(app, port=int(os.getenv("PORT", 3000)), debug=True)

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\main.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\requirements.txt:
Flask==2.3.2
requests==2.31.0
asgiref>=3.0.0
openai==1.12.0
python-dotenv==1.0.0
flask-cors==4.0.0

python-socketio==5.12.0      # pulled automatically, but pin for safety
python-engineio==4.11.2      # latest 4.x (supports Engine.IO protocol 4)
flask_socketio ==5.3.2
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\__init__.py:
from flask import Flask
from .api.chat import bp_chat     # new import

def create_app():
    app = Flask(__name__)

    app.register_blueprint(bp_chat)
    return app
# This file makes src a Python package

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\chat.py:
# pitext_travel/api/chat.py
import os, json
from flask import Blueprint, request, jsonify, session
import openai
from pitext_travel.api.llm import generate_trip_itinerary

bp_chat = Blueprint("chat", __name__, url_prefix="/travel/api")

# Initialize OpenAI
openai.api_key = os.environ["OPENAI_API_KEY"]

# Keep conversation context
MAX_HISTORY = 20

# Improved function schemas
FUNCTIONS = [
    {
        "name": "plan_trip",
        "description": "Plan a multi-day itinerary for a city. Use this when the user provides BOTH a city name AND number of days.",
        "parameters": {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city name for the trip"
                },
                "days": {
                    "type": "integer", 
                    "description": "Number of days for the trip",
                    "minimum": 1, 
                    "maximum": 14
                }
            },
            "required": ["city", "days"]
        }
    },
    {
        "name": "explain_day",
        "description": "Explain the itinerary for a specific day or provide an overview of all days",
        "parameters": {
            "type": "object",
            "properties": {
                "day_number": {
                    "type": "integer",
                    "description": "The day number to explain (1-based), or 0 for overview",
                    "minimum": 0
                }
            },
            "required": ["day_number"]
        }
    }
]

@bp_chat.route("/chat", methods=["POST"])
def chat():
    user_text = request.json.get("text", "").strip()
    if not user_text:
        return jsonify({"reply": "I didn't catch that."})

    # Initialize session data if needed
    if 'chat_history' not in session:
        session['chat_history'] = []
        session['pending_trip'] = {}
    
    history = session.get('chat_history', [])
    
    # System message that helps the model understand context better
    system_message = {
        "role": "system", 
        "content": """You are a friendly travel planning assistant. Your main job is to help users plan trips by creating detailed itineraries.

IMPORTANT INSTRUCTIONS:
1. When a user mentions wanting to plan a trip to a city but doesn't specify days, ask them how many days they'd like to spend there.
2. When you have BOTH the city name AND number of days, immediately call the plan_trip function.
3. If a user provides a number after you've asked about days, understand that's the number of days for the previously mentioned city.
4. Be conversational but focused on gathering the needed information.
5. Common phrases: "3 days", "three days", "a week" (7 days), "weekend" (2 days), "long weekend" (3 days).
6. When users ask about specific days or want an overview, use the explain_day function.
7. Phrases like "first day", "day 1", "explain the trip", "tell me about day 2" should trigger explain_day.

Current context: """ + json.dumps(session.get('pending_trip', {}))
    }
    
    # Add user message
    history.append({"role": "user", "content": user_text})
    
    # Keep history manageable but include system message
    messages = [system_message] + history[-MAX_HISTORY:]

    try:
        resp = openai.chat.completions.create(
            model="gpt-4.1",
            messages=messages,
            functions=FUNCTIONS,
            function_call="auto",
            temperature=0.7
        ).choices[0].message

        # Handle function calls
        if resp.function_call:
            name = resp.function_call.name
            args = json.loads(resp.function_call.arguments or "{}")

            if name == "plan_trip":
                try:
                    # Generate itinerary
                    itinerary = generate_trip_itinerary(args["city"], args["days"])
                    
                    # Store the itinerary in session
                    session['current_itinerary'] = itinerary
                    session['current_city'] = args["city"]
                    session['current_days'] = args["days"]
                    
                    # Clear pending trip
                    session['pending_trip'] = {}

                    # Add to history
                    history.append({
                        "role": "assistant",
                        "content": f"I've created a wonderful {args['days']}-day itinerary for {args['city']}!"
                    })
                    session['chat_history'] = history
                    session.modified = True

                    return jsonify({
                        "reply": f"I've created a wonderful {args['days']}-day itinerary for {args['city']}! You can see it on the map. Would you like me to explain any specific day or give you an overview?",
                        "itinerary": itinerary
                    })
                except Exception as e:
                    return jsonify({"reply": f"Sorry, I couldn't plan that trip: {str(e)}"})
                    
            elif name == "explain_day":
                if 'current_itinerary' not in session:
                    return jsonify({"reply": "I don't have a current itinerary to explain. Would you like me to plan a trip first?"})
                
                itinerary = session['current_itinerary']
                city = session.get('current_city', 'your destination')
                day_num = args.get("day_number", 0)
                
                if day_num == 0:
                    # Overview
                    reply = f"Here's an overview of your {len(itinerary['days'])}-day trip to {city}:\n\n"
                    for i, day in enumerate(itinerary['days']):
                        reply += f"**{day.get('label', f'Day {i+1}')}**: "
                        stops = [stop['name'] for stop in day['stops']]
                        reply += ", ".join(stops) + "\n"
                else:
                    # Specific day
                    if 0 < day_num <= len(itinerary['days']):
                        day = itinerary['days'][day_num - 1]
                        reply = f"On {day.get('label', f'Day {day_num}')} in {city}, you'll visit:\n\n"
                        for j, stop in enumerate(day['stops'], 1):
                            reply += f"{j}. **{stop['name']}**"
                            if 'placeType' in stop:
                                reply += f" ({stop['placeType'].replace('_', ' ')})"
                            reply += "\n"
                        reply += f"\nThis day includes {len(day['stops'])} stops. Would you like details about any other day?"
                    else:
                        reply = f"I don't have information for day {day_num}. Your trip is {len(itinerary['days'])} days long."
                
                history.append({"role": "assistant", "content": reply})
                session['chat_history'] = history
                session.modified = True
                
                return jsonify({"reply": reply})

        # Regular text response
        else:
            # Add assistant response to history
            history.append({"role": "assistant", "content": resp.content})
            session['chat_history'] = history
            session.modified = True
            
            return jsonify({"reply": resp.content})

    except Exception as e:
        print(f"Chat error: {str(e)}")
        return jsonify({"reply": "I encountered an error. Please try again."})
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\chat.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\config.py:
# api/config.py
"""Configuration management for the travel planner API."""
import os
from dotenv import load_dotenv

load_dotenv()


def get_openai_api_key():
    """Get OpenAI API key from environment."""
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY not set")
    return api_key


def get_google_maps_config():
    """Get Google Maps configuration."""
    return {
        "api_key": os.getenv("GOOGLE_MAPS_API_KEY", ""),
        "client_id": os.getenv("maps_client_id", ""),
        "client_secret": os.getenv("maps_client_secret", "")
    }


def get_port():
    """Get port configuration."""
    return int(os.getenv("PORT", 3000))


def get_render_mode():
    """Get render mode configuration."""
    return os.getenv("RENDER_MODE", "html")
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\config.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\geocoding.py:
# api/geocoding.py
"""Google Maps geocoding and coordinate management."""
import logging
import random
import requests
from pitext_travel.api.config import get_google_maps_config

logger = logging.getLogger(__name__)

# City coordinates database
CITY_COORDS = {
    "paris": (48.8566, 2.3522),
    "london": (51.5074, -0.1278),
    "new york": (40.7128, -74.0060),
    "tokyo": (35.6762, 139.6503),
    "rome": (41.9028, 12.4964),
    "barcelona": (41.3851, 2.1734),
    "amsterdam": (52.3676, 4.9041),
    "berlin": (52.5200, 13.4050),
    "prague": (50.0755, 14.4378),
    "vienna": (48.2082, 16.3738),
    "budapest": (47.4979, 19.0402),
    "madrid": (40.4168, -3.7038),
    "lisbon": (38.7223, -9.1393),
    "dublin": (53.3498, -6.2603),
    "stockholm": (59.3293, 18.0686),
    "copenhagen": (55.6761, 12.5683),
    "oslo": (59.9139, 10.7522),
    "helsinki": (60.1699, 24.9384),
    "athens": (37.9838, 23.7275),
    "istanbul": (41.0082, 28.9784),
    "moscow": (55.7558, 37.6173),
    "dubai": (25.2048, 55.2708),
    "singapore": (1.3521, 103.8198),
    "hong kong": (22.3193, 114.1694),
    "sydney": (33.8688, 151.2093),
    "melbourne": (37.8136, 144.9631),
    "los angeles": (34.0522, -118.2437),
    "san francisco": (37.7749, -122.4194),
    "chicago": (41.8781, -87.6298),
    "miami": (25.7617, -80.1918),
    "toronto": (43.6532, -79.3832),
    "vancouver": (49.2827, -123.1207),
    "mexico city": (19.4326, -99.1332),
    "buenos aires": (34.6118, -58.3960),
    "rio de janeiro": (22.9068, -43.1729),
    "sao paulo": (23.5505, -46.6333),
    "cairo": (30.0444, 31.2357),
    "marrakech": (31.6295, -7.9811),
    "cape town": (33.9249, 18.4241),
    "mumbai": (19.0760, 72.8777),
    "delhi": (28.7041, 77.1025),
    "bangkok": (13.7563, 100.5018),
    "seoul": (37.5665, 126.9780),
    "beijing": (39.9042, 116.4074),
    "shanghai": (31.2304, 121.4737)
}

def get_place_details(place_name, city):
    """
    Use Google Places API Text Search to get coordinates and place types.
    """
    config = get_google_maps_config()
    google_api_key = config.get("api_key")
    
    if not google_api_key:
        logger.warning("No Google Maps API key found, using estimated coordinates")
        lat, lng = get_estimated_coordinates(city)
        return lat, lng, None, None

    try:
        url = "https://maps.googleapis.com/maps/api/place/textsearch/json"
        params = {
            "query": f"{place_name}, {city}",
            "key": google_api_key
        }
        
        response = requests.get(url, params=params, timeout=10)
        data = response.json()

        if data.get("status") == "OK" and data.get("results"):
            result = data["results"][0]
            location = result["geometry"]["location"]
            place_types = result.get("types", [])
            
            # Get the primary type for icon selection
            primary_type = place_types[0] if place_types else None
            
            logger.info(f"Found details for {place_name}: {location['lat']}, {location['lng']}, Types: {place_types}")
            return location["lat"], location["lng"], primary_type, place_types
        else:
            logger.warning(f"Places API search failed for {place_name}: {data.get('status', 'Unknown')}")
            lat, lng = get_estimated_coordinates(city)
            return lat, lng, None, None
            
    except Exception as e:
        logger.error(f"Places API error for {place_name}: {e}")
        lat, lng = get_estimated_coordinates(city)
        return lat, lng, None, None
def get_estimated_coordinates(city):
    """Get estimated coordinates for major cities"""
    # Add small random offset to avoid exact duplicates
    base_lat, base_lng = CITY_COORDS.get(city.lower(), (48.8566, 2.3522))
    offset = random.uniform(-0.01, 0.01)
    return base_lat + offset, base_lng + offset

def enhance_with_geocoding(itinerary, city):
    """Add accurate coordinates and place type to each stop."""
    enhanced = {"days": []}
    
    for day in itinerary.get("days", []):
        enhanced_day = {
            "label": day.get("label", "Day"),
            "color": day.get("color", "#4285f4"),
            "stops": []
        }
        
        for stop in day.get("stops", []):
            place_name = stop.get("name", "Unknown Place")
            # Get lat, lng, primary_type, and all types
            lat, lng, primary_type, place_types = get_place_details(place_name, city)
            
            enhanced_stop = {
                "name": place_name,
                "lat": lat,
                "lng": lng,
                "placeType": primary_type,  # Send place type to frontend
                "types": place_types  # Send all types for more options
            }
            enhanced_day["stops"].append(enhanced_stop)
            
        enhanced["days"].append(enhanced_day)
    
    return enhanced
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\geocoding.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\llm.py:
# api/llm.py
"""OpenAI API integration for generating travel itineraries."""
import json
import re
import logging
from openai import OpenAI
from pitext_travel.api.config import get_openai_api_key
from pitext_travel.api.geocoding import enhance_with_geocoding, get_estimated_coordinates

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_client() -> OpenAI:
    """Return an OpenAI client initialized from the OPENAI_API_KEY env var."""
    api_key = get_openai_api_key()
    return OpenAI(api_key=api_key, timeout=30.0)

def generate_trip_itinerary(city, days=3):
    """
    Generate a multi-day itinerary using OpenAI + Google Geocoding for accurate coordinates.
    """
    logger.info(f"Starting enhanced itinerary generation for {city}, {days} days")
    
    try:
        client = get_client()
        
        # Enhanced prompt for better place names
        system_prompt = (
            "You are a knowledgeable travel expert. Generate a detailed day-by-day itinerary "
            "with specific, well-known attractions and landmarks. "
            "For each stop, provide the exact name as it would appear on Google Maps. "
            "Focus on must-see attractions, museums, landmarks, and popular areas. "
            "Keep each day to 3-4 stops maximum for a comfortable pace. "
            "Return ONLY a JSON object with this exact structure: "
            '{"days":[{"label":"Day 1","color":"#ff6b6b","stops":[{"name":"Exact Place Name"}]}]}'
        )
        
        user_prompt = (
            f"Create a {days}-day itinerary for {city}. Include specific landmark names, "
            f"famous attractions, and notable areas. Make sure place names are accurate "
            f"and would be recognized by Google Maps."
        )

        logger.info("Making OpenAI API call for itinerary...")
        response = client.chat.completions.create(
            model="gpt-4.1",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,  # Lower temperature for more consistent place names
            max_tokens=1500,
            timeout=25
        )
        
        text = response.choices[0].message.content.strip()
        logger.info(f"Received OpenAI response length: {len(text)} characters")
        
        # Log the full response for debugging
        if len(text) < 1000:
            logger.info(f"Full OpenAI response: {text}")
        else:
            logger.info(f"OpenAI response (first 500 chars): {text[:500]}...")
            logger.info(f"OpenAI response (last 500 chars): ...{text[-500:]}")
        
        # Clean and parse JSON
        text = re.sub(r'^```(?:json)?\s*', '', text, flags=re.MULTILINE)
        text = re.sub(r'```\s*$', '', text, flags=re.MULTILINE)
        text = text.strip()
        
        try:
            itinerary = json.loads(text)
            logger.info("Successfully parsed JSON response")
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            logger.error(f"Failed to parse text: {text}")
            
            # Try regex extraction as fallback
            json_match = re.search(r'\{.*\}', text, re.DOTALL)
            if json_match:
                try:
                    itinerary = json.loads(json_match.group(0))
                    logger.info("Successfully parsed JSON using regex extraction")
                except json.JSONDecodeError:
                    logger.error("Regex extraction also failed")
                    raise ValueError("No valid JSON found in response")
            else:
                raise ValueError("No JSON structure found in response")
        
        # Validate the structure
        if not isinstance(itinerary, dict) or 'days' not in itinerary:
            logger.error(f"Invalid itinerary structure: {itinerary}")
            raise ValueError("Invalid itinerary structure - missing 'days' key")
        
        # Enhance with Google geocoding
        logger.info("Enhancing itinerary with geocoding...")
        enhanced_itinerary = enhance_with_geocoding(itinerary, city)
        
        logger.info("Successfully generated enhanced itinerary")
        return enhanced_itinerary
        
    except Exception as e:
        logger.error(f"Error generating itinerary: {e}")
        logger.error(f"Error type: {type(e).__name__}")
        return get_fallback_itinerary(city, days)
def get_fallback_itinerary(city, days):
    """Generate a basic fallback itinerary"""
    colors = ["#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4", "#feca57", "#ff9ff3", "#54a0ff"]
    
    fallback = {"days": []}
    
    for i in range(days):
        lat, lng = get_estimated_coordinates(city)
        
        # Create slight variations for different stops
        stops = []
        for j in range(3):
            offset_lat = lat + (j * 0.01) - 0.01
            offset_lng = lng + (j * 0.01) - 0.01
            
            stops.append({
                "name": f"{city} Attraction {j+1}",
                "lat": offset_lat,
                "lng": offset_lng
            })
        
        fallback["days"].append({
            "label": f"Day {i+1}",
            "color": colors[i % len(colors)],
            "stops": stops
        })
    
    return fallback


# Testing
if __name__ == "__main__":
    result = generate_trip_itinerary("Prague", 3)
    print(json.dumps(result, indent=2))
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\llm.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\realtime\openai_client.py:
"""OpenAI Realtime WebSocket helper
===================================
A thin, asyncio‑friendly wrapper around the OpenAI Realtime API that:
    • opens one persistent WebSocket per user session
    • sends a *session.update* upon connect to configure modalities & voice
    • provides   push_pcm() / commit()  for streaming microphone audio
    • exposes   async for ev in client.events()   to consume server events

The class is deliberately transport‑agnostic: whatever part of your Flask
app owns the user’s Socket.IO connection can instantiate **RealtimeClient**
and stitch the two layers together.

Usage (inside a Socket.IO namespace):
-------------------------------------
client = RealtimeClient(api_key=OPENAI_KEY)
await client.connect()
...
await client.push_pcm(pcm_bytes)
...
async for event in client.events():
    process(event)
"""
from __future__ import annotations

import asyncio
import base64
import json
import os
from typing import AsyncGenerator, Dict, Optional

import websockets
from websockets.exceptions import ConnectionClosedOK, ConnectionClosedError

OPENAI_URL = os.getenv("OPENAI_REALTIME_URL", "wss://api.openai.com/v1/realtime")
DEFAULT_MODEL = os.getenv("OPENAI_REALTIME_MODEL", "gpt-4o-audio-preview")

# ---------------------------------------------------------------------------
# Helper — tiny base‑64 helper to avoid typing the same boilerplate
# ---------------------------------------------------------------------------
_b64encode = lambda b: base64.b64encode(b).decode()


class RealtimeClient:
    """Maintain a single WS connection to OpenAI Realtime."""

    def __init__(self, api_key: str, *, model: str = DEFAULT_MODEL):
        self._api_key = api_key
        self._model = model
        self._ws: Optional[websockets.WebSocketClientProtocol] = None
        self._ev_q: asyncio.Queue = asyncio.Queue()
        self._reader_task: Optional[asyncio.Task] = None

    # ------------------------------------------------------------------
    # Connection lifecycle
    # ------------------------------------------------------------------
    async def connect(self) -> None:
        headers = {"Authorization": f"Bearer {self._api_key}"}
        self._ws = await websockets.connect(
            OPENAI_URL,
            extra_headers=headers,
            max_size=2 ** 22,   # 4 MiB – big enough for long responses
        )

        # Configure session (24 kHz PCM in/out, alloy voice)
        await self._send({
            "type": "session.update",
            "session": {
                "modalities": ["audio", "text"],
                "model": self._model,
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "voice": {"name": "alloy"},
            },
        })

        # Spawn background reader
        self._reader_task = asyncio.create_task(self._reader())

    async def close(self) -> None:
        if self._ws and not self._ws.closed:
            await self._ws.close()
        if self._reader_task:
            self._reader_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._reader_task

    # ------------------------------------------------------------------
    # Public API – audio upload + event iterator
    # ------------------------------------------------------------------
    async def push_pcm(self, pcm_bytes: bytes) -> None:
        """Append raw 16‑bit PCM samples to the server buffer."""
        if not pcm_bytes:
            return
        await self._send({
            "type": "input_audio_buffer.append",
            "audio": _b64encode(pcm_bytes),
        })

    async def commit(self) -> None:
        """Flush the buffer so server‑side VAD can process the utterance."""
        await self._send({"type": "input_audio_buffer.commit"})

    async def events(self) -> AsyncGenerator[Dict, None]:
        """Iterate over OpenAI events as they arrive."""
        while True:
            ev = await self._ev_q.get()
            yield ev

    # ------------------------------------------------------------------
    # Internals
    # ------------------------------------------------------------------
    async def _send(self, payload: Dict) -> None:
        if not self._ws:
            raise RuntimeError("RealtimeClient not connected")
        await self._ws.send(json.dumps(payload))

    async def _reader(self) -> None:
        try:
            async for msg in self._ws:
                try:
                    ev = json.loads(msg)
                except json.JSONDecodeError:
                    continue  # skip garbage
                await self._ev_q.put(ev)
        except (ConnectionClosedOK, ConnectionClosedError):
            pass

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\realtime\openai_client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\travel.py:
"""Flask routes for the travel planner application.
All routes are grouped under the /travel prefix.
"""
import os
from flask import Blueprint, render_template, jsonify, request
from pitext_travel.api.llm import generate_trip_itinerary
from pitext_travel.api.config import get_google_maps_config


def create_travel_blueprint(base_dir):
    """Create and configure the travel blueprint.
    
    Args:
        base_dir: Absolute path to the application directory
    
    Returns:
        Configured Flask Blueprint
    """
    travel_bp = Blueprint(
        "travel",
        __name__,
        url_prefix="/travel",
        template_folder=os.path.join(base_dir, 'templates')
    )

    @travel_bp.route("/", strict_slashes=False)
    def index():
        """Landing page for the Travel Planner micro-app."""
        return render_template("map.html")

    @travel_bp.route("/api/config", methods=["GET"])
    def get_config():
        """Serve configuration including Google Maps credentials."""
        config = get_google_maps_config()
        
        # Check for either API key or Client ID setup
        api_key = config["api_key"]
        client_id = config["client_id"]
        
        # Provide debugging info (without exposing full credentials)
        debug_info = {
            "has_api_key": bool(api_key and api_key.strip()),
            "has_client_id": bool(client_id and client_id.strip()),
            "api_key_length": len(api_key) if api_key else 0,
            "client_id_prefix": client_id[:10] + "..." if client_id and len(client_id) > 10 else client_id
        }
        
        print(f"Maps config debug: {debug_info}")
        
        return jsonify({
            "google_maps_api_key": api_key,
            "google_maps_client_id": client_id,
            "auth_type": "client_id" if client_id else "api_key",
            "debug": debug_info
        })

    @travel_bp.route("/api/itinerary", methods=["GET", "POST"])
    def get_itinerary():
        """Generate a travel itinerary using the OpenAI API."""
        if request.method == "POST":
            payload = request.get_json(force=True) or {}
            city = payload.get("city", "Paris")
            days = int(payload.get("days", 3))
        else:
            city, days = "Paris", 3

        try:
            itinerary = generate_trip_itinerary(city, days)
            return jsonify(itinerary)
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    return travel_bp
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\travel.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\websocket.py:
# ── imports ────────────────────────────────────────────────────────────────
import asyncio, logging, base64
from flask import current_app
from flask_socketio import Namespace, emit
from ..api.realtime.openai_client import RealtimeClient

log = logging.getLogger(__name__)

# ── namespace ──────────────────────────────────────────────────────────────
class TravelVoiceNS(Namespace):
    """
    Socket.IO ↔ OpenAI-Realtime bridge
    Path: /travel/voice
    """
    def __init__(self, namespace):
        super().__init__(namespace)
        self.rt = None     # RealtimeClient

    # -------- connects / disconnects --------------------------------------
    def on_connect(self):
        api_key = current_app.config['OPENAI_API_KEY']
        self.rt = RealtimeClient(api_key)
        asyncio.create_task(self.rt.connect())
        asyncio.create_task(self._fanout())
        log.info('Voice WS connected')

    def on_disconnect(self):
        if self.rt:
            asyncio.create_task(self.rt.close())
        log.info('Voice WS disconnected')

    # -------- browser → backend ------------------------------------------
    def on_audio_chunk(self, data):
        # data['pcm'] is an ArrayBuffer -> bytes on JS side
        asyncio.create_task(self.rt.push_pcm(data['pcm']))

    def on_audio_commit(self):
        asyncio.create_task(self.rt.push_pcm(b'', commit=True))

    # -------- backend → browser ------------------------------------------
    async def _fanout(self):
        async for ev in self.rt.events():
            t = ev.get('type', '')
            if t == 'conversation.item.created':
                emit('assistant_text', {'text': ev['item']['message']})
            elif t == 'output_audio_buffer.payload':
                emit('assistant_audio', {'audio': ev['audio']})
            # add other event types if you later use tools / function-calling

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\websocket.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\dayColors.js:
// static/dayColors.js

// 1) Static palette for Days 1–7 (soft, warm, distinct)
export const DAY_COLOR_MAP = {
1: "#FFADAD", // pastel-red (Day 1)
2: "#FFD6A5", // pastel-apricot (Day 2)
3: "#FFCC99", // pastel-peach (Day 3)
4: "#FFC4E1", // pastel-pink (Day 4)
5: "#FDFFB6", // pastel-butter (Day 5)
6: "#FFB3AB", // pastel-coral (Day 6)
7: "#FFECB3", // pastel-gold (Day 7)
};

// 2) Helper to return a colour for any given day index.
//    If the day is not in the static map, fall back to an HSL-based pastel.
export function getColourForDay(dayIndex) {
  // If a static entry exists, return it
  if (DAY_COLOR_MAP.hasOwnProperty(dayIndex)) {
    return DAY_COLOR_MAP[dayIndex];
  }
  
  // Otherwise, generate a gentle pastel by spacing hues around the colour wheel.
  // This ensures undefined days (e.g., Day 8, Day 9, …) still get a soft, distinct hue.
  const hue = (dayIndex * 45) % 360;      // 45° increments around the circle
  const saturation = 70;                  // 70% saturation (pastel feel)
  const lightness = 85;                   // 85% lightness (very soft)
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\dayColors.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\base.css:
/* static/css/base.css - Global Resets & Base Styles */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: system-ui, Arial, sans-serif;
}

html, body {
  height: 100%;
  overflow: hidden;
  background-color: #000;
  background-size: cover;
  background-position: center;
  background-attachment: fixed;
  color: #333;
}

/* Utility Classes */
.hidden {
  display: none !important;
}

.visible {
  opacity: 1 !important;
}

/* Transitions */
* {
  transition: opacity 0.2s ease;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\base.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\chat.css:
/* static/css/chat.css */

/* Chat Panel Container */
.chat-panel {
  position: fixed;
  right: 1rem;
  bottom: 5rem;      /* Above the mic button */
  width: min(90vw, 420px);  /* Responsive width, max 420px */
  max-height: 60vh;
  overflow-y: auto;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  font-size: 15px;
  line-height: 1.5;
  display: none;  /* Hidden by default */
  flex-direction: column;
  gap: 0.75rem;
  z-index: 10020;
  transition: all 0.3s ease;
}

/* Show panel when it has content */
.chat-panel:not(:empty) {
  display: flex;
}

/* Chat Bubbles */
.chat-panel .bubble {
  padding: 0.75rem 1rem;
  border-radius: 18px;
  max-width: 85%;
  word-wrap: break-word;
  word-break: break-word;
  white-space: pre-wrap;
  animation: fadeIn 0.3s ease;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* User Messages (right-aligned) */
.chat-panel .bubble.user {
  background: #1976d2;
  color: white;
  align-self: flex-end;
  margin-left: auto;
  border-bottom-right-radius: 4px;
}

/* Assistant Messages (left-aligned) */
.chat-panel .bubble.assistant {
  background: #f0f0f0;
  color: #333;
  align-self: flex-start;
  margin-right: auto;
  border-bottom-left-radius: 4px;
}

/* Scrollbar Styling */
.chat-panel::-webkit-scrollbar {
  width: 6px;
}

.chat-panel::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
  border-radius: 3px;
}

.chat-panel::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.chat-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.3);
}

/* Fade-in Animation */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Mic Button */
.mic-btn {
  position: fixed;
  right: 1rem;
  bottom: 1rem;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: #1976d2;
  color: white;
  border: none;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  cursor: pointer;
  z-index: 10025;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.mic-btn:hover {
  background: #1565c0;
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
}

.mic-btn:active {
  transform: scale(0.95);
}

.mic-btn.active {
  background: #d32f2f;
  animation: pulse 1.5s infinite;
}

.mic-btn svg {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* Pulse Animation for Active Recording */
@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7);
  }
  70% {
    box-shadow: 0 0 0 20px rgba(211, 47, 47, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(211, 47, 47, 0);
  }
}

/* Mobile Responsive Adjustments */
@media (max-width: 768px) {
  .chat-panel {
    right: 0.5rem;
    bottom: 4.5rem;
    width: calc(100vw - 1rem);
    max-width: none;
    font-size: 14px;
  }
  
  .chat-panel .bubble {
    max-width: 90%;
  }
  
  .mic-btn {
    right: 0.5rem;
    bottom: 0.5rem;
  }
}

/* Dark Mode Support (if needed) */
@media (prefers-color-scheme: dark) {
  .chat-panel {
    background: rgba(30, 30, 30, 0.95);
    color: #f0f0f0;
  }
  
  .chat-panel .bubble.assistant {
    background: #424242;
    color: #f0f0f0;
  }
}

/* Add these styles to the end of chat.css */

/* Disabled state when assistant is speaking */
.mic-btn.disabled {
  background: #9e9e9e;
  cursor: not-allowed;
  opacity: 0.6;
}

.mic-btn.disabled:hover {
  background: #9e9e9e;
  transform: none;
}

/* Visual feedback for when assistant is speaking */
.chat-panel .bubble.assistant.speaking {
  animation: pulse-soft 2s infinite;
}

@keyframes pulse-soft {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

/* Add a small status indicator */
.mic-status {
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  color: #666;
  white-space: nowrap;
  pointer-events: none;
}

/* Update the mic button to show state */
.mic-btn::after {
  content: '';
  position: absolute;
  bottom: -22px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  color: #666;
  white-space: nowrap;
}

.mic-btn.active::after {
  content: 'Listening...';
  color: #d32f2f;
}

.mic-btn.disabled::after {
  content: 'Assistant speaking';
  color: #9e9e9e;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\chat.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\controls.css:
/* static/css/controls.css - Form and Day Controls Styles */

/* Trip Form Styles */
#trip-form {
  display: flex;
  gap: 0.4rem;
  flex-wrap: wrap;
  margin-bottom: 0.5rem;
  background-color: transparent;
  padding: 0;
  position: relative;
  z-index: 10020;
}

#trip-form label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: bold;
}

#trip-form input[type="text"],
#trip-form input[type="number"] {
  flex: 1 1 120px;
  padding: 0.4rem 0.6rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.95rem;
  background: rgba(255, 255, 255, 0.8);
}

#trip-form button,
#trip-form input[type="submit"] {
  background-color: #87CEEB;
  color: #000;
  padding: 0.4rem 1rem;
  border: none;
  border-radius: 4px;
  font-size: 0.95rem;
  cursor: pointer;
  flex: 0 0 auto;
  transition: all 0.1s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  position: relative;
  z-index: 10020;
  pointer-events: auto;
}

#trip-form button:hover,
#trip-form input[type="submit"]:hover {
  background-color: #6BB6CD;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
  transform: translateY(-1px);
}

#trip-form button:active,
#trip-form input[type="submit"]:active {
  transform: translateY(1px);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  background-color: #5AA5BC;
}

/* Day Controls with Checkboxes */
#day-controls {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 0.5rem;
  padding: 0.5rem 0;
  position: relative;
  z-index: 10010;
}

#day-controls > div {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.3rem;
}

#day-controls label {
  font-weight: bold;
  font-size: 0.9rem;
  cursor: pointer;
  transition: opacity 0.2s ease;
}

#day-controls label:hover {
  opacity: 0.8;
}

#day-controls input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
  accent-color: #4285f4;
}

#day-controls input[type="checkbox"]:hover {
  transform: scale(1.1);
}

/* Old day toggle button styles (for backward compatibility) */
.day-toggle {
  background-color: #e74c3c;
  color: white;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 0.7;
}

.day-toggle:hover {
  opacity: 0.9;
  transform: translateY(-1px);
}

.day-toggle.active {
  opacity: 1;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\controls.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\map.css:
/* static/css/map.css - Map Container & Related Styles */

/* Full-Screen Map Container */
#map {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background-color: #e0e0e0;
}

/* Map Container (old structure compatibility) */
#map-container {
  position: relative;
  flex-grow: 1;
  margin: 1rem auto;
  max-width: 900px;
  height: 500px;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  background-color: #e0e0e0;
}

/* Initial loading message */
#map .loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #fff;
  text-align: center;
  font-size: 1.1rem;
}

#map .loading p {
  margin: 0.5rem 0;
}

#map .loading small {
  font-size: 0.85rem;
  opacity: 0.8;
}

/* Map Overlay for Loading/Errors */
#map-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.6);
  color: #f2f2f2;
  font-size: 1.1rem;
  text-align: center;
  z-index: 5;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  padding: 1rem;
}

#map-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}

/* Info Window Styling (Google Maps) */
.info-window {
  max-width: 280px;
  font-size: 0.9rem;
  line-height: 1.3;
}

.info-window h4 {
  margin: 0 0 8px 0;
  color: #1976d2;
  font-size: 1rem;
}

.info-window p {
  margin: 4px 0;
  font-size: 0.85rem;
  color: #333;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\map.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\panel.css:
/* static/css/panel.css – 2025-06-08
   -- key changes --------------------------------------------------------
   • Panel width  : min(64vw, 336px)         ⟵ ~30 % narrower
   • Translucency : rgba(255,255,255,0.80)   ⟵ lighter glass effect
   ---------------------------------------------------------------------- */

/**************************
 * 1. PANEL POSITIONING
 *************************/
#panel {
  position: absolute;
  bottom: 1rem;
  left:   1rem;

  /* ↓-- narrower: 64 % of viewport or max 336 px (was 92 % / 480 px) */
  width: min(64vw, 336px);

  max-height: 80vh;
  z-index: 10030;
  overflow: visible;
}

/**************************
 * 2. INNER CARD LOOK & FEEL
 *************************/
#inner-panel {
  position: relative;
  padding: 0.75rem 1rem;

  /* ↓-- more see-through (alpha .80 instead of .95) */
  background: rgba(255, 255, 255, 0.80);
  backdrop-filter: blur(10px);

  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, .25);
  transition: all .3s ease;
}

/**************************
 * 3. DAY-CONTROLS ROW
 *************************/
#day-controls {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
  margin-bottom: 0.5rem;
}

/**************************
 * 4. TRIP FORM (inputs + button)
 *************************/
#trip-form input[type="text"],
#trip-form input[type="number"] {
  width: 100%;
  padding: 0.45rem 0.6rem;
  margin-bottom: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.95rem;
}

#trip-form button {
  display: block;
  width: 100%;
  padding: 0.5rem;
  font-size: 1rem;
  border: none;
  border-radius: 4px;
  background: #55a9d8;
  color: #fff;
  cursor: pointer;
  box-shadow: inset 0 -2px 2px rgba(0, 0, 0, .15);
}

/**************************
 * 5. MINIMISE / EXPAND BUTTON
 *************************/
#minimize-btn {
  position: absolute;
  top:  -14px;
  right: -14px;
  width: 28px;
  height: 28px;

  border: none;
  border-radius: 50%;
  background: #007bff;
  color: #fff;
  font-size: 20px;
  line-height: 1;

  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 0, 0, .25);
  z-index: 10040;
  transition: transform .1s;
}
#minimize-btn:active { transform: scale(0.9); }

/**************************
 * 6. COLLAPSED STATE
 *************************/
#panel.minimized #inner-panel {
  padding: 0.5rem 0.75rem;
  width: 100%;                /* keep whatever width we have */
}

/* show only the day controls when collapsed */
#panel.minimized #inner-panel > *:not(#day-controls):not(#minimize-btn) {
  display: none !important;
}
#panel.minimized #day-controls { margin-bottom: 0; }

/**************************
 * 7. OPTIONAL GLOBAL HELPERS
 *************************/
#app-container { display: flex; flex-direction: column; min-height: 100vh; }
header        { background:#007bff; color:#fff; padding:1rem; text-align:center; }
h1            { font-size:1.8rem; margin:0; }
footer        { background:#f8f9fa

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\panel.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\app.js:
// static/js/app.js - Main Application Entry Point

// Store trip data globally
let tripData = null;

/**
 * Initialize the application when DOM is ready
 */
document.addEventListener("DOMContentLoaded", () => {
    const { debugLog } = window.TravelHelpers;
    debugLog("DOM loaded, setting up travel planner...");
    
    // Initialize UI components
    window.TravelPanel.initializePanel();
    window.TravelForm.initializeForm();
    
    // Start loading Google Maps API
    loadGoogleMapsAPI();
});

/**
 * Load Google Maps API dynamically
 */
async function loadGoogleMapsAPI() {
    const { debugLog } = window.TravelHelpers;
    const { showError } = window.TravelOverlays;
    const { loadGoogleMapsConfig, createMapsScriptUrl, loadGoogleMapsScript } = window.TravelConfig;
    
    try {
        // Load configuration
        const config = await loadGoogleMapsConfig();
        
        // Create script URL
        const scriptUrl = createMapsScriptUrl(config);
        
        // Load the script
        await loadGoogleMapsScript(scriptUrl);
        
    } catch (error) {
        showError(`Failed to load Google Maps: ${error.message}`);
    }
}

/**
 * Initialize when Google Maps API is loaded (callback function)
 */
window.initializeApp = function() {
    const { debugLog } = window.TravelHelpers;
    const { initializeGoogleMap } = window.TravelGoogleMaps;
    
    debugLog('Google Maps API loaded successfully');
    
    try {
        initializeGoogleMap();
        
        // Load map modules after Google Maps is initialized
        if (window.loadMapModules) {
            debugLog('Loading map modules...');
            window.loadMapModules();
        } else {
            debugLog('loadMapModules function not found!');
        }
        
    } catch (error) {
        const { showError } = window.TravelOverlays;
        showError(`Map initialization failed: ${error.message}`);
    }
};

/**
 * Process itinerary data
 */
async function processItinerary(city, days) {
    const { debugLog } = window.TravelHelpers;
    const { showLoading, showError, hideOverlay } = window.TravelOverlays;
    const { isMapLoaded } = window.TravelGoogleMaps;
    const { fetchItinerary } = window.TravelAPI;
    
    if (!isMapLoaded()) {
        showError("Google Maps is still loading. Please wait a moment and try again.");
        return;
    }
    
    // Show loading
    showLoading("Generating your Holi :) Day plans!");
    
    try {
        // Fetch itinerary
        const data = await fetchItinerary(city, days);
        
        // Store trip data
        tripData = data;
        
        // Render on map
        renderTripOnMap(data);
        
        // Hide loading
        hideOverlay();
        
    } catch (error) {
        showError(`Failed to load itinerary: ${error.message}`);
    }
}

/**
 * Render the complete trip on Google Maps
 */
function renderTripOnMap(data) {
    const { debugLog } = window.TravelHelpers;
    const { showError } = window.TravelOverlays;
    const { fitMapToBounds } = window.TravelGoogleMaps;

    // If modules aren't ready yet, store the data and wait
    if (!window.mapModulesReady) {
        debugLog("Map modules not ready yet, storing pending render...");
        window.pendingRender = data;
        return;
    }

    debugLog("Map modules ready, rendering trip...");

    // Modules are loaded, proceed with rendering
    const { createAllMarkers, clearAllMarkers } = window.TravelMarkers;
    const { createAllRoutes, clearAllRoutes } = window.TravelRoutes;
    const { renderDayControls, clearDayControls } = window.TravelControls;
    
    debugLog("Rendering trip on Google Maps...", data);
    
    if (!data.days || data.days.length === 0) {
        showError("No itinerary data to display");
        return;
    }
    
    // Clear existing elements
    clearMapElements();
    
    // Create markers
    const { bounds, totalStops } = createAllMarkers(data);
    
    // Create routes
    createAllRoutes(data);
    
    // Hide all days except the first one
    data.days.forEach((_, index) => {
        if (index > 0) {
            const { toggleMarkersForDay } = window.TravelMarkers;
            const { toggleRoutesForDay } = window.TravelRoutes;
            toggleMarkersForDay(index, false);
            toggleRoutesForDay(index, false);
        }
    });
            
    // Fit map to bounds
    fitMapToBounds(bounds, totalStops);
    
    // Render day controls
    renderDayControls(data.days);
    
    debugLog("Trip rendering complete!");
}
/**
 * Clear all map elements
 */
function clearMapElements() {
    const { debugLog } = window.TravelHelpers;

    if (window.TravelMarkers && window.TravelMarkers.clearAllMarkers) {
        window.TravelMarkers.clearAllMarkers();
    }
    if (window.TravelRoutes && window.TravelRoutes.clearAllRoutes) {
        window.TravelRoutes.clearAllRoutes();
    }
    if (window.TravelControls && window.TravelControls.clearDayControls) {
        window.TravelControls.clearDayControls();
    }



    const { clearAllMarkers } = window.TravelMarkers;
    const { clearAllRoutes } = window.TravelRoutes;
    const { clearDayControls } = window.TravelControls;
    
    debugLog("Clearing map elements...");
    
    clearAllMarkers();
    clearAllRoutes();
    clearDayControls();
}

// Global error handler for Google Maps script loading issues
window.addEventListener('error', function (e) {
    if (e.filename && e.filename.includes('maps.googleapis.com')) {
        const { showError } = window.TravelOverlays;
        const errMsg = e.message || (e.error && e.error.message) || 'Unknown script error';
        console.error('Google Maps script error:', errMsg, e);

        showError(`
            <strong>Google Maps JavaScript failed to load</strong><br><br>
            <code>${errMsg}</code><br><br>
            • Check internet connectivity.<br>
            • Verify the API Key / Client ID.<br>
            • Ensure your quota hasn't been exceeded.<br><br>
            See the browser console for the full stack trace.
        `);
    }
}, true);

// Export for other modules
window.TravelApp = {
    processItinerary,
    renderTripOnMap,
    clearMapElements
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\app.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\chat.js:
// static/js/chat.js
// Handles voice transcripts and chat interactions

class Chat {
  constructor() {
    this.panel = document.getElementById('chat-panel');
    this.isSpeaking = false;
    this.voiceInitialized = false;
    
    // Initialize voice on first user interaction
    this.initializeVoice();
    
    // Set up voice integration
    if (window.voice) {
      window.voice.onTranscript = t => this.handleUser(t);
    }
  }

  initializeVoice() {
    // Many browsers require user interaction to enable speech synthesis
    const initHandler = () => {
      if (!this.voiceInitialized && 'speechSynthesis' in window) {
        // Get voices to initialize the speech synthesis
        const voices = window.speechSynthesis.getVoices();
        console.log(`Speech synthesis initialized with ${voices.length} voices`);
        
        // Test speech synthesis with empty utterance
        const testUtterance = new SpeechSynthesisUtterance('');
        testUtterance.volume = 0;
        window.speechSynthesis.speak(testUtterance);
        
        this.voiceInitialized = true;
        
        // Remove the event listeners after initialization
        document.removeEventListener('click', initHandler);
        document.removeEventListener('touchstart', initHandler);
      }
    };

    // Add event listeners for user interaction
    document.addEventListener('click', initHandler);
    document.addEventListener('touchstart', initHandler);
    
    // Also try to initialize immediately
    if ('speechSynthesis' in window) {
      // Load voices
      window.speechSynthesis.getVoices();
      
      // Chrome loads voices asynchronously
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = () => {
          const voices = window.speechSynthesis.getVoices();
          console.log(`Voices loaded: ${voices.length} available`);
        };
      }
    }
  }

  async handleUser(text) {
    this.addBubble('user', text);

    try {
      const res = await fetch('/travel/api/chat', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({text}),
        credentials: 'include'
      });

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }

      const data = await res.json();

      // Show reply
      this.addBubble('assistant', data.reply);
      
      // Speak the reply
      this.speakText(data.reply);

      // Handle itinerary if present AND it's a new trip
      if (data.itinerary && window.TravelApp) {
        // Only render if it's a new itinerary (check if city/days changed)
        const isNewTrip = data.reply.includes("I've created") || 
                          data.reply.includes("planned") ||
                          data.reply.includes("itinerary for");
        
        if (isNewTrip) {
          window.TravelApp.renderTripOnMap(data.itinerary);
        }
      }

    } catch (error) {
      console.error('Chat error:', error);
      this.addBubble('assistant', 'Sorry, I encountered an error. Please try again.');
    }
  }

  speakText(text) {
    if (!('speechSynthesis' in window)) {
      console.warn('Speech synthesis not supported');
      return;
    }

    // Notify voice controller that assistant is about to speak
    if (window.voice && window.voice.setAssistantSpeaking) {
      window.voice.setAssistantSpeaking(true);
    }

    // Cancel any ongoing speech
    window.speechSynthesis.cancel();

    // Wait a bit for cancel to complete
    setTimeout(() => {
      // Remove markdown formatting for cleaner speech
      const cleanText = text
        .replace(/\*\*(.*?)\*\*/g, '$1')  // Remove bold **text**
        .replace(/\*(.*?)\*/g, '$1')      // Remove italic *text*
        .replace(/\n+/g, '. ')            // Replace newlines with periods
        .replace(/[#_~`]/g, '');          // Remove other markdown chars

      const utterance = new SpeechSynthesisUtterance(cleanText);
      
      // Configure the utterance
      utterance.rate = 0.9;     // Slightly slower for clarity
      utterance.pitch = 1.0;
      utterance.volume = 0.8;   // Slightly lower volume to reduce pickup
      utterance.lang = 'en-US';
      
      // Select a voice if available
      const voices = window.speechSynthesis.getVoices();
      if (voices.length > 0) {
        // Try to find an English voice
        const englishVoice = voices.find(voice => 
          voice.lang.startsWith('en') && !voice.name.includes('Google')
        ) || voices[0];
        utterance.voice = englishVoice;
        console.log(`Using voice: ${englishVoice.name}`);
      }
      
      // Handle events
      utterance.onstart = () => {
        this.isSpeaking = true;
        console.log('Started speaking:', cleanText.substring(0, 50) + '...');
      };
      
      utterance.onend = () => {
        this.isSpeaking = false;
        console.log('Finished speaking');
        
        // Notify voice controller that assistant finished speaking
        if (window.voice && window.voice.setAssistantSpeaking) {
          window.voice.setAssistantSpeaking(false);
        }
        
        // DO NOT automatically restart voice recognition
        // User must click the mic button to speak again
        console.log('Click the mic button to speak again');
      };
      
      utterance.onerror = (event) => {
        console.error('Speech synthesis error:', event.error, event);
        this.isSpeaking = false;
        
        // Notify voice controller on error too
        if (window.voice && window.voice.setAssistantSpeaking) {
          window.voice.setAssistantSpeaking(false);
        }
        
        // Try to help debug common issues
        if (event.error === 'not-allowed') {
          console.error('Speech synthesis not allowed. User interaction may be required.');
        }
      };

      // Speak
      try {
        window.speechSynthesis.speak(utterance);
        console.log('Speech synthesis started');
      } catch (error) {
        console.error('Failed to start speech:', error);
        // Notify voice controller on failure
        if (window.voice && window.voice.setAssistantSpeaking) {
          window.voice.setAssistantSpeaking(false);
        }
      }
    }, 100);
  }
  
  addBubble(role, text) {
    const div = document.createElement('div');
    div.className = `bubble ${role}`;
    
    // Parse markdown-style formatting for display
    const formattedText = text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // Bold
      .replace(/\n/g, '<br>');                           // Line breaks
    
    div.innerHTML = formattedText;
    this.panel.appendChild(div);
    
    // Ensure panel is visible
    this.panel.style.display = 'block';
    
    // Smooth scroll to latest message
    setTimeout(() => {
      div.scrollIntoView({behavior: 'smooth', block: 'end'});
    }, 100);
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.chatInstance = new Chat();
  console.log('Chat system initialized');
});
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\chat.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\voice.js:
// static/js/voice.js
// ---------------------------------------------------------------------------
// Web‑Audio voice controller for OpenAI Realtime
// ---------------------------------------------------------------------------
// Responsibilities
//   • Capture microphone at 24 kHz mono PCM using an AudioWorklet
//   • Stream raw PCM chunks to the backend through Socket.IO
//   • Send a commit signal when the user stops speaking (mic toggle)
//   • Receive base‑64 PCM from the backend (`assistant_audio`) and play it
//   • Expose a global `window.voice` object so existing UI code can call
//       voice.start(), voice.stop(), voice.toggle(), etc.
//
// Assumptions
//   • The backend Socket.IO namespace is `/travel/voice` (see websocket.py)
//   • `socket.io.js` (or ESM) is already loaded on the page and exposes `io`
//   • `input-pcm-processor.js` (AudioWorklet) is served at
//         /static/js/audio/input-pcm-processor.js
//   • A mic button exists with id `#mic-btn`
// ---------------------------------------------------------------------------
/* global io */

(function () {
  class VoiceController {
    constructor (buttonSelector = '#mic-btn') {
      // ---------------------------------------------------------------------
      // 1  UI: mic button ----------------------------------------------------
      // ---------------------------------------------------------------------
      this.button = document.querySelector(buttonSelector)
      if (!this.button) {
        console.warn('Mic button not found – voice disabled')
        return
      }
      this.button.addEventListener('click', () => this.toggle())

      // ---------------------------------------------------------------------
      // 2  Socket.IO connection to backend ----------------------------------
      // ---------------------------------------------------------------------
      this.socket = io('/travel/voice')

      // Playback handler (assistant → audio chunks)
      this.socket.on('assistant_audio', ({ audio }) => this._playAssistant(b64ToPCM(audio)))

      // Optional: assistant text (hook for chat bubble ‑ only if you want it)
      this.socket.on('assistant_text', ({ text }) => {
        if (window.TravelChat) window.TravelChat.addAssistantMessage(text)
      })

      // ---------------------------------------------------------------------
      // 3  Audio context / worklet ------------------------------------------
      // ---------------------------------------------------------------------
      this.audioCtx = null         // lazy‑init after first click
      this.worklet = null
      this.isRecording = false
    }

    // ---------------------------------------------------------------------
    // Public API (used by other JS modules if needed) ----------------------
    // ---------------------------------------------------------------------
    async start () {
      if (this.isRecording) return

      await this._ensureAudioPipeline()
      await this.audioCtx.resume()       // required after a user gesture
      this.button.classList.add('active')
      this.isRecording = true
    }

    stop () {
      if (!this.isRecording) return
      this.button.classList.remove('active')
      this.isRecording = false
      // Tell backend to commit what we just said so server‑side VAD can act
      this.socket.emit('audio_commit')
    }

    toggle () {
      this.isRecording ? this.stop() : this.start()
    }

    // ---------------------------------------------------------------------
    // Private helpers ------------------------------------------------------
    // ---------------------------------------------------------------------
    async _ensureAudioPipeline () {
      if (this.audioCtx) return

      // Create AudioContext matching OpenAI 24 kHz sample rate
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: 24000
      })

      // Load the AudioWorklet that converts float‑32 to 16‑bit PCM LE
      try {
        await this.audioCtx.audioWorklet.addModule('/static/js/audio/input-pcm-processor.js')
      } catch (err) {
        console.error('Failed to load AudioWorklet:', err)
        return
      }

      // Open microphone stream (prompts the user the first time)
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const src = this.audioCtx.createMediaStreamSource(this.stream)

      // Worklet node that receives Float32 chunks and sends ArrayBuffer via port
      this.worklet = new AudioWorkletNode(this.audioCtx, 'input-pcm')

      // Forward PCM to backend in small chunks (~128 frames = ~5 ms)
      this.worklet.port.onmessage = ({ data }) => {
        this.socket.emit('audio_chunk', { pcm: data })
      }

      // Mic → worklet (no need to monitor output)
      src.connect(this.worklet)
    }

    _playAssistant ({ float32, sampleRate = 24000 }) {
      // Ensure AudioContext exists (might be closed if user never spoke yet)
      if (!this.audioCtx) {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate
        })
      }

      const buf = this.audioCtx.createBuffer(1, float32.length, sampleRate)
      buf.copyToChannel(float32, 0)
      const src = this.audioCtx.createBufferSource()
      src.buffer = buf
      src.connect(this.audioCtx.destination)
      src.start()
    }
  }

  // -----------------------------------------------------------------------
  // Helper: base‑64 → Float32Array (normalised −1 … +1) -------------------
  // -----------------------------------------------------------------------
  function b64ToPCM (b64) {
    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0))
    const int16 = new Int16Array(bytes.buffer)
    const float32 = Float32Array.from(int16, s => s / 0x7fff)
    return { float32, sampleRate: 24000 }
  }

  // Attach globally so other scripts can call voice.toggle(), etc.
  window.voice = new VoiceController()
})()

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\voice.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\client.js:
// static/js/api/client.js - API Communication

/**
 * Fetch itinerary from Flask backend
 */
async function fetchItinerary(city = "Paris", days = 3) {
    const { debugLog, errorLog } = window.TravelHelpers;
    const { API_ENDPOINTS } = window.TravelConstants;
    
    debugLog(`Fetching itinerary for ${city}, ${days} days...`);
    
    const endpoint = API_ENDPOINTS.ITINERARY;
    const fetchOptions = city && days ? {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ city, days })
    } : undefined;

    try {
        const response = await fetch(endpoint, fetchOptions);
        
        debugLog("API response status:", response.status);
        if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
        }
        
        const data = await response.json();
        debugLog("API response data:", data);
        
        if (!data.days || !Array.isArray(data.days)) {
            errorLog("Invalid data structure:", data);
            throw new Error("Invalid itinerary data received from server");
        }
        
        if (data.days.length === 0) {
            throw new Error("No itinerary data returned");
        }
        
        return data;
    } catch (error) {
        errorLog("Fetch error:", error);
        throw error;
    }
}

// Export for other modules
window.TravelAPI = {
    fetchItinerary
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\client.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\config.js:
// static/js/api/config.js - Frontend Configuration Loading

/**
 * Load Google Maps configuration from backend
 */
async function loadGoogleMapsConfig() {
    const { debugLog, errorLog } = window.TravelHelpers;
    const { API_ENDPOINTS } = window.TravelConstants;
    
    debugLog("Loading Google Maps API configuration...");
    
    try {
        const response = await fetch(API_ENDPOINTS.CONFIG);
        
        if (!response.ok) {
            throw new Error(`Config request failed: ${response.status}`);
        }
        
        const config = await response.json();
        debugLog("Config loaded:", config);
        
        return config;
    } catch (error) {
        errorLog('Failed to load config:', error);
        throw error;
    }
}

/**
 * Create Google Maps script URL based on configuration
 */
function createMapsScriptUrl(config) {
    const { debugLog } = window.TravelHelpers;
    let scriptUrl;
    
    if (config.auth_type === "client_id" && config.google_maps_client_id && config.google_maps_client_id.trim()) {
        // Use Client ID authentication
        const clientId = config.google_maps_client_id;
        
        // Validate Client ID format
        if (!clientId.startsWith('gme-') && clientId.length < 20) {
            throw new Error("Invalid Client ID format. Expected format: gme-company or long client ID");
        }
        
        scriptUrl = `https://maps.googleapis.com/maps/api/js?key=${config.google_maps_api_key}&libraries=places,marker,geometry&callback=initializeApp`;
        debugLog("Using Google Maps Client ID authentication");
    } else if (config.google_maps_api_key && config.google_maps_api_key.trim()) {
        // Use API Key authentication
        scriptUrl = `https://maps.googleapis.com/maps/api/js?key=${config.google_maps_api_key}&libraries=places,marker&callback=initializeApp`;        debugLog("Using Google Maps API Key authentication");
    } else {
        throw new Error("No valid Google Maps credentials found. Please check your environment variables.");
    }
    
    return scriptUrl;
}

/**
 * Load Google Maps API script
 */
function loadGoogleMapsScript(scriptUrl) {
    const { debugLog, errorLog } = window.TravelHelpers;
    
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = scriptUrl;
        script.async = true;
        script.defer = true;
        
        script.onload = () => {
            debugLog("Google Maps script loaded successfully");
            resolve();
        };
        
        script.onerror = () => {
            errorLog("Failed to load Google Maps script");
            reject(new Error('Failed to load Google Maps script'));
        };
        
        document.head.appendChild(script);
        debugLog("Google Maps script added to page");
    });
}

// Export for other modules
window.TravelConfig = {
    loadGoogleMapsConfig,
    createMapsScriptUrl,
    loadGoogleMapsScript
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\config.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\audio\input-pcm-processor.js:
// static/js/audio/input-pcm-processor.js
// AudioWorkletProcessor that converts Float32 input frames (-1..1) into
// a transferable ArrayBuffer containing 16‑bit little‑endian PCM samples.
// Each `process()` call typically handles 128 frames (~5.3 ms at 24 kHz),
// which keeps latency low enough for the Realtime API.
//
// The main thread attaches a message handler to `port.onmessage` to receive
// the ArrayBuffer and forward it (e.g. via Socket.IO) to the backend.
// ---------------------------------------------------------------------------
/* eslint-disable no-undef */
class InputPCMProcessor extends AudioWorkletProcessor {
  process (inputs) {
    const input = inputs[0]
    if (!input || !input[0]) return true // no data yet

    const float32 = input[0] // Float32Array of [-1..1]
    const pcm = new Int16Array(float32.length)

    // Convert float [-1,1] → int16
    for (let i = 0; i < float32.length; i++) {
      let s = float32[i] * 0x7fff
      // clamp just in case
      if (s > 0x7fff) s = 0x7fff
      else if (s < -0x8000) s = -0x8000
      pcm[i] = s
    }

    // Transfer the underlying buffer to main thread (zero‑copy)
    this.port.postMessage(pcm.buffer, [pcm.buffer])
    return true // keep processor alive
  }
}

registerProcessor('input-pcm', InputPCMProcessor)

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\audio\input-pcm-processor.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\controls.js:
// static/js/map/controls.js
// ----------------------------
//  • Renders "Day 1 / Day 2 / …" toggle checkboxes.
//  • Each label's text colour is taken from getColourForDay(dayIndex + 1),
//    so it will match the corresponding marker & route colour.
// ----------------------------
(function() {
    if (!window.google || !window.google.maps) {
        console.error('Google Maps API not fully loaded yet for controls.js - retrying...');
        setTimeout(function() {
            const script = document.createElement('script');
            script.src = '/travel/static/js/map/controls.js';
            document.head.appendChild(script);
        }, 100);
        return;
    }

// Store current visibility state globally
window.currentDayVisibility = window.currentDayVisibility || {};

// Track which days are visible
let dayVisibility = {};

/**
 * Render day control checkboxes
 *
 * @param {Array<Object>} days
 *   Each element is { label?: string, color?: string, stops: [...] }.
 *   We will ignore `day.color` here, and instead use getColourForDay().
 */
function renderDayControls(days) {
  const { debugLog } = window.TravelHelpers;
  debugLog("Rendering day controls for", days.length, "days");

  const controls = document.getElementById("day-controls");
  if (!controls) {
    debugLog("Day controls container not found");
    return;
  }

  // Initialize visibility: restore previous state or default to Day 1 only
  dayVisibility = window.currentDayVisibility || {};
  if (Object.keys(dayVisibility).length === 0) {
    days.forEach((_, index) => {
      dayVisibility[index] = index === 0;
    });
  }
  window.currentDayVisibility = dayVisibility;

  controls.innerHTML = "";
  controls.style.display = "flex";
  controls.style.gap = "1rem";
  controls.style.alignItems = "flex-start";

  days.forEach((day, i) => {
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.alignItems = "center";
    wrapper.style.gap = "0.3rem";

    // 1) Create the <label> for Day (i+1)
    const label = document.createElement("label");

    // Instead of using day.color, grab from our shared helper:
    const colour = window.TravelGoogleMaps.getColourForDay(i + 1);

    label.style.color = colour;          // e.g. "#FFADAD" for Day 1, "#FFD6A5" for Day 2, etc.
    label.style.fontWeight = "bold";
    label.style.fontSize = "0.9rem";
    label.textContent = day.label || `Day ${i + 1}`;
    label.style.cursor = "pointer";
    label.setAttribute("for", `day-checkbox-${i}`);

    // 2) Create the checkbox itself
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.id = `day-checkbox-${i}`;
    checkbox.checked = dayVisibility[i] !== false;  // Use restored state
    checkbox.style.cursor = "pointer";
    checkbox.style.width = "18px";
    checkbox.style.height = "18px";

    // When toggled, this will show/hide markers & routes for this day
    checkbox.onchange = () => toggleDay(i);

    // 3) Assemble & append
    wrapper.appendChild(label);
    wrapper.appendChild(checkbox);
    controls.appendChild(wrapper);
  });

  debugLog(`Created ${days.length} day control checkboxes`);
}

/**
 * Toggle visibility for a specific day
 *
 * @param {number} dayIndex
 *   Zero-based index (0 → Day 1, 1 → Day 2, etc.)
 */
function toggleDay(dayIndex) {
  const { debugLog } = window.TravelHelpers;
  const { toggleMarkersForDay } = window.TravelMarkers;
  const { toggleRoutesForDay } = window.TravelRoutes;

  debugLog(`Toggling day ${dayIndex + 1}`);

  dayVisibility[dayIndex] = !dayVisibility[dayIndex];
  
  // Save state globally
  window.currentDayVisibility = dayVisibility;

  // Update markers and routes visibility
  toggleMarkersForDay(dayIndex, dayVisibility[dayIndex]);
  toggleRoutesForDay(dayIndex, dayVisibility[dayIndex]);
}

/**
 * Get whether a given day is currently visible
 *
 * @param {number} dayIndex
 *   Zero-based index of the day
 * @returns {boolean}
 */
function isDayVisible(dayIndex) {
  return dayVisibility[dayIndex] !== false;
}

/**
 * Clear all day‐control checkboxes (for re‐rendering)
 */
function clearDayControls() {
  const controls = document.getElementById("day-controls");
  if (controls) {
    controls.innerHTML = "";
  }
  // Don't clear visibility state here - we want to preserve it
}

// Export these functions for other modules to use
window.TravelControls = {
  renderDayControls,
  toggleDay,
  isDayVisible,
  clearDayControls
};
})();
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\controls.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\google-maps.js:
// static/js/map/google-maps.js
// -------------------------------------------------------------
//  PiText Travel – Google-Maps bootstrap + "always-on" attractions
//  (with dynamic clusterer detection at use-time)
// -------------------------------------------------------------

/* ----------  DAY-COLOUR HELPER  ---------- */
const DAY_COLOR_MAP = {
  1: '#FFADAD', 2: '#FFD6A5', 3: '#FDFFB6',
  4: '#FFC4E1', 5: '#FFCC99', 6: '#FFB3AB', 7: '#FFECB3'
};
function getColourForDay(dayIndex) {
  if (DAY_COLOR_MAP[dayIndex]) return DAY_COLOR_MAP[dayIndex];
  const hue = (dayIndex * 45) % 360;
  return `hsl(${hue},70%,85%)`;
}

/* ----------  MAP / SERVICES  ---------- */
let map, directionsService, isGoogleMapsLoaded = false;

/* ----------  CLUSTERER DETECTION  ---------- */
/** 
 * At runtime, pick up whichever clusterer is loaded:
 *  - window.MarkerClusterer   (legacy)
 *  - google.maps.markerclusterer.MarkerClusterer (@googlemaps/markerclusterer)
 */
function getClustererCtor() {
  if (window.MarkerClusterer) {
    return window.MarkerClusterer;
  }
  if (window.google
      && google.maps.markerclusterer
      && google.maps.markerclusterer.MarkerClusterer) {
    return google.maps.markerclusterer.MarkerClusterer;
  }
  return null;
}

/* ----------  TOURIST POI MARKERS  ---------- */
let poiMarkers   = [];      // google.maps.Marker[]
let poiClusterer = null;
const CLUSTER_OPTIONS = {
  imagePath : 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m',
  maxZoom   : 11,   //  ≤ 11  → cluster   |   ≥ 12  → no cluster,   // ⬅️  stop clustering at zoom 13+
  // Optional fine-tuning ↓
  gridSize  : 50,   // cluster radius in px (smaller ⇒ fewer clusters)
  minimumClusterSize : 4   // don't collapse 2-or-3 markers anymore
};

/** remove existing markers & clusters */
function clearPoiMarkers() {
  if (poiClusterer) poiClusterer.clearMarkers();
  poiMarkers.forEach(m => m.setMap(null));
  poiMarkers = [];
}

/* ----------  TOURIST POI FETCHER  ---------- */
const TOURIST_TYPES = [
  'tourist_attraction','museum','art_gallery','church','hindu_temple','synagogue',
  'mosque','place_of_worship','park','zoo','aquarium','stadium','casino',
  'amusement_park','campground','cemetery','library','city_hall','rv_park',
  'university','point_of_interest'
];
const poiCache = new Map(); // key=`${type}_${lat}_${lng}_${zoom}`

function splitBounds(bounds, segments = 3) {
  const ne = bounds.getNorthEast(), sw = bounds.getSouthWest();
  const latStep = (ne.lat() - sw.lat()) / segments;
  const lngStep = (ne.lng() - sw.lng()) / segments;
  const tiles = [];
  for (let r = 0; r < segments; r++) {
    for (let c = 0; c < segments; c++) {
      const tileSw = new google.maps.LatLng(
        sw.lat() + r * latStep, sw.lng() + c * lngStep
      );
      const tileNe = new google.maps.LatLng(
        sw.lat() + (r + 1) * latStep, sw.lng() + (c + 1) * lngStep
      );
      tiles.push(new google.maps.LatLngBounds(tileSw, tileNe));
    }
  }
  return tiles;
}

function fetchTouristPois() {
  if (!map) return;
  clearPoiMarkers();

  const svc   = new google.maps.places.PlacesService(map);
  const zoom  = map.getZoom();
  const tiles = (zoom <= 14)
    ? splitBounds(map.getBounds(), 3)
    : [map.getBounds()];

  tiles.forEach(bounds => {
    TOURIST_TYPES.forEach(type => {
      const key = `${type}_${bounds.getCenter().lat().toFixed(3)}_${bounds.getCenter().lng().toFixed(3)}_${zoom}`;
      if (poiCache.has(key)) {
        poiMarkers.push(...poiCache.get(key));
        return;
      }
      svc.nearbySearch({ bounds, type }, (results, status) => {
        if (status !== google.maps.places.PlacesServiceStatus.OK || !results) return;

        const fresh = results.map(place => {
          const iconUrl = place.icon
            || 'https://maps.gstatic.com/mapfiles/place_api/icons/v1/png_71/generic_business-71.png';
          return new google.maps.Marker({
            position: place.geometry.location,
            icon:     { url: iconUrl, scaledSize: new google.maps.Size(22, 22) },
            title:    place.name,
            map
          });
        });

        poiMarkers.push(...fresh);
        poiCache.set(key, fresh);
        if (poiClusterer) poiClusterer.repaint();
      });
    });
  });

  // now cluster, if a clusterer is loaded
  const ClusterCtor = getClustererCtor();
  if (ClusterCtor) {
    if (!poiClusterer) {
      poiClusterer = new ClusterCtor(map, poiMarkers, CLUSTER_OPTIONS);
    } else {
      poiClusterer.clearMarkers();
      poiClusterer.addMarkers(poiMarkers, /* noDraw= */ true);
    }
  }
}

/* ----------  DEBOUNCE  ---------- */
function debounce(fn, ms = 400) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
}
const debouncedFetchPois = debounce(fetchTouristPois, 500);

/* ----------  MAIN INITIALIZATION  ---------- */
function initializeGoogleMap() {
  const { MAP_CONFIG, MAP_STYLES } = window.TravelConstants;
  const el = document.getElementById('map');
  
  // Create the map
// Create the map
map = new google.maps.Map(el, {
  center: MAP_CONFIG.DEFAULT_CENTER,
  zoom: MAP_CONFIG.DEFAULT_ZOOM,
  mapId: MAP_CONFIG.MAP_ID,
  mapTypeControl: true,
  zoomControl: true,
  scaleControl: true,
  streetViewControl: true,
  fullscreenControl: true,
  styles: MAP_STYLES  // Use styles from constants
});  
  // Initialize directions service
  directionsService = new google.maps.DirectionsService();
  
  // Set up event listeners for POI loading
  //map.addListener('bounds_changed', debouncedFetchPois);
 // map.addListener('zoom_changed', debouncedFetchPois);
  
  // Load initial POIs
 // google.maps.event.addListenerOnce(map, 'idle', fetchTouristPois);
  
  // Mark as loaded
  isGoogleMapsLoaded = true;
  
  console.log('Google Maps initialized successfully');
}

/* ----------  FIT BOUNDS  ---------- */
function fitMapToBounds(bounds, totalStops) {
  const { MAP_CONFIG } = window.TravelConstants;
  if (!bounds.isEmpty() && totalStops) {
    map.fitBounds(bounds);
    google.maps.event.addListenerOnce(map, 'bounds_changed', () => {
      const z = map.getZoom();
      if (z > MAP_CONFIG.MAX_ZOOM)     map.setZoom(MAP_CONFIG.COMFORTABLE_ZOOM);
      else if (z < MAP_CONFIG.MIN_ZOOM) map.setZoom(MAP_CONFIG.OVERVIEW_ZOOM);
    });
  } else {
    map.setCenter(MAP_CONFIG.DEFAULT_CENTER);
    map.setZoom(  MAP_CONFIG.DEFAULT_ZOOM);
  }
}

/* ----------  EXPORT  ---------- */
window.TravelGoogleMaps = {
  initializeGoogleMap,
  getMap:               () => map,
  getDirectionsService: () => directionsService,
  isMapLoaded:          () => isGoogleMapsLoaded,
  fitMapToBounds,
  getColourForDay,
  fetchTouristPois  
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\google-maps.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\markers.js:
// static/js/map/markers.js
// ---------------------------------------------------------
//  • Uses official Google Places icons when available via
//    `stop.iconUrl`; falls back to coloured circles.
//  • getColourForDay(dayIndex) keeps per-day hues consistent.
//  • Exposes window.showPOIs so other modules can drop
//    ad-hoc points of interest onto the same map layer.
// ---------------------------------------------------------

(function() {
    // Check if Google Maps API is loaded
    if (!window.google || !window.google.maps || !window.google.maps.marker) {
        console.error('Google Maps API not fully loaded yet for markers.js - retrying...');
        setTimeout(function() {
            // Retry loading this script
            const script = document.createElement('script');
            script.src = '/travel/static/js/map/markers.js';
            document.head.appendChild(script);
        }, 100);
        return;
    }

    // ---------- Trip-stop markers ----------// ---------- Trip-stop markers ----------


let currentMarkers = [];

/**
 * Create a marker for one itinerary stop (Advanced Markers API)
 */
// Make sure the object exists even if something later throws
if (!window.TravelMarkers) window.TravelMarkers = {};

function createMarker(stop, day, dayIndex, stopIndex) {
  const { isValidCoordinate, createLatLng, debugLog } = window.TravelHelpers;
  const { getMap, getColourForDay } = window.TravelGoogleMaps;
  const { isDayVisible } = window.TravelControls;

  if (!isValidCoordinate(stop.lat, stop.lng)) {
    debugLog(`Skipping stop ${stop.name} – invalid coordinates`, stop);
    return null;
  }

  const position = createLatLng(stop.lat, stop.lng);
  const map      = getMap();

  // Colour code for this day
  const dayColor = getColourForDay(dayIndex);

  const pinElement = new google.maps.marker.PinElement({
    background: dayColor,
    borderColor: '#FFFFFF',
    glyphColor:  '#FFFFFF',
    scale: 1.0
  });
  pinElement.element.style.opacity = '0.8';

  const marker = new google.maps.marker.AdvancedMarkerElement({
    position,
    map: isDayVisible(dayIndex) ? map : null,
    title: stop.name,
    content: pinElement.element,
    gmpClickable: true,
    zIndex: -1000 - stopIndex
  });

  // InfoWindow
  const placeTypeDisplay = stop.placeType
      ? stop.placeType.replace(/_/g, ' ')
      : 'attraction';

  marker.infoWindow = new google.maps.InfoWindow({
    content: `
      <div class="info-window-content" style="
        background:${dayColor};
        border-radius:8px;
        padding:12px;
        box-shadow:0 2px 6px rgba(0,0,0,0.2);
        min-width:200px;">
        <h4 style="margin:0 0 8px 0;font-size:1.1rem;color:#222;">
          ${stop.name}
        </h4>
        <p style="margin:4px 0;font-size:0.9rem;color:#444;">
          ${day.label || `Day ${dayIndex + 1}`} • Stop ${stopIndex + 1} of ${day.stops.length}<br>
          <small style="text-transform:capitalize;color:#666;">
            ${placeTypeDisplay}
          </small>
        </p>
      </div>`
  });

  marker.addListener('click', () => {
    closeAllInfoWindows();
    marker.infoWindow.open(map, marker);
  });

  marker.dayIndex = dayIndex;
  return marker;
}

/**
 * Build all itinerary markers and return viewport bounds
 */
function createAllMarkers(tripData) {
  const { debugLog } = window.TravelHelpers;
  const bounds = new google.maps.LatLngBounds();
  let totalStops = 0;

  clearAllMarkers();

  tripData.days.forEach((day, dayIndex) => {
    debugLog(`Processing day ${dayIndex + 1}: ${day.label}`, day);
    if (!Array.isArray(day.stops)) {
      debugLog(`Day ${dayIndex + 1} has no stops`);
      return;
    }

    day.stops.forEach((stop, stopIndex) => {
      const marker = createMarker(stop, day, dayIndex, stopIndex);
      if (marker) {
        currentMarkers.push(marker);
        bounds.extend(marker.position);
        totalStops += 1;
      }
    });
  });

  debugLog(`Created ${currentMarkers.length} markers for ${totalStops} stops`);
  return { bounds, totalStops };
}

function clearAllMarkers() {
  currentMarkers.forEach(m => {
    m.infoWindow?.close();
    m.map = null;
  });
  currentMarkers = [];
}

function closeAllInfoWindows() {
  currentMarkers.forEach(m => m.infoWindow?.close());
}

function toggleMarkersForDay(dayIndex, visible) {
  const { getMap } = window.TravelGoogleMaps;
  currentMarkers.forEach(m => {
    if (m.dayIndex === dayIndex) {
      m.map = visible ? getMap() : null;
      if (!visible) m.infoWindow?.close();
    }
  });
}

function getAllMarkers() {
  return currentMarkers;
}

// ---------- “Ad-hoc” POI markers for voice chat ----------

let poiMarkers = [];

/**
 * Drop an arbitrary list of POIs on the map (clears previous POI layer)
 * list = [ {name, lat, lng}, … ]
 */
function showPOIs(list) {
  const { getMap } = window.TravelGoogleMaps;
  const map = getMap();

  // clear previous batch
  poiMarkers.forEach(m => m.setMap(null));
  poiMarkers = [];

  list.forEach(({ name, lat, lng }) => {
    const marker = new google.maps.Marker({
      position: { lat, lng },
      title: name,
      map,
      icon: {
        url: '/travel/static/img/poi.svg',
        scaledSize: new google.maps.Size(28, 28)
      }
    });
    poiMarkers.push(marker);
  });
}

// ---------- Exports ----------

Object.assign(window.TravelMarkers, {
  createMarker,
  createAllMarkers,
  clearAllMarkers,
  closeAllInfoWindows,
  toggleMarkersForDay,
  getAllMarkers,
  showPOIs
});

// quick global handles for modules that don’t import TravelMarkers
window.showPOIs = showPOIs;
})();
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\markers.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\routes.js:
// static/js/map/routes.js
// -------------------------------------------------------------
//  • Draws a walking route (Directions API) or, if that fails,
//    a simple geodesic Polyline for each day.
//  • Keeps a per-day colour in sync with marker colours.
//  • Adds drawRoute(encodedPolyline[, day]) so voice-chat
//    can drop a ready-made route on the map in one call.
// -------------------------------------------------------------

(function() {
    if (!window.google || !window.google.maps) {
        console.error('Google Maps API not fully loaded yet for routes.js - retrying...');
        setTimeout(function() {
            const script = document.createElement('script');
            script.src = '/travel/static/js/map/routes.js';
            document.head.appendChild(script);
        }, 100);
        return;
    }

// ---------- internal state ----------

// collection of DirectionsRenderers *and* fallback Polylines
let currentPaths = [];

/** Return the same colour the markers use for this day (0-based index). */
function getRouteColour(dayIndex) {
  return window.TravelGoogleMaps.getColourForDay(dayIndex + 1);
}

// ---------- main “create all” entry point ----------

/**
 * Build routes for every day in a trip data object.
 * tripData = { days:[ {label, stops:[{name,lat,lng}, …]}, … ] }
 */
function createAllRoutes(tripData) {
  const { debugLog } = window.TravelHelpers;

  debugLog('Creating routes for all days …');
  clearAllRoutes();

  tripData.days.forEach((day, dayIndex) => {
    if (Array.isArray(day.stops) && day.stops.length > 1) {
      createDayRoute(day, dayIndex);
    }
  });
}

// ---------- one-day route builder ----------

function createDayRoute(day, dayIndex) {
  const {
    debugLog,
    isValidCoordinate,
    createLatLng
  } = window.TravelHelpers;
  const {
    getMap,
    getDirectionsService
  } = window.TravelGoogleMaps;
  const { TRAVEL_MODE } = window.TravelConstants;
  const { isDayVisible } = window.TravelControls;

  debugLog(`Creating route for Day ${dayIndex + 1} (“${day.label || ''}”)`);

  const validStops = (day.stops || []).filter(s =>
    isValidCoordinate(s.lat, s.lng)
  );
  if (validStops.length < 2) {
    debugLog(`  Day ${dayIndex + 1} has <2 valid stops → no route.`);
    return;
  }

  // Directions-API request
  const origin      = createLatLng(validStops[0].lat, validStops[0].lng);
  const destination = createLatLng(
    validStops[validStops.length - 1].lat,
    validStops[validStops.length - 1].lng
  );
  const waypoints = validStops.slice(1, -1).map(s => ({
    location: createLatLng(s.lat, s.lng),
    stopover: true
  }));

  const request = {
    origin,
    destination,
    waypoints,
    travelMode: TRAVEL_MODE.WALKING,
    optimizeWaypoints: false,
    avoidHighways: true,
    avoidTolls: true
  };

  const directionsService = getDirectionsService();
  const map          = getMap();
  const routeColour  = getRouteColour(dayIndex);

  directionsService.route(request, (result, status) => {
    debugLog(
      `  Directions API response for Day ${dayIndex + 1}: ${status}`
    );

    if (status === 'OK' && result) {
      // use DirectionsRenderer
      const renderer = new google.maps.DirectionsRenderer({
        suppressMarkers: true,
        polylineOptions: {
          strokeColor: routeColour,
          strokeWeight: 4,
          strokeOpacity: 0.8
        },
        suppressInfoWindows: true
      });

      renderer.setDirections(result);
      renderer.dayIndex = dayIndex;
      renderer.setMap(isDayVisible(dayIndex) ? map : null);

      currentPaths.push(renderer);
    } else {
      // fallback
      debugLog(
        `  Directions failed (${status}); using fallback polyline.`
      );
      createSimplePolyline(validStops, dayIndex);
    }
  });
}

// ---------- fallback polyline ----------

function createSimplePolyline(stops, dayIndex) {
  const { debugLog, createLatLng } = window.TravelHelpers;
  const { getMap }                 = window.TravelGoogleMaps;
  const { isDayVisible }           = window.TravelControls;

  debugLog(`  Drawing fallback polyline for Day ${dayIndex + 1}`);

  const pathCoords  = stops.map(s => createLatLng(s.lat, s.lng));
  const routeColour = getRouteColour(dayIndex);
  const map         = getMap();

  const polyline = new google.maps.Polyline({
    path: pathCoords,
    geodesic: true,
    strokeColor: routeColour,
    strokeOpacity: 0.8,
    strokeWeight: 4
  });

  polyline.dayIndex = dayIndex;
  polyline.setMap(isDayVisible(dayIndex) ? map : null);

  currentPaths.push(polyline);
}

// ---------- utilities ----------

function clearAllRoutes() {
  currentPaths.forEach(p => p.setMap?.(null));
  currentPaths = [];
}

function toggleRoutesForDay(dayIndex, visible) {
  const { debugLog } = window.TravelHelpers;
  const { getMap }   = window.TravelGoogleMaps;

  debugLog(
    `Toggling routes for Day ${dayIndex + 1} → ${visible ? 'show' : 'hide'}`
  );

  currentPaths.forEach(p => {
    if (p.dayIndex === dayIndex) {
      p.setMap(visible ? getMap() : null);
    }
  });
}

// ---------- “voice chat” helper ----------
//
// drawRoute(encodedPolyline[, dayIndex = 0])
// ------------------------------------------------
// Called by chat.js when the back-end returns an
// already-computed polyline.

const dayLayers = []; // one Polyline per day

function drawRoute(encoded, day = 0) {
  const map = window.TravelGoogleMaps.getMap();

  // remove old layer for that day, if any
  if (dayLayers[day]) dayLayers[day].setMap(null);

  const path = google.maps.geometry.encoding.decodePath(encoded);
  const line = new google.maps.Polyline({
    path,
    strokeOpacity: 0.9,
    strokeWeight: 4,
    geodesic: true,
    map
  });

  dayLayers[day] = line;

  // fit viewport
  const bounds = new google.maps.LatLngBounds();
  path.forEach(p => bounds.extend(p));
  map.fitBounds(bounds, 80);
}

// ---------- export to global namespace ----------

window.TravelRoutes = {
  createAllRoutes,
  createDayRoute,
  clearAllRoutes,
  toggleRoutesForDay
};

// Make the quick helper globally reachable (e.g. from chat.js)
window.drawRoute = drawRoute;
})();
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\routes.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\form.js:
// static/js/ui/form.js - Form Handling

/**
 * Initialize form event handlers
 */
function initializeForm() {
    const { debugLog } = window.TravelHelpers;
    const form = document.getElementById("trip-form");
    
    if (form) {
        form.addEventListener("submit", handleFormSubmit);
        debugLog("Form handler initialized");
    }
}

/**
 * Handle form submission
 */
async function handleFormSubmit(e) {
    e.preventDefault();
    
    const { debugLog } = window.TravelHelpers;
    const { showError } = window.TravelOverlays;
    const { processItinerary } = window.TravelApp;
    
    const city = document.getElementById("city").value.trim();
    const days = parseInt(document.getElementById("days").value, 10);
    
    debugLog(`Planning trip: ${city}, ${days} days`);
    
    if (city && days > 0) {
        try {
            await processItinerary(city, days);
        } catch (error) {
            showError(`Failed to process itinerary: ${error.message}`);
        }
    } else {
        showError("Please enter a valid city name and number of days");
    }
}

// Export for other modules
window.TravelForm = {
    initializeForm
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\form.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\overlays.js:
// static/js/ui/overlays.js - Loading and Error Overlays

/**
 * Show loading overlay on top of the map
 */
function showLoading(message) {
    const { ensureRelativePosition } = window.TravelHelpers;
    const mapElement = document.getElementById("map");
    if (!mapElement) return;
    ensureRelativePosition(mapElement);

    let overlay = document.getElementById("map-overlay");
    if (!overlay) {
        overlay = document.createElement("div");
        overlay.id = "map-overlay";
        overlay.style.cssText = `
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            color: #f2f2f2;
            font-size: 1.1rem;
            text-align: center;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        `;
        mapElement.appendChild(overlay);
    }
    
    overlay.innerHTML = `
        <p style="margin: 0 0 0.5rem;">🔄 ${message}</p>
        <p><small>This may take a few moments…</small></p>
    `;
    overlay.classList.add("visible");
}

/**
 * Show error overlay on top of the map
 */
function showError(message) {
    const { ensureRelativePosition, errorLog } = window.TravelHelpers;
    errorLog("Showing error:", message);
    
    const mapElement = document.getElementById("map");
    if (!mapElement) return;
    ensureRelativePosition(mapElement);

    let overlay = document.getElementById("map-overlay");
    if (!overlay) {
        overlay = document.createElement("div");
        overlay.id = "map-overlay";
        overlay.style.cssText = `
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            color: #c0392b;
            font-size: 1.1rem;
            text-align: center;
            z-index: 5;
            pointer-events: auto;
            transition: opacity 0.2s ease;
        `;
        mapElement.appendChild(overlay);
    } else {
        // If overlay existed from showLoading, override styling
        overlay.style.background = "rgba(255, 255, 255, 0.9)";
        overlay.style.color = "#c0392b";
        overlay.style.pointerEvents = "auto";
    }

    overlay.innerHTML = `
        <h3 style="margin-top: 0;">⚠️ Error</h3>
        <div style="max-width: 500px; text-align: left; margin: 0 auto;">
            ${message}
        </div>
        <button onclick="location.reload()"
                style="margin-top: 1rem;
                       padding: 0.4rem 1rem;
                       background: #007bff;
                       color: white;
                       border: none;
                       border-radius: 4px;
                       cursor: pointer;">
            Reload
        </button>
    `;
    overlay.classList.add("visible");
}

/**
 * Hide any loading/error overlay
 */
function hideOverlay() {
    const el = document.getElementById("map-overlay");
    if (el) {
        el.classList.remove("visible");
        el.innerHTML = "";
    }
}

// Export for other modules
window.TravelOverlays = {
    showLoading,
    showError,
    hideOverlay
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\overlays.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\panel.js:
// static/js/ui/panel.js  – Minimise / expand logic
// -------------------------------------------------
// • Adds / removes the class "minimized" on #panel.
// • CSS in panel.css already hides the form inputs and
//   keeps only the Day-controls row visible in that state.

function initializePanel() {
  const panel       = document.getElementById('panel');
  const minimizeBtn = document.getElementById('minimize-btn');

  // defensive – if markup missing, bail early
  if (!panel || !minimizeBtn) return;

  let isMinimized = false;

  minimizeBtn.addEventListener('click', () => {
    isMinimized = !isMinimized;

    // ↓ this is the only class the CSS cares about
    panel.classList.toggle('minimized', isMinimized);

    // update button glyph & tooltip
    minimizeBtn.textContent = isMinimized ? '+' : '−';
    minimizeBtn.title       = isMinimized ? 'Expand' : 'Minimize';
  });
}

// expose for main app bootstrap
window.TravelPanel = { initializePanel };

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\panel.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\constants.js:
// static/js/utils/constants.js – Shared constants (vector-map ready)
// -----------------------------------------------------------------

// 1) Map configuration
const MAP_CONFIG = {
  DEFAULT_CENTER   : { lat: 48.8566, lng: 2.3522 },
  DEFAULT_ZOOM     : 13,
  MAX_ZOOM         : 16,
  MIN_ZOOM         : 10,
  COMFORTABLE_ZOOM : 14,
  OVERVIEW_ZOOM    : 12,
  
  // Comment out or remove the MAP_ID
  MAP_ID: 'c3bdabd61cc122adbb5aee9d'
};

// 2) Travel mode
const TRAVEL_MODE = { WALKING: 'WALKING' };

// 3) UI colours
const COLORS = {
  DEFAULT_ROUTE : '#4285f4',
  DAY_COLORS    : [
    '#ff6b6b', '#4ecdc4', '#45b7d1',
    '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'
  ]
};

// 4) API endpoints
const API_ENDPOINTS = {
  CONFIG   : '/travel/api/config',
  ITINERARY: '/travel/api/itinerary'
};

// 5) Comprehensive map styles - hide only road labels, keep everything else
const MAP_STYLES = [
  /* ----- POI visibility ----- */
  // Hide ALL POI text labels
  {
    featureType: 'poi',
    elementType: 'labels.text',
    stylers: [{ visibility: 'off' }]
  },
  // Show POI icons (museums, parks, attractions, etc.)
  {
    featureType: 'poi',
    elementType: 'labels.icon',
    stylers: [{ visibility: 'on' }]
  },
  // … except for generic businesses, which we still hide:
  {
    featureType: 'poi.business',
    elementType: 'labels.icon',
    stylers: [{ visibility: 'off' }]
  },

  /* ----- Road / transit / neighbourhood clutter ----- */
  { featureType: 'road.local',           elementType: 'labels',       stylers: [{ visibility: 'off' }] },
  { featureType: 'road.arterial',        elementType: 'labels.text',  stylers: [{ visibility: 'off' }] },
  { featureType: 'road.highway',         elementType: 'labels.icon',  stylers: [{ visibility: 'off' }] },
  { featureType: 'road.arterial',        elementType: 'labels.icon',  stylers: [{ visibility: 'off' }] },
  { featureType: 'road.local',           elementType: 'labels.icon',  stylers: [{ visibility: 'off' }] },
  { featureType: 'transit',              elementType: 'labels',       stylers: [{ visibility: 'off' }] },
  { featureType: 'administrative.neighborhood', elementType: 'labels', stylers: [{ visibility: 'off' }] },

  /* ----- Subtle visual tweaks ----- */
  { elementType: 'labels.text.fill',   stylers: [{ lightness: 35 }] },
  { elementType: 'labels.text.stroke', stylers: [{ visibility: 'on' }, { lightness: 65 }] },
  { elementType: 'geometry',           stylers: [{ lightness: 10 }] }
];
// 6) Export everything
window.TravelConstants = {
  MAP_CONFIG,
  TRAVEL_MODE,
  COLORS,
  API_ENDPOINTS,
  MAP_STYLES
};

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\constants.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\helpers.js:
// static/js/utils/helpers.js - Utility Functions

/**
 * Ensure an element has relative positioning for overlays
 */
function ensureRelativePosition(el) {
    const pos = getComputedStyle(el).position;
    if (pos === 'static' || !pos) {
        el.style.position = 'relative';
    }
}

/**
 * Validate coordinates
 */
function isValidCoordinate(lat, lng) {
    return lat && lng && !isNaN(lat) && !isNaN(lng) && 
           lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
}

/**
 * Create a Google Maps LatLng object
 */
function createLatLng(lat, lng) {
    return { lat: Number(lat), lng: Number(lng) };
}

/**
 * Debug logging helper
 */
function debugLog(message, data = null) {
    if (console && console.log) {
        if (data) {
            console.log(message, data);
        } else {
            console.log(message);
        }
    }
}

/**
 * Error logging helper
 */
function errorLog(message, error = null) {
    if (console && console.error) {
        if (error) {
            console.error(message, error);
        } else {
            console.error(message);
        }
    }
}

/**
 * Create a promise that resolves after a delay
 */
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Export for other modules
window.TravelHelpers = {
    ensureRelativePosition,
    isValidCoordinate,
    createLatLng,
    debugLog,
    errorLog,
    delay
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\helpers.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\temp.txt:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\temp.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\templates\map.html:
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PiText - Travel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/travel/static/PiText_favicon.ico" />

  <!-- CSS Files -->
  <link rel="stylesheet" href="/travel/static/css/base.css" />
  <link rel="stylesheet" href="/travel/static/css/map.css" />
  <link rel="stylesheet" href="/travel/static/css/controls.css" />
  <link rel="stylesheet" href="/travel/static/css/panel.css" />
  <link rel="stylesheet" href="/travel/static/css/chat.css"/>
</head>
<body>
  <!-- Full-Screen Map Container -->
  <div id="map">
    <!-- Initial "Ready" message -->
    <div class="loading">
      <p>🗺️ Ready to plan your trip?</p>
      <p><small>Enter a city &amp; days, then click "Start Planning".</small></p>
    </div>
  </div>
  <!-- Voice-chat mic button -->
<button id="mic-btn" class="mic-btn" aria-label="Start voice chat">

  <!-- Sliding chat panel -->
  <aside id="chat-panel" class="chat-panel" aria-live="polite"></aside>

  <!-- simple SVG icon keeps it self-contained -->
  <svg viewBox="0 0 24 24" width="24" height="24">
    <path d="M12 2a4 4 0 0 1 4 4v6a4 4 0 1 1-8 0V6a4 4 0 0 1 4-4zM5 11h2a5 5 0 0 0 10 0h2a7 7 0 0 1-14 0zm7 9v-3h-2v3H8v2h8v-2h-4z"/>
  </svg>
</button>


  <!-- Transparent Outer Panel -->
  <div id="panel">
    <button id="minimize-btn" title="Minimize/Expand">−</button>
    <!-- Inner Panel: blur  white background  rounding -->
    <div id="inner-panel">
    <div id="day-controls"></div>

      <form id="trip-form">
        <input id="city" type="text" placeholder="Enter city name" value="Paris" required />
        <input id="days" type="number" min="1" max="14" value="3" required />
        <button type="submit">Start Planning</button>
      </form>
    </div>
  </div>



  <!-- Loading / Error Overlay (injected by JS) -->
  <div id="map-overlay"></div>

  <!-- JavaScript Files - Load in dependency order -->
  <!-- Utilities first -->
  <script src="/travel/static/js/utils/constants.js"></script>
  <script src="/travel/static/js/utils/helpers.js"></script>
  
  <!-- API Layer -->
  <script src="/travel/static/js/api/config.js"></script>
  <script src="/travel/static/js/api/client.js"></script>
  
  <!-- UI Components -->
  <script src="/travel/static/js/ui/overlays.js"></script>
  <script src="/travel/static/js/ui/panel.js"></script>
  <script src="/travel/static/js/ui/form.js"></script>
  
<!-- Map components (must stay in this order) -->
<!-- Map components (must stay in this order) -->
<!-- Map components (must stay in this order) -->
<script src="/travel/static/js/map/google-maps.js"></script>

<!-- Dynamically load map modules after Google Maps is ready -->
<script>
window.mapModulesLoaded = false;
window.mapModulesReady = false;

window.loadMapModules = function() {
    if (window.mapModulesLoaded) return;
    
    // Ensure Google Maps is fully ready
    if (!window.google || !window.google.maps || !window.google.maps.marker) {
        console.log('Waiting for Google Maps to be fully ready...');
        setTimeout(window.loadMapModules, 100);
        return;
    }
    
    const scripts = [
        '/travel/static/js/map/markers.js',
        '/travel/static/js/map/routes.js', 
        '/travel/static/js/map/controls.js'
    ];
    
    let loadedCount = 0;
    
    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    // Load scripts sequentially to ensure proper order
    Promise.all(scripts.map(loadScript))
        .then(() => {
            window.mapModulesLoaded = true;
            window.mapModulesReady = true;
            console.log('All map modules loaded successfully');
            
            // Trigger any pending renders
            if (window.pendingRender) {
                window.TravelApp.renderTripOnMap(window.pendingRender);
                window.pendingRender = null;
            }
        })
        .catch(err => {
            console.error('Failed to load map modules:', err);
        });
};
</script>
<!-- Marker-clusterer library -->
<script src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js"></script>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>


<!-- Voice/chat helpers -->
<script src="/travel/static/js/voice.js"></script>
<script src="/travel/static/js/chat.js"></script>

<!-- Main app (calls renderTripOnMap) – must be last, NO DEFER -->
<script src="/travel/static/js/app.js"></script>

</body>
</html>
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\templates\map.html ---


--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travelCode Folder compiled_folder_content.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\render.yaml:
services:
  - type: web
    name: PiText-Router
    runtime: python
    buildCommand: |
      echo "=== Project structure ==="
      ls -la
      echo "=== Installing dependencies ==="
      pip install -r requirements.txt
      echo "=== Installing desktop dependencies ==="
      cd pitext-desktop && pip install -r requirements.txt && cd ..
      echo "=== Installing mobile dependencies ==="
      cd pitext-mobile && pip install -r requirements.txt && cd ..
      echo "=== Installing router dependencies ==="
      cd router-backend && pip install -r requirements.txt && cd ..
      echo "=== Installing playwright ==="
      playwright install chromium --with-deps
      echo "=== Making start script executable ==="
      chmod +x start.sh
      echo "=== Final structure check ==="
      ls -la
      ls -la pitext-desktop/
      ls -la pitext-mobile/
      ls -la router-backend/
  startCommand: uvicorn router-backend.router_app:app --host 0.0.0.0 --port $PORT
    envVars:
      - key: PORT
        value: "10000"
      - key: OPENAI_API_KEY
        sync: false
      - key: RENDER_MODE
        value: html
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\render.yaml ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\requirements.txt:
fastapi>=0.110
uvicorn[standard]==0.24.0
openai>=1.14
anthropic==0.18.1
python-dotenv>=1.0
playwright==1.40.0
pillow==10.1.0
python-multipart==0.0.6
httpx==0.25.2
Flask>=2.3.0
asgiref>=3.0.0
googlemaps==4.10.0      
Flask-Session==0.5.0
flask-socketio>=5.5.1 
python-socketio>=5.11
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\main.py:
# main.py
"""
PiText desktop- Main application entry point.
"""

import logging
import sys
from pathlib import Path

import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse
from fastapi.staticfiles import StaticFiles

# Ensure project root is on sys.path
sys.path.insert(0, str(Path(__file__).parent))

from api.routes import router, setup_static_routes
from api.middleware import setup_middleware
from core.config import get_config


def setup_logging():
    """Configure application logging."""
    logging.basicConfig(
        level=logging.INFO,  # Ensure this is INFO, not DEBUG
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)]
    )
    
    # Set specific loggers to INFO level
    logging.getLogger("core.pipeline").setLevel(logging.INFO)
    logging.getLogger("core.sanitizer").setLevel(logging.INFO)
    logging.getLogger("api.routes").setLevel(logging.INFO)

def create_app() -> FastAPI:
    """Create and configure the FastAPI application."""
    config = get_config()

    app = FastAPI(
        title="PiText CodeGen",
        description="Visual code generation and Mermaid diagram creator",
        version="0.1.0",
    )

    # Middleware (CORS, Logging, Security, etc.)
    setup_middleware(app)

    # Mount static files
    setup_static_routes(app)

    # API routes
    app.include_router(router)

    # Root redirect
    @app.get("/", include_in_schema=False)
    async def root_redirect():
        return RedirectResponse(url=config.API_PREFIX or "/codegen")

    return app


def main():
    setup_logging()
    config = get_config()

    app = create_app()

    logging.info(f"PiText CodeGen running at http://{config.HOST}:{config.PORT}")

    uvicorn.run(
        app,
        host=config.HOST,
        port=config.PORT,
        reload=True,
    )


app = create_app()

if __name__ == "__main__":
    main()

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\main.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\render.yaml:
services:
  - type: web
    name: PiText-Router
    runtime: python
    buildCommand: |
      echo "=== Project structure ==="
      ls -la
      echo "=== Installing dependencies ==="
      pip install -r requirements.txt
      echo "=== Installing desktop dependencies ==="
      cd pitext-desktop && pip install -r requirements.txt && cd ..
      echo "=== Installing mobile dependencies ==="
      cd pitext-mobile && pip install -r requirements.txt && cd ..
      echo "=== Installing router dependencies ==="
      cd router-backend && pip install -r requirements.txt && cd ..
      echo "=== Installing playwright ==="
      playwright install chromium --with-deps
      echo "=== Making start script executable ==="
      chmod +x start.sh
      echo "=== Final structure check ==="
      ls -la
      ls -la pitext-desktop/
      ls -la pitext-mobile/
      ls -la router-backend/
  startCommand: uvicorn pitext_desktop.main:create_app --host 0.0.0.0 --port 8000 --log-level debug

    envVars:
      - key: PORT
        value: "10000"
      - key: OPENAI_API_KEY
        sync: false
      - key: RENDER_MODE
        value: html
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\render.yaml ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\requirements.txt:
fastapi==0.104.1
uvicorn[standard]==0.24.0
openai==1.12.0
anthropic==0.18.1
python-dotenv==1.0.0
playwright==1.40.0
pillow==10.1.0
python-multipart==0.0.6
httpx==0.25.2
Flask>=2.3.0
asgiref>=3.0.0

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\middleware.py:
# api/middleware.py
"""
Middleware configuration for PiText Desktop.
Handles CORS, logging, error handling, and request/response processing.
"""

import time
import logging
from typing import Callable
from uuid import uuid4

from fastapi import FastAPI, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from core.config import get_config
from api.models import create_error_response


logger = logging.getLogger(__name__)


def setup_cors(app: FastAPI) -> None:
    """
    Configure CORS middleware for the application.
    
    Args:
        app: FastAPI application instance
    """
    config = get_config()
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=config.CORS_ORIGINS,
        allow_credentials=config.CORS_ALLOW_CREDENTIALS,
        allow_methods=config.CORS_ALLOW_METHODS,
        allow_headers=config.CORS_ALLOW_HEADERS,
    )
    
    logger.info(f"CORS configured with origins: {config.CORS_ORIGINS}")


async def log_requests(request: Request, call_next: Callable) -> Response:
    """
    Middleware to log all incoming requests and their processing time.
    
    Args:
        request: Incoming request
        call_next: Next middleware/handler in chain
        
    Returns:
        Response from the handler
    """
    # Generate request ID for tracking
    request_id = str(uuid4())[:8]
    
    # Log request start
    start_time = time.time()
    logger.info(
        f"[{request_id}] {request.method} {request.url.path} "
        f"from {request.client.host if request.client else 'unknown'}"
    )
    
    # Process request
    response = await call_next(request)
    
    # Calculate processing time
    process_time = time.time() - start_time
    
    # Log request completion
    logger.info(
        f"[{request_id}] Completed in {process_time:.3f}s "
        f"with status {response.status_code}"
    )
    
    # Add custom headers
    response.headers["X-Request-ID"] = request_id
    response.headers["X-Process-Time"] = f"{process_time:.3f}"
    
    return response


async def handle_errors(request: Request, call_next: Callable) -> Response:
    """
    Global error handling middleware.
    
    Catches unhandled exceptions and returns consistent error responses.
    
    Args:
        request: Incoming request
        call_next: Next middleware/handler in chain
        
    Returns:
        Response from the handler or error response
    """
    try:
        return await call_next(request)
    except Exception as e:
        logger.error(
            f"Unhandled exception for {request.method} {request.url.path}: {str(e)}",
            exc_info=True
        )
        
        # Don't expose internal errors in production
        config = get_config()
        if config.is_production():
            error_detail = "An internal error occurred"
        else:
            error_detail = str(e)
        
        return JSONResponse(
            status_code=500,
            content=create_error_response(
                detail=error_detail,
                error_type="internal_error"
            )
        )


async def add_security_headers(request: Request, call_next: Callable) -> Response:
    """
    Add security headers to all responses.
    
    Args:
        request: Incoming request
        call_next: Next middleware/handler in chain
        
    Returns:
        Response with security headers
    """
    response = await call_next(request)
    
    # Add security headers
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    
    # Add cache headers for static assets
    if request.url.path.startswith(f"{get_config().API_PREFIX}/assets"):
        response.headers["Cache-Control"] = "public, max-age=31536000"  # 1 year
    elif request.url.path.endswith((".js", ".css")):
        response.headers["Cache-Control"] = "public, max-age=86400"  # 1 day
    
    return response


def setup_middleware(app: FastAPI) -> None:
    """
    Configure all middleware for the application.
    
    Order matters! Middleware is executed in reverse order for responses.
    
    Args:
        app: FastAPI application instance
    """
    # CORS should be first
    setup_cors(app)
    
    # Add custom middleware (order matters for response processing)
    app.middleware("http")(add_security_headers)
    app.middleware("http")(handle_errors)
    app.middleware("http")(log_requests)
    
    logger.info("All middleware configured")


def setup_exception_handlers(app: FastAPI) -> None:
    """
    Configure custom exception handlers.
    
    Args:
        app: FastAPI application instance
    """
    @app.exception_handler(ValueError)
    async def value_error_handler(request: Request, exc: ValueError):
        """Handle ValueError exceptions."""
        return JSONResponse(
            status_code=400,
            content=create_error_response(
                detail=str(exc),
                error_type="validation_error"
            )
        )
    
    @app.exception_handler(404)
    async def not_found_handler(request: Request, exc):
        """Handle 404 errors."""
        return JSONResponse(
            status_code=404,
            content=create_error_response(
                detail=f"Path {request.url.path} not found",
                error_type="not_found"
            )
        )
    
    logger.info("Exception handlers configured")

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\middleware.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\models.py:
# api/models.py
"""
Pydantic models for API requests and responses.
Defines the contract between frontend and backend.
"""

from typing import Optional, Literal, Dict, Any
from pydantic import BaseModel, Field, validator


# ============================================================================
# Request Models
# ============================================================================

class DescribeRequest(BaseModel):
    """Request to generate a diagram from a query."""
    query: str = Field(..., min_length=1, max_length=1000)
    
    @validator('query')
    def validate_query(cls, v):
        """Ensure query is not just whitespace."""
        if not v.strip():
            raise ValueError("Query cannot be empty or just whitespace")
        return v.strip()


class DeepDiveRequest(BaseModel):
    """Request for contextual information about selected diagram content."""
    selected_text: str = Field(..., min_length=1, max_length=5000)
    question: str = Field(..., min_length=1, max_length=500)
    original_query: str = Field(default="", max_length=1000)
    
    @validator('selected_text', 'question')
    def validate_not_empty(cls, v):
        """Ensure text fields are not just whitespace."""
        if not v.strip():
            raise ValueError("Field cannot be empty or just whitespace")
        return v.strip()


# ============================================================================
# Response Models
# ============================================================================

class DiagramResponse(BaseModel):
    """Response containing the generated diagram and metadata."""
    success: bool = True
    query: str
    description: str = Field(..., description="Text description of the content")
    # NEW — raw bullet-points / prompt fed into Mermaid
    content: str = Field(..., description="Raw text used to build the diagram")
    diagram_type: Literal["flowchart", "radial_mindmap", "sequence_comparison"]
    diagram: str = Field(..., description="Mermaid diagram code")
    render_type: Literal["html", "image"] = "html"
    rendered_content: Optional[str] = Field(
        None, 
        description="Rendered diagram (HTML or base64 image)"
    )
    
    class Config:
        schema_extra = {
            "example": {
                "success": True,
                "query": "How do rainbows form?",
                "description": "Rainbow formation process...",
                "diagram_type": "flowchart",
                "diagram": "flowchart TD\n    A[Start] ==> B[End]",
                "render_type": "html",
                "rendered_content": "<div>...</div>"
            }
        }


class DeepDiveResponse(BaseModel):
    """Response containing contextual information about selected content."""
    success: bool = True
    response: str = Field(..., description="Detailed explanation")
    
    class Config:
        schema_extra = {
            "example": {
                "success": True,
                "response": "The selected concept refers to..."
            }
        }


class ErrorResponse(BaseModel):
    """Standard error response format."""
    success: bool = False
    detail: str = Field(..., description="Error message")
    error_type: Optional[str] = Field(None, description="Error classification")
    
    class Config:
        schema_extra = {
            "example": {
                "success": False,
                "detail": "Query is required",
                "error_type": "validation_error"
            }
        }


class HealthResponse(BaseModel):
    """Health check response."""
    message: str = "LLM Diagram Service is running!"
    status: Literal["healthy", "degraded", "unhealthy"] = "healthy"
    version: Optional[str] = Field(None, description="Application version")
    
    class Config:
        schema_extra = {
            "example": {
                "message": "LLM Diagram Service is running!",
                "status": "healthy",
                "version": "1.0.0"
            }
        }


# ============================================================================
# Internal Models (used between services)
# ============================================================================

class DiagramGenerationResult(BaseModel):
    """Internal model for diagram generation results."""
    diagram_type: Literal["flowchart", "radial_mindmap", "sequence_comparison"]
    content_description: str
    mermaid_code: str
    raw_llm_output: Optional[str] = Field(
        None, 
        description="Raw LLM output for debugging"
    )


class RenderResult(BaseModel):
    """Internal model for rendering results."""
    render_type: Literal["html", "image"]
    rendered_content: str


# ============================================================================
# Utility Functions
# ============================================================================

def create_error_response(
    detail: str, 
    error_type: Optional[str] = None
) -> Dict[str, Any]:
    """Create a standardized error response dictionary."""
    return ErrorResponse(
        detail=detail,
        error_type=error_type
    ).dict()


def create_success_response(
    data: BaseModel
) -> Dict[str, Any]:
    """Ensure response includes success=True."""
    response = data.dict()
    response["success"] = True
    return response

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\models.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\routes.py:
# api/routes.py
"""
API route definitions for PiText Desktop.
Handles all /desktop/* endpoints.
"""

from pathlib import Path
import logging

from fastapi import APIRouter, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

from api.models import (
    DescribeRequest,
    DeepDiveRequest,
    DiagramResponse,
    DeepDiveResponse,
    HealthResponse,
    create_error_response,
)
from core.config import get_config
from core.pipeline import process_pipeline
from core.sanitizer import sanitize_mermaid                 # ← NEW
from services.llm.diagram import generate_deep_dive_response

logger = logging.getLogger(__name__)
config = get_config()

# ---------------------------------------------------------------------------
# Router
# ---------------------------------------------------------------------------

router = APIRouter(prefix=config.API_PREFIX)

# ---------------------------------------------------------------------------
# API End‑points
# ---------------------------------------------------------------------------


@router.post("/describe", response_model=DiagramResponse)
async def describe(request: DescribeRequest):
    """Generate a diagram from a text query."""
    try:
        logger.info("Processing describe request: %s...", request.query[:50])

        result = await process_pipeline(request.query)

        # Log the final diagram code being sent to client
        diagram_code = result.get("diagram", "")
        logger.info("📤 Final Mermaid code being sent to client for '%s':\n%s", 
                    request.query[:50], diagram_code)

        return DiagramResponse(query=request.query, **result)

    except ValueError as exc:
        logger.error("Validation error: %s", exc)
        raise HTTPException(
            status_code=400,
            detail=create_error_response(str(exc), "validation_error"),
        ) from exc

@router.post("/deep-dive", response_model=DeepDiveResponse)
async def deep_dive(request: DeepDiveRequest):
    """
    Generate an explanatory answer about selected diagram content.
    """
    try:
        logger.info(
            "Deep‑dive request – Text: %s..., Question: %s...",
            request.selected_text[:30],
            request.question[:50],
        )

        response = await generate_deep_dive_response(
            selected_text=request.selected_text,
            question=request.question,
            original_query=request.original_query,
        )

        return DeepDiveResponse(response=response)

    except ValueError as exc:
        logger.error("Validation error: %s", exc)
        raise HTTPException(
            status_code=400,
            detail=create_error_response(str(exc), "validation_error"),
        ) from exc
    except Exception as exc:  # noqa: BLE001
        logger.error("Unexpected error in deep‑dive: %s", exc, exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=create_error_response(
                "An error occurred while generating the response",
                "internal_error",
            ),
        ) from exc


@router.get("/health", response_model=HealthResponse)
async def health_check():
    """
    Health‑check end‑point.
    """
    return HealthResponse(status="healthy", version="1.0.0")


# ---------------------------------------------------------------------------
# Static file serving
# ---------------------------------------------------------------------------


def setup_static_routes(app):
    """
    Register static‑file mounts for the desktop front‑end.
    """
    app.mount(
        f"{config.API_PREFIX}/assets",
        StaticFiles(directory=str(config.PUBLIC_DIR / "assets")),
        name="assets",
    )
    app.mount(
        f"{config.API_PREFIX}/js",
        StaticFiles(directory=str(config.PUBLIC_DIR / "js")),
        name="js",
    )
    app.mount(
        f"{config.API_PREFIX}/css",
        StaticFiles(directory=str(config.PUBLIC_DIR / "css")),
        name="css",
    )

    @app.get(config.API_PREFIX)
    @app.get(f"{config.API_PREFIX}/")
    async def desktop_root():  # noqa: D401, ANN001
        """Serve the main desktop application."""
        index_path = config.PUBLIC_DIR / "index.html"
        if not index_path.exists():
            logger.error("index.html not found at %s", index_path)
            raise HTTPException(
                status_code=500, detail="Application files not found"
            )
        return FileResponse(index_path)

    @app.get(f"{config.API_PREFIX}/{{path:path}}")
    async def catch_all(path: str):  # noqa: D401
        """
        Client‑side routing fall‑back.
        """
        file_path = config.PUBLIC_DIR / path
        if file_path.exists() and file_path.is_file():
            return FileResponse(file_path)

        index_path = config.PUBLIC_DIR / "index.html"
        if index_path.exists():
            return FileResponse(index_path)

        raise HTTPException(status_code=404, detail="Not found")

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\routes.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\api\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\config.py:
# core/config.py
"""
Configuration management for PiText Desktop.
Centralizes all environment variables and configuration settings.
"""

import os
from pathlib import Path
from typing import Optional, Literal
from functools import lru_cache
from dotenv import load_dotenv

# Load environment variables
load_dotenv()


class Config:
    """Application configuration singleton."""
    
    # Paths
    BASE_DIR: Path = Path(__file__).parent.parent
    PROMPTS_DIR: Path = BASE_DIR / "prompts"
    PUBLIC_DIR: Path = BASE_DIR / "public"
    
    # API Settings
    API_PREFIX: str = "/desktop"
    HOST: str = "0.0.0.0"
    PORT: int = int(os.getenv("PORT", 3000))
    
    # OpenAI Settings
    OPENAI_API_KEY: Optional[str] = os.getenv("OPENAI_API_KEY")
    OPENAI_MODEL: str = "gpt-4.1"
    OPENAI_TEMPERATURE: float = 0.7
    OPENAI_MAX_TOKENS_CONTENT: int = 500
    OPENAI_MAX_TOKENS_DIAGRAM: int = 1500
    OPENAI_MAX_TOKENS_SELECTOR: int = 5
    
    # Rendering Settings
    RENDER_MODE: Literal["html", "image"] = os.getenv("RENDER_MODE", "html").lower()  # type: ignore
    
    # Playwright Settings (for image rendering)
    PLAYWRIGHT_TIMEOUT: int = 10000  # ms
    PLAYWRIGHT_ARGS: list[str] = ['--no-sandbox', '--disable-setuid-sandbox']
    
    # CORS Settings
    CORS_ORIGINS: list[str] = ["*"]
    CORS_ALLOW_CREDENTIALS: bool = True
    CORS_ALLOW_METHODS: list[str] = ["*"]
    CORS_ALLOW_HEADERS: list[str] = ["*"]
    
    # Logging
    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO")
    LOG_FORMAT: str = "%(asctime)s [%(levelname)s] %(message)s"
    
    @classmethod
    def validate(cls) -> None:
        """Validate required configuration."""
        if not cls.OPENAI_API_KEY:
            raise ValueError(
                "OPENAI_API_KEY environment variable is required. "
                "Please set it in your .env file or environment."
            )
        
        if cls.RENDER_MODE not in ("html", "image"):
            raise ValueError(
                f"Invalid RENDER_MODE: {cls.RENDER_MODE}. "
                "Must be either 'html' or 'image'."
            )
        
        if not cls.PROMPTS_DIR.exists():
            raise ValueError(f"Prompts directory not found: {cls.PROMPTS_DIR}")
        
        if not cls.PUBLIC_DIR.exists():
            raise ValueError(f"Public directory not found: {cls.PUBLIC_DIR}")
    
    @classmethod
    def get_prompt_path(cls, filename: str) -> Path:
        """Get the full path to a prompt file."""
        path = cls.PROMPTS_DIR / filename
        if not path.exists():
            raise FileNotFoundError(f"Prompt file not found: {filename}")
        return path
    
    @classmethod
    def is_development(cls) -> bool:
        """Check if running in development mode."""
        return os.getenv("ENV", "development").lower() == "development"
    
    @classmethod
    def is_production(cls) -> bool:
        """Check if running in production mode."""
        return os.getenv("ENV", "development").lower() == "production"


@lru_cache()
def get_config() -> type[Config]:
    """Get validated configuration singleton."""
    Config.validate()
    return Config


# Validate configuration on module import
try:
    Config.validate()
except ValueError as e:
    # Only raise in production, warn in development
    if Config.is_production():
        raise
    else:
        import warnings
        warnings.warn(f"Configuration warning: {e}")

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\config.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\pipeline.py:
# core/pipeline.py
"""
Pipeline orchestration for diagram generation.
Coordinates the flow from query to final diagram.
"""

import logging
from typing import Dict, Any

from core.sanitizer import sanitize_mermaid
from services.llm.diagram import (
    select_diagram_type,
    generate_content,
    generate_diagram_code
)
from services.renderer import render_diagram
from api.models import DiagramGenerationResult, RenderResult


logger = logging.getLogger(__name__)


class DiagramPipeline:
    """Orchestrates the diagram generation pipeline."""
    
    def __init__(self):
        """Initialize the pipeline."""
        self.stages = [
            ("Selecting diagram type", self._select_type),
            ("Generating content", self._generate_content),
            ("Creating diagram", self._create_diagram),
            ("Sanitizing output", self._sanitize_diagram),
            ("Rendering diagram", self._render_diagram)
        ]
    
    async def process(self, query: str) -> Dict[str, Any]:
        """
        Process a query through the complete pipeline.
        
        Args:
            query: User's query text
            
        Returns:
            Dict containing all pipeline results
            
        Raises:
            Exception: If any pipeline stage fails
        """
        logger.info(f"Starting pipeline for query: {query[:50]}...")
        
        # Initialize pipeline context
        context = {
            "query": query,
            "diagram_type": None,
            "content_description": None,
            "raw_diagram": None,
            "sanitized_diagram": None,
            "render_result": None
        }
        
        # Execute pipeline stages
        for stage_name, stage_func in self.stages:
            logger.info(f"Stage: {stage_name}")
            try:
                await stage_func(context)
            except Exception as e:
                logger.error(f"Pipeline failed at stage '{stage_name}': {str(e)}")
                raise
        
        # Build final result
        return self._build_result(context)
    
    async def _select_type(self, context: Dict[str, Any]) -> None:
        """Stage 1: Select the appropriate diagram type."""
        context["diagram_type"] = await select_diagram_type(context["query"])
        logger.info(f"Selected diagram type: {context['diagram_type']}")
    
    async def _generate_content(self, context: Dict[str, Any]) -> None:
        """Stage 2: Generate content description."""
        context["content_description"] = await generate_content(
            query=context["query"],
            diagram_type=context["diagram_type"]
        )
        logger.debug("🟡 RAW Mermaid code ↓\n%s", context["raw_diagram"])
    
    async def _create_diagram(self, context: Dict[str, Any]) -> None:
        """Stage 3: Generate Mermaid diagram code."""
        context["raw_diagram"] = await generate_diagram_code(
            content_description=context["content_description"],
            original_query=context["query"],
            diagram_type=context["diagram_type"]
        )
        
        # Log raw Mermaid code at INFO level so it shows in render logs
        logger.info("🟡 RAW Mermaid code for query '%s':\n%s", 
                    context["query"][:50], context["raw_diagram"])

    async def _sanitize_diagram(self, context: Dict[str, Any]) -> None:
        """Stage 4: Sanitize the Mermaid code."""
        context["sanitized_diagram"] = sanitize_mermaid(context["raw_diagram"])
        
        # Log sanitized Mermaid code at INFO level
        logger.info("🟢 SANITIZED Mermaid code for query '%s':\n%s", 
                    context["query"][:50], context["sanitized_diagram"])
        
        # Log if changes were made during sanitization
        if context["raw_diagram"] != context["sanitized_diagram"]:
            logger.info("⚠️ Diagram was modified during sanitization for query '%s'", 
                        context["query"][:50])
            
    async def _render_diagram(self, context: Dict[str, Any]) -> None:
        """Stage 5: Render the diagram (HTML or image)."""
        context["render_result"] = await render_diagram(
            context["sanitized_diagram"]
        )
        logger.info(f"Rendered as: {context['render_result'].render_type}")
    
    def _build_result(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Build the final result dictionary."""
        render_result = context["render_result"]
        
        return {
            "description": context["content_description"],
            "content":      context["content_description"], 
            "diagram_type": context["diagram_type"],
            "diagram": context["sanitized_diagram"],
            "render_type": render_result.render_type,
            "rendered_content": render_result.rendered_content
        }


# Create a singleton pipeline instance
_pipeline = DiagramPipeline()


async def process_pipeline(query: str) -> Dict[str, Any]:
    """
    Process a query through the diagram generation pipeline.
    
    This is the main entry point for diagram generation.
    
    Args:
        query: User's query text
        
    Returns:
        Dict containing:
        - description: Text description of the content
        - diagram_type: Selected diagram type
        - diagram: Sanitized Mermaid code
        - render_type: "html" or "image"
        - rendered_content: Rendered output
        
    Raises:
        ValueError: If query is invalid
        Exception: If pipeline processing fails
    """
    if not query or not query.strip():
        raise ValueError("Query cannot be empty")
    
    return await _pipeline.process(query.strip())

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\pipeline.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\sanitizer.py:
# core/sanitizer.py
"""
Mermaid diagram sanitisation utilities.
Cleans and fixes common issues in LLM‑generated Mermaid code so that it always
parses in the browser.
"""

from __future__ import annotations

import html
import re
from typing import List, Tuple


class MermaidSanitizer:
    """Static helpers that convert raw LLM output into valid Mermaid."""

    # ------------------------------------------------------------------
    # mapping tables ----------------------------------------------------
    # ------------------------------------------------------------------
    UNICODE_REPLACEMENTS: List[Tuple[str, str]] = [
        ("\u2013", "-"),   # en dash –
        ("\u2014", "-"),   # em dash —
        ("\u201C", '"'),  # left  double quote "
        ("\u201D", '"'),  # right double quote "
        ("\u2018", "'"),   # left  single quote '
        ("\u2019", "'"),   # right single quote '
        ("\u00A0", " "),   # non‑breaking space
        ("\u200B", ""),    # zero‑width space
    ]

    HTML_ENTITIES: List[Tuple[str, str]] = [
        ("&amp;", "&"),
        ("&lt;", "<"),
        ("&gt;", ">"),
        ("&quot;", '"'),
        ("&#39;", "'"),
    ]

    # ------------------------------------------------------------------
    # public API --------------------------------------------------------
    # ------------------------------------------------------------------
    @classmethod
    def sanitize(cls, snippet: str) -> str:
        """Full sanitisation pipeline."""
        text = snippet.strip()
        
        # STEP 1: Extract and preserve the init block
        init_block = None
        init_pattern = r'(%%\{init:.*?\}%%)'
        init_match = re.search(init_pattern, text, re.DOTALL)
        
        if init_match:
            init_block = init_match.group(0)
            # Replace with a unique placeholder that won't be affected by sanitization
            text = text.replace(init_block, '###MERMAID_INIT_BLOCK_PLACEHOLDER###')
        
        # STEP 2: Apply all sanitization steps to the rest
        text = cls._decode_html_entities(text)
        text = cls._remove_markdown_fences(text)
        text = cls._normalise_unicode(text)
        text = cls._fix_line_breaks(text)

        # STEP 3: Process line by line (but skip placeholder line)
        fixed_lines: List[str] = []
        for line in text.splitlines():
            if '###MERMAID_INIT_BLOCK_PLACEHOLDER###' in line:
                # Don't process lines with our placeholder
                fixed_lines.append(line)
            else:
                fixed_lines.append(cls._process_line(line))
        
        text = "\n".join(fixed_lines)
        
        # STEP 4: Final cleanup (but preserve placeholder)
        text = cls._final_cleanup(text)
        
        # STEP 5: Restore the original init block
        if init_block:
            text = text.replace('###MERMAID_INIT_BLOCK_PLACEHOLDER###', init_block)
        
        return text

    # ------------------------------------------------------------------
    # individual steps --------------------------------------------------
    # ------------------------------------------------------------------
    @staticmethod
    def _decode_html_entities(text: str) -> str:
        """Decode once, then again to catch double‑encoding."""
        return html.unescape(html.unescape(text))

    @staticmethod
    def _remove_markdown_fences(text: str) -> str:
        """Drop ```mermaid fences that sometimes wrap the snippet."""
        text = re.sub(r"^```(?:mermaid)?\s*", "", text, flags=re.MULTILINE | re.IGNORECASE)
        return re.sub(r"```$", "", text, flags=re.MULTILINE)

    @classmethod
    def _normalise_unicode(cls, text: str) -> str:
        """Replace smart punctuation and non‑printables with ASCII."""
        for bad, good in cls.UNICODE_REPLACEMENTS:
            text = text.replace(bad, good)
        return text

    @staticmethod
    def _fix_line_breaks(text: str) -> str:
        """Normalise all forms of <br/> to <br>."""
        return re.sub(r"<\s*br\s*/?\s*>", "<br>", text, flags=re.IGNORECASE)

    # ------------------------------------------------------------------
    # per‑line processing ----------------------------------------------
    # ------------------------------------------------------------------
    @classmethod
    def _process_line(cls, line: str) -> str:
        stripped = line.strip()

        # 1. Subgraph declarations
        if stripped.lower().startswith("subgraph"):
            fixed = cls._fix_subgraph(stripped)
            if stripped != fixed:
                import logging
                logging.debug(f"Fixed subgraph: '{stripped}' -> '{fixed}'")
            return fixed

        # 2. Parentheses nodes  A("text") → A["text"]
        m = re.match(r"(\w+)\(\"([^\"]+)\"\)(.*)$", stripped)
        if m:
            node_id, label, rest = m.groups()
            return f"{node_id}[\"{label}\"]{rest}"

        # 3. Bracket nodes with stray quotes
        m = re.match(r"(\w+)\[\"([^\"]+)\"\](.*)$", stripped)
        if m:
            node_id, label, rest = m.groups()
            return f"{node_id}[\"{label}\"]{rest}"

        # 4. Circular nodes ((text)) – de‑quote content if present
        if "((" in stripped and "))" in stripped:
            def fix_circular(m):
                content = m.group(1).replace('"', "'")
                return f"(({content}))"
            return re.sub(r"\(\(([^)]+)\)\)", fix_circular, stripped)

        # 5. Fallback – ensure A[label] has quotes
        # Don't apply to subgraph lines as they're already handled
        if not stripped.lower().startswith("subgraph"):
            return cls._fix_general_quotes(stripped)
        
        return stripped

    # ---------------------- specific fix helpers -----------------------
    @staticmethod
    def _fix_subgraph(line: str) -> str:
        # Extract everything after "subgraph"
        content = line[len("subgraph"):].strip()
        
        # For simplicity, we'll just extract a valid ID and ignore any labels
        # This avoids all the bracket/quote parsing issues
        
        # Try to find a valid ID at the start
        id_match = re.match(r'^(\w+)', content)
        
        if id_match:
            safe_id = id_match.group(1).strip('_')
            # Remove any trailing underscores or numbers that look like errors
            safe_id = re.sub(r'_+$', '', safe_id)
            safe_id = re.sub(r'_+', '_', safe_id)
        else:
            # No valid ID found, try to extract from any text present
            words = re.findall(r'\b[A-Za-z]+\b', content)
            if words:
                safe_id = words[0].capitalize()
            else:
                safe_id = "Subgraph"
        
        # Ensure the ID is valid
        if not safe_id or not re.match(r'^[A-Za-z]\w*$', safe_id):
            safe_id = 'Subgraph'
        
        # Return simple subgraph without label
        return f'subgraph {safe_id}'

    @staticmethod
    def _fix_general_quotes(line: str) -> str:
        def repl(m: re.Match) -> str:
            node_id, label = m.groups()
            label = label.strip().strip('"').replace('"', "'")
            return f"{node_id}[\"{label}\"]"

        return re.sub(r"(\b[^\s\[\]]+)?\[([^\]]+)\]", repl, line)

    # ----------------------- final cleanup -----------------------------
    @classmethod
    def _final_cleanup(cls, text: str) -> str:
        for entity, repl in cls.HTML_ENTITIES:
            text = text.replace(entity, repl)
        # Remove accidental identifier‑quote‑bracket sequences  id"[ -> id[
        return re.sub(r'"\[', '[', text)


# convenience wrapper --------------------------------------------------

def sanitize_mermaid(snippet: str) -> str:
    """Return a cleaned Mermaid snippet suitable for rendering."""
    # Log the raw input for debugging
    import logging
    logger = logging.getLogger(__name__)
    
    # Check for init block
    if '%%{init:' in snippet:
        logger.info("ℹ️ Detected init block in Mermaid code - will preserve it untouched")
    
    # Check for common problematic patterns
    if '___[' in snippet or ']["' in snippet and '"]"]' in snippet:
        logger.warning("Detected potentially malformed subgraph syntax in Mermaid code")
    
    sanitized = MermaidSanitizer.sanitize(snippet)
    
    # Log significant changes
    if snippet != sanitized and logger.isEnabledFor(logging.DEBUG):
        logger.debug("Mermaid code was sanitized")
        # Log first few lines of changes to avoid huge logs
        original_lines = snippet.split('\n')[:10]
        sanitized_lines = sanitized.split('\n')[:10]
        for i, (orig, san) in enumerate(zip(original_lines, sanitized_lines)):
            if orig != san:
                logger.debug(f"Line {i}: '{orig}' -> '{san}'")
    
    return sanitized
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\sanitizer.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\core\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\content.txt:
You are an expert at creating concise, structured descriptions. When given a query, provide:

The main topic/subject (1-3 words)
Maximum of 5-6 key facts or characteristics, each 10-20 words
Use bullet points (“- ”) for the facts
Keep each fact distinct and memorable
Focus on the most important, defining aspects
Format your response exactly like this:
Main topic: [topic name]

[concise description of first fact]
[another key characteristic]
[important feature]
[additional notable aspect] etc...
Keep the total response under 100 words. Each fact should be self-contained and suitable for display in a diagram node. Try to ensure that the theme of each fact is unique, to the extent possible. None of the content or nodes should deviate too much from the question.







--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\content.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\content_sequence_comparison.txt:
You are an expert at generating structured, concise comparison data for up to four items (such as languages, frameworks, or concepts).

When given a comparison query, provide:

A list of all items being compared (use their actual names).

2–6 key similarities shared by all items, written as short, memorable points.

For each item, list 2–4 unique features or characteristics that distinguish it from the others (short, clear, and specific).

Format your response as:

Items: [item1], [item2], [item3], [item4]

Similarity 1: [concise shared feature]

Similarity 2: [concise shared feature]
...

[item1] unique 1: [distinctive trait]

[item1] unique 2: [distinctive trait]
...

[item2] unique 1: [distinctive trait]
...

Rules:

Do not invent items; use only what the query asks to compare (up to 4).

If similarities apply only to a subset, specify clearly (“Python & Julia: high-level and open-source languages”).

Keep each statement under 20 words and focused on what matters most.

No extra explanations—just the items, similarities, and unique features.

Example:

Items: Python, JavaScript, R

Similarity 1: Dynamically typed languages
Similarity 2: Open-source and have active communities

Python unique 1: Largest general-purpose standard library
Python unique 2: Widely used for machine learning

JavaScript unique 1: Runs natively in web browsers
JavaScript unique 2: Foundation of front-end web development

R unique 1: Specialized for statistical analysis and plotting
R unique 2: CRAN as primary package repository


--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\content_sequence_comparison.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\deep_dive.txt:
You are a helpful assistant that provides detailed, contextual information about specific concepts. 

In the context of the selected text and the question about it, provide a focused, informative response that:

1. Directly answers their question about the selected content
2. Provides additional relevant details, examples, or context
3. Keeps the response concise but comprehensive (2-4 paragraphs)
4. Uses clear language
5. Relates back to the selected text when appropriate

Focus on being informative and educational while maintaining clarity. If the question asks for specific types of information (examples, applications, history, etc.), prioritize that in your response.

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\deep_dive.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\diagram.txt:
You are a diagram-making assistant that creates flowcharts, which are structured like radial mind-maps. Given descriptive text about a topic, output **only** the Mermaid flowchart code.

Follow this exact pattern:

```
%%{init: {
  "theme": "base",
  "fontFamily": "sans-serif",
  "fontSize" : "13px",
  "flowchart": { 
    "htmlLabels": false, 
    "wrap": true,
    "useMaxWidth": true,
  },
  "themeVariables": {
    "primaryColor": "#ffffff",
    "primaryTextColor": "#000000",
    "primaryBorderColor": "#000000",
    "lineColor": "#eee",
    "arrowColor": "#eee",
    "arrowheadColor": "#000000",
    "edgeLabelBackground": "#ffffff",
    "clusterBkg": "#ffffff",
    "defaultLinkColor": "#000000",
    "titleColor": "#000000",
    "edgePath": "#000000",
    "fill0": "#f9f9f9",
    "fill1": "#f9f9f9",
    "fill2": "#f9f9f9"
  }
}}%%

flowchart TD
    %% centre
    A((Topic Name)):::center

    %% facts with better text breaks
    B("First fact<br>with line break"):::fact
    C("Second fact<br>with line break"):::fact
    D("Third fact<br>with line break"):::fact
    E("Additional info..."):::fact

   %% connections using thick arrows
    B <==> A
    C <==> A
    A <==> D
    A <==> E

    classDef center fill:#e3f2fd,stroke:#000000,stroke-width:3px,color:#000000
    classDef fact fill:#f9f9f9,stroke:#000000,stroke-width:2px,color:#000000
```

Rules:
- Use `A((Topic)):::center` for the main topic
- To achieve radial distribution: Write the first 2-3 connections with fact nodes first (FactNode <==> CenterNode), then write the remaining connections with the center node first (CenterNode <==> FactNode)
- Use `[]` for node text, not `()`
- Add `<br>` tags to break long text (not <br/>)
- Connect facts to center with `<==>` for thick bidirectional arrows
- Use `==>` for thick directional arrows
- Output ONLY the Mermaid code, no explanations
- Always set lineColor and defaultLinkColor to #000000 for black arrows
- Include classDef definitions for center and fact nodes with proper contrast
- Do not choose dark colours for nodes but ensure all borders and text are clearly visible
- Always use `[Node Label]` for every flowchart node, even if that label contains parentheses, commas, etc.
- If you want a circular or special shape, assign a CSS class (e.g. `:::circle`) and style it via `classDef`.
- Do NOT use `((…))` in your output—just `[Label]`.
- If you have to use special charcters use entity codes like #38

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\diagram.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\diagram_flowchart.txt:
You are a diagram‑making assistant that returns **only** Mermaid flowchart code representing the process described.

---

### Pattern to follow

```mermaid

%%{init:{
  "theme":"base",
  "flowchart":{
    "useMaxWidth":true,
    "fontFamily":"sans-serif",
    "fontSize":"14px"
  },
  "themeVariables":{
    "lineColor":"#fbbf24",
    "arrowColor":"#fbbf24",
    "arrowheadColor":"#fbbf24"
  }
}}%%
flowchart TB
  %% styles
  classDef processStyle  fill:#fbbf24,stroke:#f59e0b,stroke-width:2px,color:#000000,font-weight:bold;
  classDef decisionStyle fill:#10b981,stroke:#059669,stroke-width:2px,color:#ffffff,font-weight:bold;

  %% Context section (optional)
  subgraph Context
    direction LR
    C1(C1 description):::processStyle
    C2(C2 description):::processStyle
    C3(C3 description):::processStyle
    C1 ~~~ C2  ~~~ C3
  end
  
  %% Main flow
  subgraph Details
    direction TB
    Step1(First real step):::processStyle
    Step2(Second step):::processStyle
    Decision(Condition?):::decisionStyle
    YesPath(Yes branch):::processStyle
    NoPath(No branch):::processStyle

    Step1 --> Step2 --> Decision
    Decision --|Yes|-->YesPath
    Decision --|No|-->NoPath
  end

  %% Connect the two sections (remove if no Context subgraph)
  Context ~~~ Step1
  ```

---

### Rules

1. **Node declaration**: Always use the form `id[Label)`, `id{Question?}`, or `id(Label))`—the identifier *before* the brackets is mandatory and must be unique.
2. **Arrows**: Use `-->` for normal flows and `-->|Label|` for labelled flows. Do **not** use `==>`, `===`, or other variants.
3. **Sections**:
   * Mention broad background items in a `Context` subgraph. Ensure at least one context item and a maximum of three.
   * Place the step‑by‑step logic in one `Details` subgraph. Use `direction LR` inside `Context`, `direction TB` inside `Details`.
   * **Subgraph syntax**: Use simple `subgraph ID` format without labels. The ID should be a simple word like `Context` or `Details` (no underscores, no brackets, no special characters).
   * Example: `subgraph Context` or `subgraph Details`
4. **Styling**: Apply `:::processStyle` or `:::decisionStyle` directly to nodes. Do not override stroke widths; the `classDef` settings handle them.
5. **Header**: Begin every diagram with the `%%{init:{…}}%%` block exactly as shown.
6. **Keep labels concise**; use `<br/>` for line breaks inside a node when needed.
7. **Decision nodes** appear only when the described process genuinely branches.
8. **Output strictly the Mermaid code**—no prose, no Markdown fencing other than the single \`\`\`mermaid block.
9. Avoid special characters in labels except whitespace, commas, periods, and `/`.

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\diagram_flowchart.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\diagram_sequence_comparison.txt:
You are a diagram-making assistant that creates Mermaid sequence diagrams for comparing between 2 and 4 items (such as programming languages, frameworks, or concepts).

Follow this pattern:

```
%%{init:
  {
    "themeVariables": {
      "sequenceDiagramActorWidth": 500,
      "fontFamily": "sans-serif",
      "fontSize": "13px"
    },
    "sequence": {"mirrorActors": false},
    "themeCSS": ".actor-line { stroke-width: 0.0001px !important; }"
  }
}%%

sequenceDiagram
  participant Item1
  participant Item2
  participant Item3

  activate Item1
  activate Item2
  activate Item3

  rect rgb(230,255,230)
      Note over Item1,Item3: Similarities
      Note over Item1,Item3: 1. Similarity_aspect1 and <br/>brief explanation
      Note over Item1,Item3: 2. Similarity_aspect2 and <br/>brief explanation
      Note over Item1,Item3: 3. Similarity_aspect3 and <br/>brief explanation
  end

  rect rgb(255,235,235)
    Note over Item1: Unique aspects<br/>1. Feature A1 and brief explanation<br/>2. Feature A2 and brief explanation<br/>3. Feature A3 and brief explanation
  end

  rect rgb(255,235,235)
    Note over Item2: Unique aspects<br/>1. Feature B1 and brief explanation<br/>2. Feature B2 and brief explanation<br/>3. Feature B3 and brief explanation
  end

  rect rgb(255,235,235)
    Note over Item3: Unique aspects<br/>1. Feature C1 and brief explanation<br/>2. Feature C2 and brief explanation<br/>3. Feature C3 and brief explanation
  end

  deactivate Item1
  deactivate Item2
  deactivate Item3
  ```

Given a query asking for a comparison, output ONLY the Mermaid code for a sequenceDiagram, in the above pattern, that follows these strict rules:

Rules:

- Use the sequenceDiagram type.
- Ensure that the init section used in the example is used in the final result. 
- Create one participant for each item, using the item’s name as the participant label, in the order provided in the query.
    For each item name:
    - If it has no spaces (e.g. “Item1”), write:
        participant Item1
    - If it has spaces (e.g. “New York Pizza”), pick an ID by replacing spaces with underscores, then quote the original name:
        participant New_York_Pizza as "New York Pizza"

- For similarities across all compared items, use Note over [FirstParticipant],[LastParticipant]. Do not use Note over with any other combination of participants.
- For similarities that apply to all items, use a rect block with a light green background (e.g., rect rgb(230,255,230)), and a Note over [FirstParticipant],[LastParticipant] spanning the entire group.
- Use autonumber for similarities.
- Give a brief description of each similarity
- Each similarity must have its own line.
- For unique features, use a rect block with a light red background (e.g., rect rgb(255,235,235)), and a Note over [Participant] for each item.
- Give a brief description of each feature
- Keep the explanations concise.
- Output only the Mermaid code, nothing else.
- Never add explanations outside the Mermaid diagram.
- Support up to 4 items; if more are provided, focus only on the first 4.
- Always use `[Node Label]` for every flowchart node, even if that label contains parentheses, commas, etc.
- If you want a circular or special shape, assign a CSS class (e.g. `:::circle`) and style it via `classDef`.
- Do NOT use `((…))` in your output—just `[Label]`.


--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\prompts\diagram_sequence_comparison.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\index.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-status-bar-style" content="black-translucent">
  <title>PiText</title>
  
  <link rel="icon" href="/desktop/assets/PiText_favicon.ico" type="image/x-icon"/>
  <link rel="apple-touch-icon" href="/desktop/assets/PiText_favicon.ico">
  
  <link rel="stylesheet" href="/desktop/css/styles.css">
  
  <link rel="preload" href="/desktop/assets/PiText_background.png" as="image">
  
  <script type="module">
    // Import Mermaid but don't initialize - our app will handle it
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    window.mermaid = mermaid;
  </script>
</head>
<body>
  <header class="app-header">
    <h1>Answers, you can <span class="highlight">See!</span></h1>
    <p class="tagline">Ask anything. Get responses in <strong>Textcharts.</strong></p>
    <div class="examples">
      <p class="examples-label">Try:</p>
      <button class="example-btn" data-query="How do rainbows form">"How do rainbows form"</button>
      <button class="example-btn" data-query="Pepsi vs Coke">"Pepsi vs Coke"</button>
      <button class="example-btn" data-query="Steps to bake a cake">"Steps to bake a cake"</button>
    </div>
  </header>

  <main class="app-main">
    <section class="query-section">
      <div class="input-wrapper">
        <input 
          id="query" 
          type="text"
          placeholder="Ask anything!" 
          autocomplete="off"
          aria-label="Enter your question"
        />
        <button id="generateBtn" class="primary-btn" aria-label="Generate">
          <span class="btn-text">Generate</span>
        </button>
      </div>
      <div id="querySuggestions" class="suggestions"></div>
    </section>

    <section class="result-section">
      <div id="result" class="diagram-container" role="region" aria-live="polite">
        <div class="placeholder">
          <div class="placeholder-icon">📊</div>
          <p>The response will appear here</p>
        </div>
      </div>
    </section>

    <section id="selectionSection" class="selection-section" >
      <div id="selectionIndicator" class="selection-indicator">
        <div class="selection-header">
          <strong>Selected:</strong> 
          <span id="selectedText" class="selected-text"></span>
        </div>
        <div class="deep-dive-input-wrapper">
          <input 
            id="deepDiveQuery" 
            type="text"
            placeholder="Ask about this selection…" 
            autocomplete="off"
            aria-label="Ask about selected content"
          />
          <button id="askBtn" class="secondary-btn" aria-label="Ask question">
            Ask
          </button>
        </div>
      </div>

      <div id="deepDiveResponse" class="deep-dive-response"></div>
    </section>
  </main>

  <div id="notifications" class="notification-container" role="status" aria-live="polite"></div>

  <script type="module" src="/desktop/js/app.js"></script>
  
  <script nomodule>
    document.body.innerHTML = '<div class="error-message" style="text-align: center; padding: 2rem;"><h2>Browser Not Supported</h2><p>Please use a modern browser that supports ES6 modules.</p></div>';
  </script>
</body>
</html>
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\index.html ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\main.css:
/* public/css/main.css */
/* Main entry point - imports all other CSS files in correct order */

/* Base styles */
@import url('./base/variables.css');
@import url('./base/reset.css');
@import url('./base/typography.css');

/* Layout styles */
@import url('./layout/header.css');
@import url('./layout/main.css');
@import url('./layout/footer.css');

/* Component styles */
@import url('./components/buttons.css');
@import url('./components/forms.css');
@import url('./components/diagram.css');
@import url('./components/selection.css');
@import url('./components/notifications.css');
@import url('./components/dialogs.css');
@import url('./components/loading.css');

/* Utility styles */
@import url('./utilities/animations.css');
@import url('./utilities/helpers.css');
@import url('./utilities/print.css');

/* Responsive styles */
@import url('./responsive/mobile.css');
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\main.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\styles.css:
/* public/css/styles.css */

/* ============================================
   CSS Variables & Reset
   ============================================ */
:root {
  --primary-color: #FFD600;
  --bg-dark: #000000;
  --text-light: #f0f0f0;
  --text-white: #ffffff;
  --border-light: rgba(255, 255, 255, 0.3);
  --bg-translucent: rgba(255, 255, 255, 0.1);
  --shadow-dark: rgba(0, 0, 0, 0.8);
  --error-color: #ff6b6b;
  --success-color: #51cf66;
  --warning-color: #ffd93d;
  --info-color: #339af0;
  
  --transition-fast: 0.2s ease;
  --transition-normal: 0.3s ease;
  
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* ============================================
   Base Styles
   ============================================ */
body {
  background: var(--bg-dark) url("/desktop/assets/PiText_background.png") center/cover no-repeat fixed;
  color: var(--text-light);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ============================================
   Header
   ============================================ */
.app-header {
  text-align: center;
  padding: 2rem 1rem 1rem;
  animation: fadeIn 0.6s ease-out;
}

.app-header h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  color: var(--text-white);
  text-shadow: 0 0 10px var(--shadow-dark);
}

.app-header .highlight {
  color: var(--primary-color);
}

.tagline {
  font-size: 1.1rem;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.examples {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.examples-label {
  font-size: 0.9rem;
  opacity: 0.7;
}

.example-btn {
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  padding: 0.25rem 0.75rem;
  border-radius: var(--radius-sm);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.example-btn:hover {
  background: var(--bg-translucent);
  border-color: var(--primary-color);
  color: var(--primary-color);
}

/* ============================================
   Main Content
   ============================================ */
.app-main {
  flex: 1;
  padding: 1rem 2rem;
  max-width: 1200px;
  width: 100%;
  margin: 0 auto;
}

/* ============================================
   Query Section
   ============================================ */
.query-section {
  margin-bottom: 2rem;
}

.input-wrapper {
  display: flex;
  gap: 0.5rem;
  max-width: 600px;
  margin: 0 auto;
}

#query {
  flex: 1;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  color: var(--text-white);
  transition: all var(--transition-fast);
}

#query:focus {
  outline: none;
  border-color: var(--primary-color);
  background: rgba(255, 255, 255, 0.15);
}

#query::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

.primary-btn {
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: all var(--transition-fast);
}

.primary-btn:hover {
  background: #ffc400;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(255, 214, 0, 0.3);
}

.primary-btn:active {
  transform: translateY(0);
}

.primary-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-icon {
  font-size: 1.2rem;
}

/* ============================================
   Result Section
   ============================================ */
.result-section {
  margin-bottom: 2rem;
}

.diagram-container {
  background: var(--bg-translucent);
  backdrop-filter: blur(10px);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 2rem;
  min-height: 400px;
  position: relative;
  overflow: auto;
}

/* only sequence diagrams get extra width */
.diagram-container.sequence-wide {
  max-width: none;        /* lift the normal cap */
  width: 1100px;          /* choose your “wide” value */
  margin: 0 auto;
}

/* if you need the inner SVG to fill that new width */
.diagram-container.sequence-wide svg {
  width: 100% !important;
  height: auto !important;
}


.placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  opacity: 0.5;
}

.placeholder-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

/* ============================================
   Diagram Styles
   ============================================ */
.diagram-container .mermaid {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
}

.diagram-container svg {
  max-width: 100%;
  height: auto;
}

/* Mermaid customizations */
.mermaid text {
  fill: var(--text-white) !important;
  text-shadow: 1px 1px 2px var(--shadow-dark);
}

.mermaid .node rect,
.mermaid .node circle,
.mermaid .node ellipse,
.mermaid .node polygon {
  fill: var(--bg-translucent) !important;
  stroke: var(--text-white) !important;
  stroke-width: 2px;
}

.mermaid .node.element-selected rect,
.mermaid .node.element-selected circle {
  stroke: var(--primary-color) !important;
  stroke-width: 3px !important;
  filter: drop-shadow(0 0 6px var(--primary-color));
}

.mermaid .edgePath path {
  stroke: var(--text-white) !important;
  stroke-width: 2px !important;
}

/* ============================================
   Diagram Utilities
   ============================================ */
.diagram-utils {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  justify-content: flex-end;
}

.diagram-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.diagram-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: var(--text-white);
}




/* ============================================
   Selection Section
   ============================================ */
.selection-section {
  margin-bottom: 2rem;
}

.selection-indicator {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem;
  margin-bottom: 1rem;
}

.selection-header {
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-light);
  padding-left: 2rem; /* ADD THIS LINE to push the "Selected:" text to the right */
}

.selected-text {
  color: var(--primary-color);
}

.deep-dive-input-wrapper {
  display: flex;
  gap: 0.5rem;
}

#deepDiveQuery {
  flex: 1;
  padding: 0.5rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  color: var(--text-white);
  font-size: 0.875rem;
}


#deepDiveQuery:focus, #deepDiveQuery.highlight-focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 10px rgba(255, 214, 0, 0.5);
  transition: all 0.2s ease-in-out;
}

.secondary-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid var(--border-light);
  color: var(--text-white);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.secondary-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  border-color: var(--text-white);
}

/* ============================================
   Deep Dive Response
   ============================================ */
.deep-dive-response {
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1.5rem;
  color: var(--text-white);
  line-height: 1.8;
  opacity: 0;
  transform: translateY(20px);
  transition: all var(--transition-normal);
  position: relative; /* ADD THIS LINE */
}


/* --- ADD THIS ENTIRE NEW BLOCK OF CSS --- */
/* This styles the new close button */
.deep-dive-response .close-btn {
  position: relative;
  top: 0.75rem;
  left: 0.75rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  font-size: 1.4rem;
  line-height: 30px;
  text-align: center;
  cursor: pointer;
  transition: all var(--transition-fast);
  z-index: 10;
}

.deep-dive-close {        /* the existing class on the button */
  position: absolute;
  top: 0.5rem;            /* keep the vertical offset that looked good */
  right: 0.5rem;          /* move to right */
  left: auto;             /* override any old left: 0; */
}


.deep-dive-response .close-btn:hover {
  background: var(--error-color);
  color: var(--text-white);
  border-color: var(--error-color);
  transform: scale(1.1);
}

.deep-dive-response.active {
  opacity: 1;
  transform: translateY(0);
}

.deep-dive-content h3 {
  margin-bottom: 1rem;
  color: var(--primary-color);
}

.deep-dive-qa {
  margin-bottom: 1.5rem;
}

.question {
  font-style: italic;
  margin-bottom: 1rem;
  opacity: 0.8;
}

.answer {
  white-space: pre-wrap;
}

.answer p {
  margin-bottom: 1rem;
}

.answer p:last-child {
  margin-bottom: 0;
}

.answer code {
  background: rgba(255, 255, 255, 0.1);
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Consolas', 'Monaco', monospace;
}

.answer mark {
  background: rgba(255, 214, 0, 0.3);
  color: var(--text-white);
  padding: 0.1rem 0.2rem;
  border-radius: 2px;
}

.deep-dive-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.action-btn {
  padding: 0.5rem 1rem;
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--primary-color);
  color: var(--primary-color);
}

/* ============================================
   Loading States
   ============================================ */
.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  font-size: 1.125rem;
  color: var(--text-white);
}

.loading-tip {
  font-size: 0.875rem;
  opacity: 0.7;
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-md);
  opacity: 0;
  visibility: hidden;
  transition: all var(--transition-fast);
}

.loading-overlay-show {
  opacity: 1;
  visibility: visible;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* ============================================
   Error States
   ============================================ */
.error-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
  text-align: center;
}

.error-icon {
  font-size: 3rem;
  filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
}

.error-text {
  font-size: 1.125rem;
  color: var(--error-color);
  max-width: 500px;
}

.retry-btn {
  padding: 0.75rem 1.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--error-color);
  color: var(--error-color);
  border-radius: var(--radius-md);
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.retry-btn:hover {
  background: rgba(255, 107, 107, 0.1);
  border-color: var(--text-white);
  color: var(--text-white);
}

/* ============================================
   Notifications
   ============================================ */
.notification-container {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 9999;
  pointer-events: none;
}

.notification {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem 1.5rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  min-width: 300px;
  transform: translateX(400px);
  transition: transform var(--transition-normal);
  pointer-events: all;
  cursor: pointer;
}

.notification-show {
  transform: translateX(0);
}

.notification-icon {
  font-size: 1.25rem;
}

.notification-success {
  border-color: var(--success-color);
}

.notification-success .notification-icon {
  color: var(--success-color);
}

.notification-error {
  border-color: var(--error-color);
}

.notification-error .notification-icon {
  color: var(--error-color);
}

.notification-warning {
  border-color: var(--warning-color);
}

.notification-warning .notification-icon {
  color: var(--warning-color);
}

.notification-info {
  border-color: var(--info-color);
}

.notification-info .notification-icon {
  color: var(--info-color);
}

.notification-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-light);
  font-size: 1.5rem;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity var(--transition-fast);
}

.notification-close:hover {
  opacity: 1;
}

/* ============================================
   Footer
   ============================================ */
.app-footer {
  padding: 1rem;
  text-align: center;
  opacity: 0.7;
}

.keyboard-shortcuts {
  font-size: 0.875rem;
}

kbd {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  border-radius: 3px;
  padding: 0.2rem 0.4rem;
  font-family: monospace;
  font-size: 0.85em;
}

/* ============================================
   Dialogs
   ============================================ */
.shortcuts-dialog {
  background: rgba(0, 0, 0, 0.95);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-lg);
  color: var(--text-white);
  padding: 2rem;
  max-width: 500px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.shortcuts-dialog::backdrop {
  background: rgba(0, 0, 0, 0.8);
}

.shortcuts-dialog h2 {
  margin-bottom: 1.5rem;
  color: var(--primary-color);
}

.shortcuts-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 2rem;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.close-dialog {
  width: 100%;
  padding: 0.75rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.close-dialog:hover {
  background: #ffc400;
}

/* ============================================
   Animations
   ============================================ */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* ============================================
   Responsive Design
   ============================================ */
@media (max-width: 768px) {
  .app-header h1 {
    font-size: 2rem;
  }
  
  .app-main {
    padding: 1rem;
  }
  
  .input-wrapper {
    flex-direction: column;
  }
  
  #query {
    width: 100%;
  }
  
  .primary-btn {
    width: 100%;
    justify-content: center;
  }
  
  .diagram-container {
    padding: 1rem;
    min-height: 300px;
  }
  
  .notification-container {
    left: 1rem;
    right: 1rem;
  }
  
  .notification {
    min-width: auto;
    transform: translateY(-100px);
  }
  
  .notification-show {
    transform: translateY(0);
  }
}

/* ============================================
   Utility Classes
   ============================================ */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.disabled {
  opacity: 0.5;
  cursor: not-allowed !important;
  pointer-events: none;
}

/* ============================================
   Print Styles
   ============================================ */
@media print {
  body {
    background: white;
    color: black;
  }
  
  .app-header,
  .app-footer,
  .query-section,
  .selection-section,
  .diagram-utils,
  .notification-container {
    display: none;
  }
  
  .diagram-container {
    border: none;
    background: none;
    padding: 0;
  }
  
  .mermaid text {
    fill: black !important;
    text-shadow: none;
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\styles.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\base\reset.css:
/* public/css/base/reset.css */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\base\reset.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\base\typography.css:
/* public/css/base/typography.css */

/* ============================================
   Base Styles
   ============================================ */
body {
  background: var(--bg-dark) url("/desktop/assets/PiText_background.png") center/cover no-repeat fixed;
  color: var(--text-light);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\base\typography.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\base\variables.css:
/* public/css/base/variables.css */

/* ============================================
   CSS Variables & Reset
   ============================================ */
:root {
  --primary-color: #FFD600;
  --bg-dark: #000000;
  --text-light: #f0f0f0;
  --text-white: #ffffff;
  --border-light: rgba(255, 255, 255, 0.3);
  --bg-translucent: rgba(255, 255, 255, 0.1);
  --shadow-dark: rgba(0, 0, 0, 0.8);
  --error-color: #ff6b6b;
  --success-color: #51cf66;
  --warning-color: #ffd93d;
  --info-color: #339af0;
  
  --transition-fast: 0.2s ease;
  --transition-normal: 0.3s ease;
  
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\base\variables.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\buttons.css:
/* public/css/components/buttons.css */

.primary-btn {
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: all var(--transition-fast);
}

.primary-btn:hover {
  background: #ffc400;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(255, 214, 0, 0.3);
}

.primary-btn:active {
  transform: translateY(0);
}

.primary-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-icon {
  font-size: 1.2rem;
}

.secondary-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid var(--border-light);
  color: var(--text-white);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.secondary-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  border-color: var(--text-white);
}

.diagram-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.diagram-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: var(--text-white);
}

.action-btn {
  padding: 0.5rem 1rem;
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--primary-color);
  color: var(--primary-color);
}

.retry-btn {
  padding: 0.75rem 1.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--error-color);
  color: var(--error-color);
  border-radius: var(--radius-md);
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.retry-btn:hover {
  background: rgba(255, 107, 107, 0.1);
  border-color: var(--text-white);
  color: var(--text-white);
}

.close-dialog {
  width: 100%;
  padding: 0.75rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.close-dialog:hover {
  background: #ffc400;
}

/* Add to pitext-desktop/public/css/components/buttons.css */

.primary-btn:disabled,
.secondary-btn:disabled,
.action-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed !important;
    position: relative;
}

.primary-btn:disabled::after {
    content: attr(title);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.875rem;
}

/* Also update the input disabled state */
#query:disabled,
#deepDiveQuery:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: rgba(255, 255, 255, 0.05);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\buttons.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\diagrams.css:
/* public/css/components/diagram.css */

/* ============================================
   Result Section
   ============================================ */
.result-section {
  margin-bottom: 2rem;
}

.diagram-container {
  background: var(--bg-translucent);
  backdrop-filter: blur(10px);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 2rem;
  min-height: 400px;
  position: relative;
  overflow: auto;
}

/* only sequence diagrams get extra width */
.diagram-container.sequence-wide {
  max-width: none;        /* lift the normal cap */
  width: 1100px;          /* choose your "wide" value */
  margin: 0 auto;
}

/* if you need the inner SVG to fill that new width */
.diagram-container.sequence-wide svg {
  width: 100% !important;
  height: auto !important;
}

.placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  opacity: 0.5;
}

.placeholder-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

/* ============================================
   Diagram Styles
   ============================================ */
.diagram-container .mermaid {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
}

.diagram-container svg {
  max-width: 100%;
  height: auto;
}

/* Mermaid customizations */
.mermaid text {
  fill: var(--text-white) !important;
  text-shadow: 1px 1px 2px var(--shadow-dark);
}

.mermaid .node rect,
.mermaid .node circle,
.mermaid .node ellipse,
.mermaid .node polygon {
  fill: var(--bg-translucent) !important;
  stroke: var(--text-white) !important;
  stroke-width: 2px;
}

.mermaid .node.element-selected rect,
.mermaid .node.element-selected circle {
  stroke: var(--primary-color) !important;
  stroke-width: 3px !important;
  filter: drop-shadow(0 0 6px var(--primary-color));
}

.mermaid .edgePath path {
  stroke: var(--text-white) !important;
  stroke-width: 2px !important;
}

/* ============================================
   Diagram Utilities
   ============================================ */
.diagram-utils {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  justify-content: flex-end;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\diagrams.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\dialogs.css:
/* public/css/components/dialogs.css */

/* ============================================
   Dialogs
   ============================================ */
.shortcuts-dialog {
  background: rgba(0, 0, 0, 0.95);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-lg);
  color: var(--text-white);
  padding: 2rem;
  max-width: 500px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.shortcuts-dialog::backdrop {
  background: rgba(0, 0, 0, 0.8);
}

.shortcuts-dialog h2 {
  margin-bottom: 1.5rem;
  color: var(--primary-color);
}

.shortcuts-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 2rem;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\dialogs.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\forms.css:
/* public/css/components/forms.css */

/* ============================================
   Query Section
   ============================================ */
.query-section {
  margin-bottom: 2rem;
}

.input-wrapper {
  display: flex;
  gap: 0.5rem;
  max-width: 600px;
  margin: 0 auto;
}

#query {
  flex: 1;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  color: var(--text-white);
  transition: all var(--transition-fast);
}

#query:focus {
  outline: none;
  border-color: var(--primary-color);
  background: rgba(255, 255, 255, 0.15);
}

#query::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

#deepDiveQuery {
  flex: 1;
  padding: 0.5rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  color: var(--text-white);
  font-size: 0.875rem;
}

#deepDiveQuery:focus, #deepDiveQuery.highlight-focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 10px rgba(255, 214, 0, 0.5);
  transition: all 0.2s ease-in-out;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\forms.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\loading.css:
/* public/css/components/loading.css */

/* ============================================
   Loading States
   ============================================ */
.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  font-size: 1.125rem;
  color: var(--text-white);
}

.loading-tip {
  font-size: 0.875rem;
  opacity: 0.7;
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-md);
  opacity: 0;
  visibility: hidden;
  transition: all var(--transition-fast);
}

.loading-overlay-show {
  opacity: 1;
  visibility: visible;
}

/* ============================================
   Error States
   ============================================ */
.error-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
  text-align: center;
}

.error-icon {
  font-size: 3rem;
  filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
}

.error-text {
  font-size: 1.125rem;
  color: var(--error-color);
  max-width: 500px;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\loading.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\notifications.css:
/* public/css/components/notifications.css */

/* ============================================
   Notifications
   ============================================ */
.notification-container {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 9999;
  pointer-events: none;
}

.notification {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem 1.5rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  min-width: 300px;
  transform: translateX(400px);
  transition: transform var(--transition-normal);
  pointer-events: all;
  cursor: pointer;
}

.notification-show {
  transform: translateX(0);
}

.notification-icon {
  font-size: 1.25rem;
}

.notification-success {
  border-color: var(--success-color);
}

.notification-success .notification-icon {
  color: var(--success-color);
}

.notification-error {
  border-color: var(--error-color);
}

.notification-error .notification-icon {
  color: var(--error-color);
}

.notification-warning {
  border-color: var(--warning-color);
}

.notification-warning .notification-icon {
  color: var(--warning-color);
}

.notification-info {
  border-color: var(--info-color);
}

.notification-info .notification-icon {
  color: var(--info-color);
}

.notification-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-light);
  font-size: 1.5rem;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity var(--transition-fast);
}

.notification-close:hover {
  opacity: 1;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\notifications.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\selection.css:
/* public/css/components/selection.css */

/* ============================================
   Selection Section
   ============================================ */
.selection-section {
  margin-bottom: 2rem;
}

.selection-indicator {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem;
  margin-bottom: 1rem;
}

.selection-header {
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-light);
  padding-left: 2rem; /* ADD THIS LINE to push the "Selected:" text to the right */
}

.selected-text {
  color: var(--primary-color);
}

.deep-dive-input-wrapper {
  display: flex;
  gap: 0.5rem;
}

/* ============================================
   Deep Dive Response
   ============================================ */
.deep-dive-response {
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1.5rem;
  color: var(--text-white);
  line-height: 1.8;
  opacity: 0;
  transform: translateY(20px);
  transition: all var(--transition-normal);
  position: relative; /* ADD THIS LINE */
}

/* --- ADD THIS ENTIRE NEW BLOCK OF CSS --- */
/* This styles the new close button */
.deep-dive-response .close-btn {
  position: absolute;
  top: 0.75rem;
  left: 0.75rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  font-size: 1.4rem;
  line-height: 30px;
  text-align: center;
  cursor: pointer;
  transition: all var(--transition-fast);
  z-index: 10;
}

.deep-dive-response .close-btn:hover {
  background: var(--error-color);
  color: var(--text-white);
  border-color: var(--error-color);
  transform: scale(1.1);
}

.deep-dive-response.active {
  opacity: 1;
  transform: translateY(0);
}

.deep-dive-content h3 {
  margin-bottom: 1rem;
  color: var(--primary-color);
}

.deep-dive-qa {
  margin-bottom: 1.5rem;
}

.question {
  font-style: italic;
  margin-bottom: 1rem;
  opacity: 0.8;
}

.answer {
  white-space: pre-wrap;
}

.answer p {
  margin-bottom: 1rem;
}

.answer p:last-child {
  margin-bottom: 0;
}

.answer code {
  background: rgba(255, 255, 255, 0.1);
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Consolas', 'Monaco', monospace;
}

.answer mark {
  background: rgba(255, 214, 0, 0.3);
  color: var(--text-white);
  padding: 0.1rem 0.2rem;
  border-radius: 2px;
}

.deep-dive-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\components\selection.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\layout\footer.css:
/* public/css/layout/footer.css */

/* ============================================
   Footer
   ============================================ */
.app-footer {
  padding: 1rem;
  text-align: center;
  opacity: 0.7;
}

.keyboard-shortcuts {
  font-size: 0.875rem;
}

kbd {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  border-radius: 3px;
  padding: 0.2rem 0.4rem;
  font-family: monospace;
  font-size: 0.85em;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\layout\footer.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\layout\header.css:
/* public/css/layout/header.css */

/* ============================================
   Header
   ============================================ */
.app-header {
  text-align: center;
  padding: 2rem 1rem 1rem;
  animation: fadeIn 0.6s ease-out;
}

.app-header h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  color: var(--text-white);
  text-shadow: 0 0 10px var(--shadow-dark);
}

.app-header .highlight {
  color: var(--primary-color);
}

.tagline {
  font-size: 1.1rem;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.examples {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.examples-label {
  font-size: 0.9rem;
  opacity: 0.7;
}

.example-btn {
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  padding: 0.25rem 0.75rem;
  border-radius: var(--radius-sm);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.example-btn:hover {
  background: var(--bg-translucent);
  border-color: var(--primary-color);
  color: var(--primary-color);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\layout\header.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\layout\main.css:
/* public/css/layout/main.css */

/* ============================================
   Main Content
   ============================================ */
.app-main {
  flex: 1;
  padding: 1rem 2rem;
  max-width: 1200px;
  width: 100%;
  margin: 0 auto;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\layout\main.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\responsive\mobile.css:
/* public/css/responsive/mobile.css */

/* ============================================
   Responsive Design
   ============================================ */
@media (max-width: 768px) {
  .app-header h1 {
    font-size: 2rem;
  }
  
  .app-main {
    padding: 1rem;
  }
  
  .input-wrapper {
    flex-direction: column;
  }
  
  #query {
    width: 100%;
  }
  
  .primary-btn {
    width: 100%;
    justify-content: center;
  }
  
  .diagram-container {
    padding: 1rem;
    min-height: 300px;
  }
  
  .notification-container {
    left: 1rem;
    right: 1rem;
  }
  
  .notification {
    min-width: auto;
    transform: translateY(-100px);
  }
  
  .notification-show {
    transform: translateY(0);
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\responsive\mobile.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\utilities\animations.css:
/* public/css/utilities/animations.css */

/* ============================================
   Animations
   ============================================ */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\utilities\animations.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\utilities\helpers.css:
/* public/css/utilities/helpers.css */

/* ============================================
   Utility Classes
   ============================================ */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.disabled {
  opacity: 0.5;
  cursor: not-allowed !important;
  pointer-events: none;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\utilities\helpers.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\utilities\print.css:
/* public/css/utilities/print.css */

/* ============================================
   Print Styles
   ============================================ */
@media print {
  body {
    background: white;
    color: black;
  }
  
  .app-header,
  .app-footer,
  .query-section,
  .selection-section,
  .diagram-utils,
  .notification-container {
    display: none;
  }
  
  .diagram-container {
    border: none;
    background: none;
    padding: 0;
  }
  
  .mermaid text {
    fill: black !important;
    text-shadow: none;
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\css\utilities\print.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\app.js:
// public/js/app.js
/**
 * PiText Desktop - Main Application Entry Point
 * Initializes the application and coordinates all modules
 */

import { Config } from './core/config.js';
import { state } from './core/state.js';
import { API } from './core/api.js';
import { MermaidManager } from './diagram/mermaid.js';
import { DiagramGenerator } from './diagram/generator.js';
import { SelectionHandler } from './selection/handler.js';
import { DeepDive } from './selection/deepdive.js';
import { DOMHelpers } from './utils/dom.js';
import { initializeApp } from './core/init.js';
import { setupEventListeners } from './ui/events.js';


/**
 * Main application class
 */
class PiTextApp {
  constructor() {
    this.config = new Config();
    this.state = state;
    this.api = new API(this.config);
    this.mermaid = new MermaidManager();
    this.generator = null; // Initialized after Mermaid is ready
    this.selection = null;
    this.deepDive = null;
    this.dom = new DOMHelpers();
  }

  /**
   * Initialize the application
   */
  async init() {
    console.log('🚀 PiText Desktop initializing...');
    
    try {
      // Wait for Mermaid to be ready
      await this.mermaid.waitForReady();
      
      // Initialize components that depend on Mermaid
      this.generator = new DiagramGenerator(
        this.api,
        this.mermaid,
        this.state,
        this.dom
      );
      
      this.selection = new SelectionHandler(this.state, this.dom);
      
      this.deepDive = new DeepDive(
        this.api,
        this.state,
        this.dom
      );

      this.deepDive.init();
      
      // Use init module
      initializeApp(this);
      
      // Use events module
      setupEventListeners(this);
      
      console.log('✅ PiText Desktop ready!');
      
    } catch (error) {
      console.error('Failed to initialize app:', error);
      this.showInitError();
    }
  }

  /**
   * Handle diagram generation
   */
// In pitext-desktop/public/js/app.js, modify the handleGenerate method:

async handleGenerate() {
    const queryInput = document.getElementById('query');
    const generateBtn = document.getElementById('generateBtn');
    const query = queryInput?.value.trim();
    
    if (!query) {
        this.dom.showNotification('Please enter a query', 'warning');
        return;
    }
    
    // Prevent duplicate requests
    if (this.state.get('isGenerating')) {
        console.log('Already generating, ignoring duplicate request');
        return;
    }
    
    try {
        // Set state FIRST to prevent duplicates
        this.state.setLoading('generating', true);
        
        // Disable button and input immediately
        if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating...';
        }
        if (queryInput) {
            queryInput.disabled = true;
        }
        
        // Clear any existing selection
        this.selection?.clearSelection();
        
        // Generate diagram with proper error handling
        await this.generator.generate(query);
        
        // Set up selection handling for the new diagram
        const resultDiv = document.getElementById('result');
        if (resultDiv) {
            this.selection.setupForContainer(resultDiv);
        }
        
    } catch (error) {
        console.error('Generation failed:', error);
        this.dom.showNotification('Failed to generate diagram', 'error');
    } finally {
        // Always re-enable controls
        this.state.setLoading('generating', false);
        if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.textContent = 'Generate';
        }
        if (queryInput) {
            queryInput.disabled = false;
        }
    }
}

async handleAsk() {
    const questionInput = document.getElementById('deepDiveQuery');
    const askBtn = document.getElementById('askBtn');
    const question = questionInput?.value.trim();
    
    if (!question) {
        this.dom.showNotification('Please enter a question', 'warning');
        return;
    }
    
    if (!this.state.hasSelection()) {
        this.dom.showNotification('Please select something first', 'info');
        return;
    }
    
    // Check if already asking
    if (this.state.get('isAskingDeepDive')) {
        this.dom.showNotification('Already processing question', 'info');
        return;
    }
    
    try {
        // Disable controls
        if (askBtn) {
            this.dom.disableElement(askBtn, 'Asking...');
        }
        if (questionInput) {
            questionInput.disabled = true;
        }
        
        await this.deepDive.ask(question);
    } catch (error) {
        console.error('Deep dive failed:', error);
        // Error handling is done in the deep dive module
    } finally {
        // Re-enable controls
        if (askBtn) {
            this.dom.enableElement(askBtn);
        }
        if (questionInput) {
            questionInput.disabled = false;
            questionInput.focus();
        }
    }
}
  /**
   * Handle deep dive question
   */
  async handleAsk() {
    const questionInput = document.getElementById('deepDiveQuery');
    const question = questionInput?.value.trim();
    
    if (!question) {
      this.dom.showNotification('Please enter a question', 'warning');
      return;
    }
    
    if (!this.state.hasSelection()) {
      this.dom.showNotification('Please select something first', 'info');
      return;
    }
    
    try {
      await this.deepDive.ask(question);
    } catch (error) {
      console.error('Deep dive failed:', error);
      // Error handling is done in the deep dive module
    }
  }

  /**
   * Show initialization error
   */
  showInitError() {
    const result = document.getElementById('result');
    if (result) {
      result.innerHTML = `
        <div class="error-message">
          <div class="error-icon">⚠️</div>
          <div class="error-text">
            Failed to initialize the application. 
            Please refresh the page to try again.
          </div>
        </div>
      `;
    }
  }
}


// Initialize app when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.piTextApp = new PiTextApp();
    window.piTextApp.init();
  });
} else {
  // DOM already loaded
  window.piTextApp = new PiTextApp();
  window.piTextApp.init();
}


// Export for debugging in console
window.PiTextApp = PiTextApp;
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\app.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\api.js:
// public/js/core/api.js
/**
 * API client for backend communication
 * Handles all HTTP requests with retry logic and error handling
 */

export class API {
  constructor(config) {
    this.config = config;
    this.activeRequests = new Map();
      // Override the timeout for describe endpoint
    this.config.api.timeout = 120000; // 2 minutes

  }

  /**
   * Generate a diagram from a query
   * @param {string} query - User query
   * @returns {Promise<Object>} Diagram response
   */
  async generateDiagram(query) {
    return this._request('describe', {
      method: 'POST',
      body: { query }
    });
  }

  /**
   * Get deep dive information
   * @param {Object} params - Deep dive parameters
   * @param {string} params.selectedText - Selected text from diagram
   * @param {string} params.question - User's question
   * @param {string} params.originalQuery - Original query that created the diagram
   * @returns {Promise<Object>} Deep dive response
   */
  async getDeepDive({ selectedText, question, originalQuery = '' }) {
    return this._request('deepDive', {
      method: 'POST',
      body: {
        selected_text: selectedText,
        question: question,
        original_query: originalQuery
      }
    });
  }

  /**
   * Check API health
   * @returns {Promise<Object>} Health status
   */
  async checkHealth() {
    return this._request('health', {
      method: 'GET',
      skipRetry: true
    });
  }

  /**
   * Make HTTP request with retry logic
   * @private
   * @param {string} endpoint - Endpoint name from config
   * @param {Object} options - Request options
   * @returns {Promise<Object>} Response data
   */
  async _request(endpoint, options = {}) {
    const {
      method = 'GET',
      body = null,
      headers = {},
      skipRetry = false,
      signal = null
    } = options;

    const url = this.config.getApiUrl(endpoint);
    const requestKey = `${method}:${url}`;

    // Cancel any existing request to the same endpoint
    this._cancelRequest(requestKey);

    // Create abort controller for this request
    const abortController = new AbortController();
    this.activeRequests.set(requestKey, abortController);

    const requestOptions = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      },
      signal: signal || abortController.signal
    };

    if (body && method !== 'GET') {
      requestOptions.body = JSON.stringify(body);
    }

    try {
      const response = await this._fetchWithRetry(
        url,
        requestOptions,
        skipRetry ? 0 : this.config.api.retryAttempts
      );

      // Remove from active requests
      this.activeRequests.delete(requestKey);

      return response;

    } catch (error) {
      // Remove from active requests
      this.activeRequests.delete(requestKey);

      // Enhance error with context
      error.endpoint = endpoint;
      error.method = method;
      
      throw error;
    }
  }

  /**
   * Fetch with retry logic
   * @private
   * @param {string} url - Request URL
   * @param {Object} options - Fetch options
   * @param {number} retries - Number of retries remaining
   * @returns {Promise<Object>} Response data
   */
  async _fetchWithRetry(url, options, retries) {
    try {
      this.config.debug('API Request:', options.method, url);

      const response = await this._timeout(
        fetch(url, options),
        this.config.api.timeout
      );

      this.config.debug('API Response:', response.status, response.statusText);

      if (!response.ok) {
        const error = await this._parseError(response);
        throw error;
      }

      const data = await response.json();

      // Validate response structure
      if (!data.success && !data.message && !data.status) {
        console.warn('Non-standard API response:', data);
      }

      return data;

    } catch (error) {
      // Don't retry on client errors (4xx)
      if (error.status && error.status >= 400 && error.status < 500) {
        throw error;
      }

      // Don't retry on abort
      if (error.name === 'AbortError') {
        throw new APIError('Request cancelled', 'cancelled', 0);
      }

      // Retry if attempts remaining
      if (retries > 0) {
        this.config.debug(`Retrying request, ${retries} attempts remaining`);
        
        await this._delay(this.config.api.retryDelay);
        
        return this._fetchWithRetry(url, options, retries - 1);
      }

      throw error;
    }
  }

  /**
   * Parse error response
   * @private
   * @param {Response} response - Fetch response
   * @returns {Promise<APIError>} Parsed error
   */
  async _parseError(response) {
    let detail = 'Unknown error';
    let errorType = 'unknown';

    try {
      const data = await response.json();
      detail = data.detail || data.message || detail;
      errorType = data.error_type || errorType;
    } catch {
      // If JSON parsing fails, use status text
      detail = response.statusText || `HTTP ${response.status}`;
    }

    return new APIError(detail, errorType, response.status);
  }

  /**
   * Add timeout to promise
   * @private
   * @param {Promise} promise - Promise to timeout
   * @param {number} ms - Timeout in milliseconds
   * @returns {Promise} Promise with timeout
   */
  _timeout(promise, ms) {
    return Promise.race([
      promise,
      new Promise((_, reject) => {
        setTimeout(() => {
          reject(new APIError('Request timeout', 'timeout', 0));
        }, ms);
      })
    ]);
  }

  /**
   * Delay helper for retries
   * @private
   * @param {number} ms - Delay in milliseconds
   * @returns {Promise} Resolves after delay
   */
  _delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Cancel active request
   * @private
   * @param {string} requestKey - Request identifier
   */
  _cancelRequest(requestKey) {
    const controller = this.activeRequests.get(requestKey);
    if (controller) {
      controller.abort();
      this.activeRequests.delete(requestKey);
    }
  }

  /**
   * Cancel all active requests
   */
  cancelAll() {
    this.activeRequests.forEach(controller => controller.abort());
    this.activeRequests.clear();
  }

  /**
   * Create FormData for file uploads
   * @param {Object} data - Data including files
   * @returns {FormData} Form data object
   */
  createFormData(data) {
    const formData = new FormData();
    
    Object.entries(data).forEach(([key, value]) => {
      if (value instanceof File || value instanceof Blob) {
        formData.append(key, value);
      } else if (value !== null && value !== undefined) {
        formData.append(key, String(value));
      }
    });
    
    return formData;
  }
}

/**
 * Custom API Error class
 */
export class APIError extends Error {
  constructor(message, type = 'unknown', status = 0) {
    super(message);
    this.name = 'APIError';
    this.type = type;
    this.status = status;
    this.timestamp = Date.now();
  }

  /**
   * Check if error is a network error
   * @returns {boolean}
   */
  isNetworkError() {
    return this.type === 'timeout' || this.status === 0;
  }

  /**
   * Check if error is a server error
   * @returns {boolean}
   */
  isServerError() {
    return this.status >= 500;
  }

  /**
   * Check if error is a client error
   * @returns {boolean}
   */
  isClientError() {
    return this.status >= 400 && this.status < 500;
  }

  /**
   * Get user-friendly error message
   * @returns {string}
   */
  getUserMessage() {
    if (this.isNetworkError()) {
      return 'Connection failed. Please check your internet connection.';
    }
    
    if (this.isServerError()) {
      return 'Server error. Please try again later.';
    }
    
    if (this.status === 404) {
      return 'The requested resource was not found.';
    }
    
    if (this.status === 401) {
      return 'You are not authorized to perform this action.';
    }
    
    if (this.status === 403) {
      return 'Access denied.';
    }
    
    if (this.status === 429) {
      return 'Too many requests. Please slow down.';
    }
    
    return this.message || 'An error occurred. Please try again.';
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\api.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\config.js:
// public/js/core/config.js
/**
 * Frontend configuration management
 * Centralizes all configuration settings for the client-side application
 */

export class Config {
  constructor() {
    // API Configuration
    this.api = {
      baseUrl: '/desktop',
      endpoints: {
        describe: '/describe',
        deepDive: '/deep-dive',
        health: '/health'
      },
      timeout: 30000, // 30 seconds
      retryAttempts: 2,
      retryDelay: 1000 // 1 second
    };

    // Mermaid Configuration
    this.mermaid = {
      theme: 'base',
      fontFamily: 'Arial, sans-serif',
      fontSize: '13px',
      startOnLoad: false,
      securityLevel: 'loose',
      flowchart: {
        htmlLabels: false,
        wrap: true,
        useMaxWidth: true,
        nodeSpacing: 50,
        rankSpacing: 50,
        curve: 'basis'
      },
      themeVariables: {
        primaryColor: '#ffffff',
        primaryTextColor: '#000000',
        primaryBorderColor: '#000000',
        lineColor: '#000000',
        arrowheadColor: '#000000',
        edgeLabelBackground: '#ffffff',
        defaultLinkColor: '#000000'
      }
    };

    // UI Configuration
    this.ui = {
      notifications: {
        duration: 3000,
        position: 'top-right'
      },
      animation: {
        duration: 200,
        easing: 'ease-out'
      },
      selection: {
        highlightColor: '#ffb300',
        highlightWidth: 5,
        textEmphasisFilter: 'drop-shadow(0 0 2px #fff6)'
      },
      diagram: {
        errorMessageDelay: 100,
        arrowFixDelay: 50,
        maxRetries: 3
      }
    };

    // Export Configuration
    this.export = {
      png: {
        scale: 4,
        backgroundColor: 'transparent',
        quality: 0.95
      },
      svg: {
        includeStyles: true,
        cleanIds: true
      },
      filename: {
        prefix: 'pitext-diagram',
        timestamp: true,
        format: 'YYYY-MM-DD-HHmmss'
      }
    };

    // Feature Flags
    this.features = {
      enableKeyboardShortcuts: true,
      enableAutoSave: false,
      enableAnalytics: false,
      debugMode: this._isDebugMode()
    };

    // Storage Configuration
    this.storage = {
      prefix: 'pitext_',
      keys: {
        recentQueries: 'recent_queries',
        preferences: 'user_preferences',
        diagramCache: 'diagram_cache'
      },
      maxRecentQueries: 10,
      cacheExpiry: 86400000 // 24 hours
    };
  }

  /**
   * Get full API endpoint URL
   * @param {string} endpoint - Endpoint name from config.api.endpoints
   * @returns {string} Full URL
   */
  getApiUrl(endpoint) {
    const path = this.api.endpoints[endpoint];
    if (!path) {
      throw new Error(`Unknown endpoint: ${endpoint}`);
    }
    return `${this.api.baseUrl}${path}`;
  }

  /**
   * Get Mermaid initialization config
   * @returns {Object} Mermaid config object
   */
  getMermaidConfig() {
    return {
      ...this.mermaid,
      flowchart: { ...this.mermaid.flowchart },
      themeVariables: { ...this.mermaid.themeVariables }
    };
  }

  /**
   * Check if in debug mode
   * @private
   * @returns {boolean}
   */
  _isDebugMode() {
    // Check URL params
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('debug') === 'true') {
      return true;
    }

    // Check localStorage
    if (localStorage.getItem('pitext_debug') === 'true') {
      return true;
    }

    // Check if running on localhost
    return window.location.hostname === 'localhost' || 
           window.location.hostname === '127.0.0.1';
  }

  /**
   * Enable debug mode
   */
  enableDebug() {
    this.features.debugMode = true;
    localStorage.setItem('pitext_debug', 'true');
    console.log('🐛 Debug mode enabled');
  }

  /**
   * Disable debug mode
   */
  disableDebug() {
    this.features.debugMode = false;
    localStorage.removeItem('pitext_debug');
    console.log('Debug mode disabled');
  }

  /**
   * Get export filename
   * @param {string} extension - File extension
   * @returns {string} Formatted filename
   */
  getExportFilename(extension) {
    const { prefix, timestamp, format } = this.export.filename;
    let filename = prefix;
    
    if (timestamp) {
      const date = new Date();
      const formatted = format
        .replace('YYYY', date.getFullYear())
        .replace('MM', String(date.getMonth() + 1).padStart(2, '0'))
        .replace('DD', String(date.getDate()).padStart(2, '0'))
        .replace('HH', String(date.getHours()).padStart(2, '0'))
        .replace('mm', String(date.getMinutes()).padStart(2, '0'))
        .replace('ss', String(date.getSeconds()).padStart(2, '0'));
      
      filename += `-${formatted}`;
    }
    
    return `${filename}.${extension}`;
  }

  /**
   * Log debug message if debug mode is enabled
   * @param {...any} args - Arguments to log
   */
  debug(...args) {
    if (this.features.debugMode) {
      console.log('[PiText Debug]', ...args);
    }
  }

  /**
   * Get configuration value by path
   * @param {string} path - Dot-separated path (e.g., 'api.timeout')
   * @returns {any} Configuration value
   */
  get(path) {
    const keys = path.split('.');
    let value = this;
    
    for (const key of keys) {
      value = value[key];
      if (value === undefined) {
        throw new Error(`Configuration not found: ${path}`);
      }
    }
    
    return value;
  }

  /**
   * Override configuration value
   * @param {string} path - Dot-separated path
   * @param {any} value - New value
   */
  set(path, value) {
    const keys = path.split('.');
    const lastKey = keys.pop();
    let target = this;
    
    for (const key of keys) {
      if (!target[key]) {
        target[key] = {};
      }
      target = target[key];
    }
    
    target[lastKey] = value;
    this.debug(`Configuration updated: ${path} =`, value);
  }
}

// Export singleton instance
export const config = new Config();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\config.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\init.js:
// public/js/core/init.js
/**
 * Application initialization logic
 * Sets up initial UI state
 */

import { DOMHelpers } from '../utils/dom.js';

/**
 * Initialize the application UI
 * @param {Object} app - Main app instance
 */
export function initializeApp(app) {
  setupUI(app);
}

/**
 * Set up initial UI state
 * @param {Object} app - Main app instance
 */
function setupUI(app) {
  // Get DOM elements
  const elements = app.dom.getElements({
    query: '#query',
    result: '#result',
    selectionIndicator: '#selectionIndicator',
    deepDiveResponse: '#deepDiveResponse'
  });
  
  // Focus on query input
  elements.query?.focus();
  
  // Set initial result message
  if (elements.result) {
    elements.result.textContent = 'Textchart will appear here.';
  }
  
  // Hide selection UI initially
  app.dom.hideElement(elements.selectionIndicator);
  app.dom.hideElement(elements.deepDiveResponse);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\init.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\state.js:
// public/js/core/state.js
/**
 * Centralized state management for PiText Desktop
 * Manages application state with event emitters for reactivity
 */

export class State {
  constructor() {
    // Core state
    this._state = {
      // Current query and diagram
      currentQuery: '',
      currentDiagramType: null,
      currentDiagramCode: null,
      currentDiagramContent: null,
      
      // Selection state
      selectedElement: null,
      selectedText: '',
      
      // UI state
      isGenerating: false,
      isAskingDeepDive: false,
      lastError: null,
      
      // History
      queryHistory: [],
      diagramHistory: [],
      
      // Deep dive
      deepDiveHistory: []
    };
    
    // Event listeners
    this._listeners = {
      'selection-changed': [],
      'query-changed': [],
      'diagram-generated': [],
      'state-changed': [],
      'error-occurred': []
    };
    
    // Initialize from storage if available
    this._loadFromStorage();
  }

  /**
   * Get state value
   * @param {string} key - State key
   * @returns {any} State value
   */
  get(key) {
    return this._state[key];
  }

  /**
   * Set state value
   * @param {string} key - State key
   * @param {any} value - New value
   */
  set(key, value) {
    const oldValue = this._state[key];
    this._state[key] = value;
    
    // Emit state change event
    this._emit('state-changed', { key, value, oldValue });
    
    // Emit specific events
    switch (key) {
      case 'selectedElement':
      case 'selectedText':
        this._emit('selection-changed', {
          element: this._state.selectedElement,
          text: this._state.selectedText
        });
        break;
      case 'currentQuery':
        this._emit('query-changed', value);
        break;
    }
    
    // Save to storage
    this._saveToStorage();
  }

  /**
   * Update multiple state values
   * @param {Object} updates - Object with key-value pairs to update
   */
  update(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      this.set(key, value);
    });
  }

  /**
   * Set current query
   * @param {string} query - Query text
   */
  setQuery(query) {
    this.set('currentQuery', query);
    
    // Add to history
    if (query && !this._state.queryHistory.includes(query)) {
      this._state.queryHistory.unshift(query);
      // Keep only last 20 queries
      if (this._state.queryHistory.length > 20) {
        this._state.queryHistory.pop();
      }
    }
  }

  /**
   * Set diagram data
   * @param {Object} diagramData - Diagram information
   */
  setDiagram(diagramData) {
    const { type, code,content, query } = diagramData;
    
    this.update({
      currentDiagramType: type,
      currentDiagramCode: code,
      currentDiagramContent: content
    });
    
    // Add to history
    this._state.diagramHistory.unshift({
      query,
      type,
      code,
      content,
      timestamp: Date.now()
    });
    
    // Keep only last 10 diagrams
    if (this._state.diagramHistory.length > 10) {
      this._state.diagramHistory.pop();
    }
    
    this._emit('diagram-generated', diagramData);
  }

  /**
   * Set selection
   * @param {HTMLElement} element - Selected element
   * @param {string} text - Selected text
   */
  setSelection(element, text) {
    this.update({
      selectedElement: element,
      selectedText: text
    });
  }

  /**
   * Clear selection
   */
  clearSelection() {
    this.update({
      selectedElement: null,
      selectedText: ''
    });
  }

  /**
   * Check if there's an active selection
   * @returns {boolean}
   */
  hasSelection() {
    return Boolean(this._state.selectedText);
  }

  /**
   * Set loading state
   * @param {string} operation - Operation name ('generating', 'askingDeepDive')
   * @param {boolean} isLoading - Loading state
   */
  setLoading(operation, isLoading) {
    switch (operation) {
      case 'generating':
        this.set('isGenerating', isLoading);
        break;
      case 'askingDeepDive':
        this.set('isAskingDeepDive', isLoading);
        break;
    }
  }

  /**
   * Set error state
   * @param {Error|string|null} error - Error object or message
   */
  setError(error) {
    const errorData = error ? {
      message: error.message || String(error),
      timestamp: Date.now(),
      stack: error.stack
    } : null;
    
    this.set('lastError', errorData);
    
    if (errorData) {
      this._emit('error-occurred', errorData);
    }
  }

  /**
   * Add deep dive to history
   * @param {Object} deepDiveData - Deep dive information
   */
  addDeepDive(deepDiveData) {
    this._state.deepDiveHistory.unshift({
      ...deepDiveData,
      timestamp: Date.now()
    });
    
    // Keep only last 20 deep dives
    if (this._state.deepDiveHistory.length > 20) {
      this._state.deepDiveHistory.pop();
    }
  }

  /**
   * Get query suggestions based on history
   * @param {string} partial - Partial query
   * @returns {string[]} Suggested queries
   */
  getQuerySuggestions(partial) {
    if (!partial) return [];
    
    const lowerPartial = partial.toLowerCase();
    return this._state.queryHistory
      .filter(q => q.toLowerCase().includes(lowerPartial))
      .slice(0, 5);
  }

  /**
   * Subscribe to state events
   * @param {string} event - Event name
   * @param {Function} callback - Callback function
   * @returns {Function} Unsubscribe function
   */
  on(event, callback) {
    if (!this._listeners[event]) {
      throw new Error(`Unknown event: ${event}`);
    }
    
    this._listeners[event].push(callback);
    
    // Return unsubscribe function
    return () => {
      const index = this._listeners[event].indexOf(callback);
      if (index > -1) {
        this._listeners[event].splice(index, 1);
      }
    };
  }

  /**
   * Emit event to listeners
   * @private
   * @param {string} event - Event name
   * @param {any} data - Event data
   */
  _emit(event, data) {
    if (this._listeners[event]) {
      this._listeners[event].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in ${event} listener:`, error);
        }
      });
    }
  }

  /**
   * Save state to localStorage
   * @private
   */
  _saveToStorage() {
    try {
      const toSave = {
        queryHistory: this._state.queryHistory,
        diagramHistory: this._state.diagramHistory.slice(0, 5), // Only save recent 5
        deepDiveHistory: this._state.deepDiveHistory.slice(0, 5)
      };
      
      localStorage.setItem('pitext_state', JSON.stringify(toSave));
    } catch (error) {
      console.warn('Failed to save state:', error);
    }
  }

  /**
   * Load state from localStorage
   * @private
   */
  _loadFromStorage() {
    try {
      const saved = localStorage.getItem('pitext_state');
      if (saved) {
        const data = JSON.parse(saved);
        Object.assign(this._state, data);
      }
    } catch (error) {
      console.warn('Failed to load state:', error);
    }
  }

  /**
   * Clear all state and storage
   */
  reset() {
    // Reset to initial state
    this._state = {
      currentQuery: '',
      currentDiagramType: null,
      currentDiagramCode: null,
      selectedElement: null,
      selectedText: '',
      isGenerating: false,
      isAskingDeepDive: false,
      lastError: null,
      queryHistory: [],
      diagramHistory: [],
      deepDiveHistory: []
    };
    
    // Clear storage
    localStorage.removeItem('pitext_state');
    
    // Emit reset event
    this._emit('state-changed', { reset: true });
  }

  /**
   * Get current state snapshot
   * @returns {Object} Copy of current state
   */
  getSnapshot() {
    return JSON.parse(JSON.stringify(this._state));
  }
}

// Export singleton instance for convenience
export const state = new State();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\core\state.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\diagram\generator.js:
// public/js/diagram/generator.js
/**
 * Diagram generation orchestration – from query to rendered diagram.
 */

import { DiagramUtilities } from './utilities.js';
import { Helpers } from '../utils/helpers.js';

export class DiagramGenerator {
  constructor(api, mermaid, state, dom) {
    this.api = api;
    this.mermaid = mermaid;
    this.state = state;
    this.dom = dom;
    this.utilities = new DiagramUtilities();
    this.helpers = new Helpers();

    // Retry settings
    this.retryCount = 0;
    this.maxRetries = 3;
  }

  /**
   * Generate a diagram from the user query.
   * @param {string}  query     User's request
   * @param {boolean} isRetry   Internal flag (do not supply manually)
   **/
  async generate(query, isRetry = false) {
      const resultContainer = document.getElementById('result');

      // Reset counter only on the very first attempt
      if (!isRetry) this.retryCount = 0;

      // House‑keeping
      this.state.setQuery(query);
      this.state.setLoading('generating', true);
      this.state.setError(null);
      this._showLoading(resultContainer);

      // Ensure no leftover styling from previous diagrams
      resultContainer.classList.remove('sequence-wide');

      try {
          const response = await this.api.generateDiagram(query);

          if (!response.success) {
              throw new Error(response.detail || 'Generation failed');
          }

          // Apply width tweak for sequence‑comparison diagrams only
          if (response.diagram_type === 'sequence_comparison') {
              resultContainer.classList.add('sequence-wide');
          }

          // Store diagram in the state
          this.state.setDiagram({
              type: response.diagram_type,
              code: response.diagram,
              content: response.content,
              query,
          });

          const ok = await this._renderDiagram(response.diagram, resultContainer);

          if (!ok) {
              // DON'T retry the entire generation - just fail
              throw new Error('Failed to render diagram');
          }

          // Success – augment the SVG
          this._enhanceDiagram(resultContainer);
      } catch (err) {
          console.error('Generation error:', err);
          this.state.setError(err);
          this._showError(resultContainer, err);
      } finally {
          this.state.setLoading('generating', false);
      }
  }
  // -------------------------------------------------------------------------
  // Internal helpers
  // -------------------------------------------------------------------------

  /**
   * Attempt to render Mermaid code.
   * @returns {Promise<boolean>} true on success, false on failure
   */
async _renderDiagram(code, container) {
    try {
        console.log('Starting Mermaid render with code:', code.substring(0, 100) + '...');
        
        // Ensure container is ready
        container.innerHTML = '';
        
        // Create a pre element with mermaid class
        const pre = document.createElement('pre');
        pre.className = 'mermaid';
        pre.textContent = code;
        container.appendChild(pre);
        
        // Force Mermaid to render
        console.log('Calling mermaid.run()...');
        await window.mermaid.run({
            nodes: [pre],
            suppressErrors: false
        });
        
        // Wait for render to complete
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Check if SVG was created
        const svg = container.querySelector('svg');
        if (!svg) {
            console.error('No SVG created by Mermaid');
            // Try displaying the raw code as fallback
            container.innerHTML = `
                <div class="mermaid-error">
                    <p>Failed to render diagram. Raw Mermaid code:</p>
                    <pre style="text-align: left; background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 8px; overflow: auto;">${this.helpers.escapeHtml(code)}</pre>
                </div>
            `;
            return false;
        }
        
        console.log('SVG successfully created');
        this._fixArrowVisibility(container);
        return true;
        
    } catch (err) {
        console.error('Mermaid render error:', err);
        console.error('Failed code:', code);
        // Show the error to user
        container.innerHTML = `
            <div class="error-message">
                <div class="error-icon">⚠️</div>
                <div class="error-text">Failed to render diagram: ${err.message}</div>
                <details style="margin-top: 1rem;">
                    <summary>View Mermaid Code</summary>
                    <pre style="text-align: left; background: rgba(255,255,255,0.1); padding: 1rem; border-radius: 8px; overflow: auto;">${this.helpers.escapeHtml(code)}</pre>
                </details>
            </div>
        `;
        return false;
    }
}

  _showLoading(container) {
    container.innerHTML = `
      <div class="loading-state">
        <div class="loading-spinner"></div>
        <div class="loading-text">Generating textchart...</div>
        <div class="loading-tip">This may take a few seconds</div>
      </div>
    `;
    this._addLoadingAnimation();
  }

  _showError(container, error) {
    const userMessage = error.getUserMessage
      ? error.getUserMessage()
      : this.helpers.getErrorMessage(error);

    container.innerHTML = `
      <div class="error-message">
        <div class="error-icon">⚠️</div>
        <div class="error-text">${userMessage}</div>
        <button class="retry-btn" id="retryBtn">Try Again</button>
        <div class="error-details">
          <details>
            <summary>Technical details</summary>
            <pre>${error.message}</pre>
          </details>
        </div>
      </div>
    `;

    const retryBtn = container.querySelector('#retryBtn');
    if (retryBtn) {
      retryBtn.onclick = () => {
        const q = this.state.get('currentQuery');
        if (q) this.generate(q);
      };
    }
  }

  _enhanceDiagram(container) {
    this.utilities.addButtons(container);
    this._makeInteractive(container);

    if (this._isDiagramLarge(container)) {
      this.utilities.addZoomControls(container);
    }

    this.currentContainer = container;
  }

  _makeInteractive(container) {
    const svg = container.querySelector('svg');
    if (!svg) return;

    const nodes = svg.querySelectorAll('g.node, .node');
    nodes.forEach((node) => {
      node.style.cursor = 'pointer';
      node.addEventListener('mouseenter', () =>
        node.classList.add('node-hover')
      );
      node.addEventListener('mouseleave', () =>
        node.classList.remove('node-hover')
      );
    });

    const edgeLabels = svg.querySelectorAll('.edgeLabel');
    edgeLabels.forEach((label) => (label.style.cursor = 'pointer'));
  }

  _fixArrowVisibility(container) {
    setTimeout(() => {
      const svg = container.querySelector('svg');
      if (!svg) return;

      const paths = svg.querySelectorAll('path');
      paths.forEach((p) => {
        const d = p.getAttribute('d');
        if (d && d.includes('M') && d.includes('L')) {
          p.setAttribute('stroke', '#000000');
          p.setAttribute('stroke-width', '4');
          p.setAttribute('fill', 'none');
          p.style.filter = 'drop-shadow(0 0 3px rgba(255,255,255,0.9))';
        }
      });

      const markers = svg.querySelectorAll('marker path, marker polygon');
      markers.forEach((m) => {
        m.setAttribute('fill', '#000000');
        m.setAttribute('stroke', '#ffffff');
        m.setAttribute('stroke-width', '2');
      });

      const edgePaths = svg.querySelectorAll('g.edgePath path, .edgePath path');
      edgePaths.forEach((e) => {
        e.setAttribute('stroke', '#000000');
        e.setAttribute('stroke-width', '4');
        e.setAttribute('fill', 'none');
        e.style.filter = 'drop-shadow(0 0 3px rgba(255,255,255,0.9))';
      });
    }, 50);
  }

  _isDiagramLarge(container) {
    const svg = container.querySelector('svg');
    if (!svg) return false;

    const vb = svg.getAttribute('viewBox');
    if (!vb) return false;

    const [, , w, h] = vb.split(' ').map(Number);
    return w > 1000 || h > 1000;
  }

  _addLoadingAnimation() {
    if (document.getElementById('generator-loading-styles')) return;

    const style = document.createElement('style');
    style.id = 'generator-loading-styles';
    style.textContent = `
      .loading-state{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:300px;gap:1rem}
      .loading-spinner{width:40px;height:40px;border:3px solid rgba(255,255,255,0.3);border-top-color:#fff;border-radius:50%;animation:spin 1s linear infinite}
      .loading-text{font-size:18px;color:#fff}
      .loading-tip{font-size:14px;color:rgba(255,255,255,0.7)}
      @keyframes spin{to{transform:rotate(360deg)}}
      .node-hover rect,
      .node-hover circle,
      .node-hover ellipse{stroke-width:3px!important;filter:brightness(1.1)}
    `;
    document.head.appendChild(style);
  }

  /**
   * Export the diagram in PNG, SVG or Mermaid form.
   */
  async exportDiagram(format) {
    if (!this.currentContainer) {
      throw new Error('No diagram to export');
    }

    const svg = this.currentContainer.querySelector('svg');
    if (!svg && format !== 'mermaid') {
      throw new Error('No SVG found to export');
    }

    switch (format) {
      case 'png':
        await this.utilities.exportAsPNG(svg);
        break;
      case 'svg':
        await this.utilities.exportAsSVG(svg);
        break;
      case 'mermaid': {
        const code = this.state.get('currentDiagramCode');
        await this.utilities.exportAsMermaid(code);
        break;
      }
      default:
        throw new Error(`Unknown export format: ${format}`);
    }
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\diagram\generator.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\diagram\mermaid.js:
// public/js/diagram/mermaid.js
/**
 * Mermaid diagram management
 * Handles initialization, rendering, and error recovery
 */

export class MermaidManager {
  constructor() {
    this.isReady = false;
    this.mermaid = null;
    this.initPromise = null;
    this.renderCount = 0;
  }

  /**
   * Wait for Mermaid to be available on window
   * @returns {Promise} Resolves when Mermaid is ready
   */
  async waitForReady() {
    if (this.isReady) {
      return this.mermaid;
    }

    if (this.initPromise) {
      return this.initPromise;
    }

    this.initPromise = this._initialize();
    return this.initPromise;
  }

  /**
   * Initialize Mermaid
   * @private
   * @returns {Promise} Resolves when initialized
   */
async _initialize() {
    console.log('🔄 Waiting for Mermaid...');

    // Wait for Mermaid to appear on window
    this.mermaid = await this._waitForGlobal('mermaid', 10000);
    
    if (!this.mermaid) {
        throw new Error('Mermaid failed to load');
    }

    // Configure Mermaid with simpler config
    const config = {
        startOnLoad: false,
        theme: 'default',
        securityLevel: 'loose',
        logLevel: 'error'
    };
    
    this.mermaid.initialize(config);
    
    this.isReady = true;
    console.log('✅ Mermaid initialized with version:', this.mermaid.version || 'unknown');
    
    return this.mermaid;
}

  /**
   * Wait for a global variable to be defined
   * @private
   * @param {string} name - Variable name
   * @param {number} timeout - Timeout in ms
   * @returns {Promise} Resolves with the variable value
   */
  _waitForGlobal(name, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      const check = () => {
        if (window[name]) {
          resolve(window[name]);
          return;
        }
        
        if (Date.now() - startTime > timeout) {
          reject(new Error(`Timeout waiting for ${name}`));
          return;
        }
        
        setTimeout(check, 100);
      };
      
      check();
    });
  }

  /**
   * Get Mermaid configuration
   * @private
   * @returns {Object} Mermaid config
   */
  _getMermaidConfig() {
    // Import config from our config module
    return {
      startOnLoad: false,
      theme: 'base',
      fontFamily: 'Arial, sans-serif',
      fontSize: '13px',
      securityLevel: 'loose',
      logLevel: 'error',
      flowchart: {
        htmlLabels: false,
        wrap: true,
        useMaxWidth: true,
        nodeSpacing: 50,
        rankSpacing: 50,
        curve: 'basis'
      },
      themeVariables: {
        primaryColor: '#ffffff',
        primaryTextColor: '#000000',
        primaryBorderColor: '#000000',
        lineColor: '#000000',
        arrowheadColor: '#000000',
        edgeLabelBackground: '#ffffff',
        defaultLinkColor: '#000000'
      }
    };
  }

  /**
   * Render a Mermaid diagram
   * @param {string} code - Mermaid diagram code
   * @param {HTMLElement} container - Container element
   * @returns {Promise<boolean>} Success status
   */
async render(code, container) {
    if (!this.isReady) {
        await this.waitForReady();
    }

    // Clear container
    container.innerHTML = '';
    
    // Create diagram element
    const diagramId = `mermaid-${++this.renderCount}`;
    const diagramDiv = document.createElement('div');
    diagramDiv.className = 'mermaid';
    diagramDiv.id = diagramId;
    diagramDiv.textContent = code;
    
    container.appendChild(diagramDiv);

    try {
        // Remove any existing diagrams with same ID
        this.mermaid.contentLoaded();
        
        // Render the diagram
        this.mermaid.init(undefined, diagramDiv);
        
        // Wait a bit for rendering to complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Check for rendering success
        const success = await this._checkRenderSuccess(container);
        
        if (!success) {
            throw new Error('Diagram rendering failed');
        }
        
        return true;
        
    } catch (error) {
        console.error('Mermaid render error:', error);
        this._handleRenderError(container, error);
        return false;
    }
}
  /**
   * Check if diagram rendered successfully
   * @private
   * @param {HTMLElement} container - Container element
   * @returns {Promise<boolean>} Success status
   */
  async _checkRenderSuccess(container) {
    // Wait a bit for rendering to complete
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Check for SVG
    const svg = container.querySelector('svg');
    if (!svg) {
      return false;
    }
    
    // Check for error indicators
    const errorElements = container.querySelectorAll(
      '.mermaidError, [data-mermaid-error], .error'
    );
    if (errorElements.length > 0) {
      return false;
    }
    
    // Check for error text
    const text = container.textContent || '';
    const hasError = /syntax error|error in text|parse error/i.test(text);
    
    return !hasError;
  }

  /**
   * Handle render error
   * @private
   * @param {HTMLElement} container - Container element
   * @param {Error} error - Error object
   */
  _handleRenderError(container, error) {
    const errorMessage = this._extractErrorMessage(error);
    
    container.innerHTML = `
      <div class="mermaid-error">
        <div class="error-icon">⚠️</div>
        <div class="error-title">Diagram Error</div>
        <div class="error-message">${errorMessage}</div>
        <div class="error-hint">Please try regenerating with a different query.</div>
      </div>
    `;
  }

  /**
   * Extract user-friendly error message
   * @private
   * @param {Error} error - Error object
   * @returns {string} Error message
   */
  _extractErrorMessage(error) {
    const message = error.message || String(error);
    
    // Common Mermaid errors
    if (message.includes('Parse error')) {
      return 'The diagram syntax is invalid.';
    }
    
    if (message.includes('Syntax error')) {
      return 'There is a syntax error in the diagram.';
    }
    
    if (message.includes('No diagram type detected')) {
      return 'The diagram type could not be determined.';
    }
    
    // Generic message
    return 'Failed to render the diagram.';
  }

  /**
   * Parse Mermaid code to extract diagram type
   * @param {string} code - Mermaid diagram code
   * @returns {string|null} Diagram type
   */
  parseDiagramType(code) {
    const firstLine = code.trim().split('\n')[0];
    
    // Common diagram types
    if (firstLine.includes('flowchart')) return 'flowchart';
    if (firstLine.includes('sequenceDiagram')) return 'sequence';
    if (firstLine.includes('gantt')) return 'gantt';
    if (firstLine.includes('pie')) return 'pie';
    if (firstLine.includes('graph')) return 'graph';
    if (firstLine.includes('stateDiagram')) return 'state';
    if (firstLine.includes('journey')) return 'journey';
    if (firstLine.includes('gitGraph')) return 'git';
    
    return null;
  }

  /**
   * Validate Mermaid code
   * @param {string} code - Mermaid diagram code
   * @returns {Object} Validation result
   */
  validateCode(code) {
    const result = {
      isValid: true,
      errors: []
    };
    
    // Check if empty
    if (!code || !code.trim()) {
      result.isValid = false;
      result.errors.push('Diagram code is empty');
      return result;
    }
    
    // Check for basic structure
    const lines = code.trim().split('\n');
    if (lines.length < 2) {
      result.isValid = false;
      result.errors.push('Diagram appears incomplete');
    }
    
    // Check for diagram type
    const type = this.parseDiagramType(code);
    if (!type && !code.includes('%%')) {
      result.isValid = false;
      result.errors.push('No valid diagram type found');
    }
    
    // Check for common syntax errors
    const openBrackets = (code.match(/\[/g) || []).length;
    const closeBrackets = (code.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      result.isValid = false;
      result.errors.push('Mismatched brackets');
    }
    
    const openParens = (code.match(/\(/g) || []).length;
    const closeParens = (code.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      result.isValid = false;
      result.errors.push('Mismatched parentheses');
    }
    
    return result;
  }

  /**
   * Clean and prepare Mermaid code
   * @param {string} code - Raw Mermaid code
   * @returns {string} Cleaned code
   */
  cleanCode(code) {
    // Remove markdown code fences if present
    code = code.replace(/^```mermaid\s*/i, '');
    code = code.replace(/```\s*$/, '');
    
    // Ensure proper line endings
    code = code.replace(/\r\n/g, '\n');
    
    // Trim each line but preserve structure
    const lines = code.split('\n').map(line => line.trimEnd());
    
    // Remove empty lines at start and end
    while (lines.length > 0 && lines[0] === '') {
      lines.shift();
    }
    while (lines.length > 0 && lines[lines.length - 1] === '') {
      lines.pop();
    }
    
    return lines.join('\n');
  }

  /**
   * Reset Mermaid state
   */
  reset() {
    if (this.mermaid) {
      this.mermaid.contentLoaded();
    }
    this.renderCount = 0;
  }
}

// Export singleton instance
export const mermaidManager = new MermaidManager();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\diagram\mermaid.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\diagram\utilities.js:
/**
 * public/js/diagram/utilities.js
 *
 * Diagram utility functions
 * Handles Copy, Save, Export, and Zoom functionality
 */

import { state } from '../core/state.js';

export class DiagramUtilities {
  constructor() {
    this.zoomLevel = 1;
    this.minZoom = 0.5;
    this.maxZoom = 3;
    this.zoomStep = 0.25;
  }

  /**
   * Add utility buttons to diagram container
   * @param {HTMLElement} container - Diagram container
   */
  addButtons(container) {
    // Prevent duplicate buttons
    if (container.querySelector('.diagram-utils')) return;

    const utils = document.createElement('div');
    utils.className = 'diagram-utils';

    // "Save text" button: export diagram's content as .txt
    const copyBtn = this._createButton('Save text', 'copy-icon', () => {
      this.exportDiagramContent();
    });

    // "Save PNG" button: export diagram as PNG
    const saveBtn = this._createButton('Save PNG', 'save-icon', () => {
      const svg = container.querySelector('svg');
      if (svg) this.exportAsPNG(svg);
    });

    // Append buttons
    utils.appendChild(copyBtn);
    utils.appendChild(saveBtn);

    // Insert at top of container
    container.insertBefore(utils, container.firstChild);
  }

  /**
   * Add zoom controls to diagram
   * @param {HTMLElement} container - Diagram container
   */
  addZoomControls(container) {
    // Check if controls already exist
    if (container.querySelector('.zoom-controls')) return;
    
    const controls = document.createElement('div');
    controls.className = 'zoom-controls';
    
    // Zoom out button
    const zoomOutBtn = this._createButton('-', 'zoom-out', () => {
      this.zoom(container, this.zoomLevel - this.zoomStep);
    });
    
    // Zoom level display
    const zoomDisplay = document.createElement('span');
    zoomDisplay.className = 'zoom-level';
    zoomDisplay.textContent = '100%';
    this.zoomDisplay = zoomDisplay;
    
    // Zoom in button
    const zoomInBtn = this._createButton('+', 'zoom-in', () => {
      this.zoom(container, this.zoomLevel + this.zoomStep);
    });
    
    // Reset zoom button
    const resetBtn = this._createButton('Reset', 'zoom-reset', () => {
      this.zoom(container, 1);
    });
    
    controls.appendChild(zoomOutBtn);
    controls.appendChild(zoomDisplay);
    controls.appendChild(zoomInBtn);
    controls.appendChild(resetBtn);
    
    container.appendChild(controls);
    
    // Add mouse wheel zoom
    this._addWheelZoom(container);
  }

  /**
   * Export diagram as PNG
   * @param {SVGElement} svg - SVG element
   */
  async exportAsPNG(svg) {
    if (!svg) return;
    
    try {
      const blob = await this._svgToBlob(svg, 'png');
      this._downloadBlob(blob, this._getFilename('png'));
      this._showNotification('PNG exported successfully!', 'success');
    } catch (error) {
      console.error('PNG export failed:', error);
      this._showNotification('Failed to export PNG', 'error');
    }
  }

  /** Export the raw bullet-point text we now hold in state */
  async exportDiagramContent() {
    const diagramContent = state.get('currentDiagramContent');
    if (!diagramContent) {
        this._showNotification('No diagram text available to save.', 'error');
         return;
     }

    const currentQuery = state.get('currentQuery') || 'No query found';

    // Format the content
    const contentLines = [];
    contentLines.push(`Query: "${currentQuery}"`);
    contentLines.push(`Generated: ${new Date().toLocaleString()}`);
    contentLines.push('');
    contentLines.push('--- Diagram Text ---');
    contentLines.push('');
    contentLines.push(diagramContent);

    const fileContent = contentLines.join('\n');

    try {
        await this._downloadTextFile(fileContent, this._getFilename('txt'));
        this._showNotification('Diagram text downloaded!', 'success');
    } catch (error) {
        console.error('Text export failed:', error);
        this._showNotification('Failed to download diagram text.', 'error');
    }
  }

  /**
   * Helper to download text file
   * @private
   */
  async _downloadTextFile(content, filename) {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    this._downloadBlob(blob, filename);
  }

  /**
   * Zoom diagram
   * @param {HTMLElement} container - Diagram container
   * @param {number} level - Zoom level
   */
  zoom(container, level) {
    level = Math.max(this.minZoom, Math.min(this.maxZoom, level));
    this.zoomLevel = level;
    
    const svg = container.querySelector('svg');
    if (!svg) return;
    
    svg.style.transform = `scale(${level})`;
    svg.style.transformOrigin = 'center';
    
    if (this.zoomDisplay) {
      this.zoomDisplay.textContent = `${Math.round(level * 100)}%`;
    }
    
    if (level !== 1) {
      container.classList.add('diagram-zoomed');
    } else {
      container.classList.remove('diagram-zoomed');
    }
  }

    /**
   * Convert SVG to blob for download
   * @private
   * @param {SVGElement} svg - SVG element
   * @param {string} format - Output format ('png' or 'webp')
   * @returns {Promise<Blob>}
   */
  async _svgToBlob(svg, format = 'png') {
    const clone = svg.cloneNode(true);
    const viewBox = (clone.getAttribute('viewBox') || '').split(' ').map(Number);
    let width, height;

    if (viewBox.length === 4) {
      [ , , width, height ] = viewBox;
    } else {
      const bbox = svg.getBBox();
      width = bbox.width;
      height = bbox.height;
      clone.setAttribute('viewBox', `0 0 ${width} ${height}`);
    }

    const scale = 4;
    clone.setAttribute('width', width * scale);
    clone.setAttribute('height', height * scale);
    
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('width', '100%');
    rect.setAttribute('height', '100%');
    rect.setAttribute('fill', 'white');
    clone.insertBefore(rect, clone.firstChild);
    
    const svgString = new XMLSerializer().serializeToString(clone);
    
    // --- START OF FIX ---
    // Convert the SVG string to a robust base64 data URL to prevent canvas tainting.
    // This is more reliable than using a blob URL.
    const url = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
    // --- END OF FIX ---

    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = width * scale;
        canvas.height = height * scale;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(blob => {
          // No need to revoke a data URL, so the cleanup step is removed.
          resolve(blob);
        }, `image/${format}`, 0.95);
      };
      // Updated error message for better debugging.
      img.onerror = () => { reject(new Error('Failed to load SVG into an image element.')); };
      img.src = url;
    });
  }
  /**
   * Download blob as file
   * @private
   * @param {Blob} blob - File blob
   * @param {string} filename - File name
   */
  _downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 250);
  }

  /**
   * Generate filename with timestamp
   * @private
   * @param {string} extension - File extension
   * @returns {string}
   */
  _getFilename(extension) {
    const date = new Date();
    const timestamp = date.toISOString().replace(/[:.]/g, '-').slice(0, -5);
    return `pitext-diagram-${timestamp}.${extension}`;
  }

  /**
   * Create button element
   * @private
   * @param {string} text - Button text
   * @param {string} className - CSS class
   * @param {Function} onClick - Click handler
   * @returns {HTMLElement}
   */
  _createButton(text, className, onClick) {
    const button = document.createElement('button');
    button.textContent = text;
    button.className = `diagram-btn ${className}`;
    button.onclick = onClick;
    return button;
  }

  /**
   * Add mouse wheel zoom
   * @private
   * @param {HTMLElement} container - Diagram container
   */
  _addWheelZoom(container) {
    container.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -this.zoomStep : this.zoomStep;
        this.zoom(container, this.zoomLevel + delta);
      }
    });
  }

  /**
   * Show notification
   * @private
   * @param {string} message - Notification message
   * @param {string} type - Notification type
   */
  _showNotification(message, type = 'info') {
    if (window.piTextApp?.dom) {
      window.piTextApp.dom.showNotification(message, type);
      return;
    }
    console.log(`[${type.toUpperCase()}] ${message}`);
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\diagram\utilities.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\selection\deepdive.js:
// public/js/selection/deepdive.js
/**
 * Deep dive functionality for selected diagram elements
 * Handles Q&A interactions about selected content
 */

export class DeepDive {
  constructor(api, state, dom) {
    this.api = api;
    this.state = state;
    this.dom = dom;
    this.responseContainer = null;
    this.queryInput = null;
    this.isProcessing = false;
  }

  /**
   * Initialize deep dive UI elements
   */
  init() {
    this.responseContainer = document.getElementById('deepDiveResponse');
    this.queryInput = document.getElementById('deepDiveQuery');
    
    if (!this.responseContainer || !this.queryInput) {
      console.warn('Deep dive UI elements not found');
    }
  }

  /**
   * Ask a question about the selected content
   * @param {string} question - User's question
   * @returns {Promise<void>}
   */
  async ask(question) {
    // Validate inputs
    if (!question || !question.trim()) {
      this.dom.showNotification('Please enter a question', 'warning');
      return;
    }
    
    const selectedText = this.state.get('selectedText');
    if (!selectedText) {
      this.dom.showNotification('Please select something first', 'info');
      return;
    }
    
    // Prevent concurrent requests
    if (this.isProcessing) {
      return;
    }
    
    this.isProcessing = true;
    this.state.setLoading('askingDeepDive', true);
    
    try {
      // Show loading state
      this._showLoading();
      
      // Make API request
      const response = await this.api.getDeepDive({
        selectedText: selectedText,
        question: question,
        originalQuery: this.state.get('currentQuery') || ''
      });
      
      // Validate response
      if (!response.success) {
        throw new Error(response.detail || 'Failed to get response');
      }
      
      // Display response
      this._displayResponse(selectedText, question, response.response);
      
      // Add to history
      this.state.addDeepDive({
        selectedText,
        question,
        response: response.response
      });
      
      // Clear input
      if (this.queryInput) {
        this.queryInput.value = '';
      }
      
    } catch (error) {
      console.error('Deep dive error:', error);
      this._showError(error);
      
    } finally {
      this.isProcessing = false;
      this.state.setLoading('askingDeepDive', false);
    }
  }

  /**
   * Display deep dive response
   * @private
   * @param {string} selectedText - Selected text
   * @param {string} question - User's question
   * @param {string} response - API response
   */
// pitext-desktop/public/js/selection/deepdive.js

  _displayResponse(selectedText, question, response) {
    if (!this.responseContainer) {
      this.responseContainer = document.getElementById('deepDiveResponse');
    }
    
    // Format the response
    const html = `
      <div class="deep-dive-content">
        <button class="close-btn" onclick="window.piTextApp.deepDive.close()">×</button>
        <div class="deep-dive-header">
          <h3>Deep Dive: ${this._escapeHtml(this._truncate(selectedText, 50))}</h3>
        </div>
        
        <div class="deep-dive-qa">
          <div class="answer">
            ${this._formatResponse(response)}
          </div>
        </div>
        
        <div class="deep-dive-actions">
          <button class="action-btn copy-btn" onclick="window.piTextApp.deepDive.copyResponse()">
            Copy Answer
          </button>
          <button class="action-btn save-btn" onclick="window.piTextApp.deepDive.saveResponse()">
            Save as TXT
          </button>
          <button class="action-btn ask-followup-btn" onclick="window.piTextApp.deepDive.focusInput()">
            Ask Follow-up
          </button>
        </div>
        
        <div class="deep-dive-history">
          <details>
            <summary>Previous questions (${this._getHistoryCount()})</summary>
            <div class="history-list">
              ${this._renderHistory()}
            </div>
          </details>
        </div>
      </div>
    `;
    
    this.responseContainer.innerHTML = html;
    this.dom.showElement(this.responseContainer);
    
    // Store current response for actions
    this.currentResponse = {
      selectedText,
      question,
      response
    };
    
    // Animate in
    this._animateIn();
  }
  /**
   * Show loading state
   * @private
   */
  _showLoading() {
    if (!this.responseContainer) return;
    
    this.responseContainer.innerHTML = `
      <div class="deep-dive-loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Diving deep...</div>
      </div>
    `;
    
    this.dom.showElement(this.responseContainer);
  }

  /**
   * Show error state
   * @private
   * @param {Error} error - Error object
   */
  _showError(error) {
    if (!this.responseContainer) return;
    
    const userMessage = error.getUserMessage 
      ? error.getUserMessage() 
      : 'Failed to get response. Please try again.';
    
    this.responseContainer.innerHTML = `
      <div class="deep-dive-error">
        <div class="error-icon">⚠️</div>
        <div class="error-message">${userMessage}</div>
        <button class="retry-btn" onclick="window.piTextApp.deepDive.retry()">
          Try Again
        </button>
      </div>
    `;
    
    this.dom.showElement(this.responseContainer);
  }

  /**
   * Format response text
   * @private
   * @param {string} response - Raw response text
   * @returns {string} Formatted HTML
   */
  _formatResponse(response) {
    // Escape HTML first
    let formatted = this._escapeHtml(response);
    
    // Convert line breaks to paragraphs
    const paragraphs = formatted.split('\n\n').filter(p => p.trim());
    formatted = paragraphs.map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('');
    
    // Add syntax highlighting for code blocks
    formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Make lists look better
    formatted = formatted.replace(/^- (.+)$/gm, '<li>$1</li>');
    formatted = formatted.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
    
    // Highlight key terms from the selected text
    const terms = this._extractKeyTerms(this.state.get('selectedText'));
    terms.forEach(term => {
      const regex = new RegExp(`\\b(${term})\\b`, 'gi');
      formatted = formatted.replace(regex, '<mark>$1</mark>');
    });
    
    return formatted;
  }

  /**
   * Copy current response to clipboard
   */
  async copyResponse() {
    if (!this.currentResponse) return;
    
    const text = `Q: ${this.currentResponse.question}\n\nA: ${this.currentResponse.response}`;
    
    try {
      await navigator.clipboard.writeText(text);
      this.dom.showNotification('Answer copied to clipboard!', 'success');
    } catch (error) {
      console.error('Copy failed:', error);
      this.dom.showNotification('Failed to copy answer', 'error');
    }
  }

  /**
   * Save current response as text file
   */
  saveResponse() {
    if (!this.currentResponse) return;
    
    const content = [
      `Deep Dive: ${this.currentResponse.selectedText}`,
      '=' .repeat(50),
      '',
      `Q: ${this.currentResponse.question}`,
      '',
      `A: ${this.currentResponse.response}`,
      '',
      '---',
      `Generated on: ${new Date().toLocaleString()}`
    ].join('\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `deep-dive-${Date.now()}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.dom.showNotification('Response saved!', 'success');
  }

  /**
   * Focus on input for follow-up question
   */
  focusInput() {
    if (this.queryInput) {
      this.queryInput.focus();
      this.queryInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  /**
   * Close deep dive panel
   */
  close() {
    if (this.responseContainer) {
      this._animateOut(() => {
        this.dom.hideElement(this.responseContainer);
        this.currentResponse = null;
      });
    }
  }

  /**
   * Retry last question
   */
  retry() {
    if (this.queryInput && this.queryInput.value) {
      this.ask(this.queryInput.value);
    }
  }

  /**
   * Get history count for current selection
   * @private
   * @returns {number}
   */
  _getHistoryCount() {
    const selectedText = this.state.get('selectedText');
    const history = this.state.get('deepDiveHistory') || [];
    
    return history.filter(item => 
      item.selectedText === selectedText
    ).length;
  }

  /**
   * Render history for current selection
   * @private
   * @returns {string} HTML
   */
  _renderHistory() {
    const selectedText = this.state.get('selectedText');
    const history = this.state.get('deepDiveHistory') || [];
    
    const relevant = history
      .filter(item => item.selectedText === selectedText)
      .slice(0, 5);
    
    if (relevant.length === 0) {
      return '<p class="no-history">No previous questions for this selection</p>';
    }
    
    return relevant.map(item => `
      <div class="history-item" onclick="window.piTextApp.deepDive.loadFromHistory('${item.question}')">
        <div class="history-question">${this._escapeHtml(item.question)}</div>
        <div class="history-time">${this._formatTime(item.timestamp)}</div>
      </div>
    `).join('');
  }

  /**
   * Load question from history
   * @param {string} question - Historical question
   */
  loadFromHistory(question) {
    if (this.queryInput) {
      this.queryInput.value = question;
      this.focusInput();
    }
  }

  /**
   * Extract key terms from text
   * @private
   * @param {string} text - Source text
   * @returns {string[]} Key terms
   */
  _extractKeyTerms(text) {
    // Simple extraction - words longer than 4 chars
    const words = text.split(/\W+/);
    return words
      .filter(w => w.length > 4)
      .map(w => w.toLowerCase())
      .filter((w, i, arr) => arr.indexOf(w) === i) // unique
      .slice(0, 5); // limit to 5 terms
  }

  /**
   * Escape HTML
   * @private
   * @param {string} text - Raw text
   * @returns {string} Escaped text
   */
  _escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Truncate text
   * @private
   * @param {string} text - Text to truncate
   * @param {number} length - Max length
   * @returns {string} Truncated text
   */
  _truncate(text, length) {
    if (text.length <= length) return text;
    return text.substring(0, length) + '...';
  }

  /**
   * Format timestamp
   * @private
   * @param {number} timestamp - Unix timestamp
   * @returns {string} Formatted time
   */
  _formatTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    
    if (diff < 60000) return 'just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)} min ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)} hours ago`;
    
    return date.toLocaleDateString();
  }

  /**
   * Animate panel in
   * @private
   */
  _animateIn() {
    if (!this.responseContainer) return;
    
    this.responseContainer.style.opacity = '0';
    this.responseContainer.style.transform = 'translateY(20px)';
    
    setTimeout(() => {
      this.responseContainer.style.transition = 'all 0.3s ease-out';
      this.responseContainer.style.opacity = '1';
      this.responseContainer.style.transform = 'translateY(0)';
    }, 10);
  }

  /**
   * Animate panel out
   * @private
   * @param {Function} callback - Callback after animation
   */
  _animateOut(callback) {
    if (!this.responseContainer) return;
    
    this.responseContainer.style.transition = 'all 0.2s ease-in';
    this.responseContainer.style.opacity = '0';
    this.responseContainer.style.transform = 'translateY(20px)';
    
    setTimeout(callback, 200);
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\selection\deepdive.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\selection\handler.js:
// public/js/selection/handler.js
/**
 * Selection handler for diagram elements
 * Manages selection of nodes, edges, and text in Mermaid diagrams
 */

export class SelectionHandler {
  constructor(state, dom) {
    this.state = state;
    this.dom = dom;
    this.selectedClass = 'element-selected';
    this.currentContainer = null;
  }

  /**
   * Set up selection handling for a container
   * @param {HTMLElement} container - Diagram container
   */
  setupForContainer(container) {
    this.currentContainer = container;
    const svg = container.querySelector('svg');
    
    if (!svg) {
      console.warn('No SVG found in container');
      return;
    }
    
    // Clear any existing selection
    this.clearSelection();
    
    // Set up different selection types based on diagram type
    const diagramType = this._detectDiagramType(svg);
    
    switch (diagramType) {
      case 'flowchart':
      case 'graph':
        this._setupFlowchartSelection(svg);
        break;
      case 'sequence':
        this._setupSequenceSelection(svg);
        break;
      default:
        this._setupGenericSelection(svg);
    }
    
    // Set up canvas click to deselect
    this._setupCanvasDeselect(svg);
  }

  /**
   * Clear current selection
   */
  clearSelection() {
    // Remove visual selection
    if (this.state.get('selectedElement')) {
      this._removeSelectionStyling(this.state.get('selectedElement'));
    }
    
    // Clear state
    this.state.clearSelection();
    
    // Hide selection UI
    const indicator = document.getElementById('selectionIndicator');
    if (indicator) {
      this.dom.hideElement(indicator);
    }
    
    // Clear deep dive response
    const response = document.getElementById('deepDiveResponse');
    if (response) {
      this.dom.hideElement(response);
    }
  }

  /**
   * Handle element selection
   * @param {Element} element - Selected element
   * @param {string} text - Selected text
   */
  selectElement(element, text) {
    // Clear previous selection
    if (this.state.get('selectedElement')) {
      this._removeSelectionStyling(this.state.get('selectedElement'));
    }
    
    // Apply selection styling
    this._applySelectionStyling(element);
    
    // Update state
    this.state.setSelection(element, text);
    
    // Show selection UI
    this._showSelectionUI(text);
  }

  /**
   * Set up flowchart/graph selection
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupFlowchartSelection(svg) {
    // Nodes
    const nodes = svg.querySelectorAll('g.node, .node');
    nodes.forEach(node => {
      node.style.cursor = 'pointer';
      
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        const text = this._extractNodeText(node);
        if (text) {
          this.selectElement(node, text);
        }
      });
    });
    
    // Edge labels
    const edgeLabels = svg.querySelectorAll('.edgeLabel, g.edgeLabel');
    edgeLabels.forEach(label => {
      label.style.cursor = 'pointer';
      
      label.addEventListener('click', (e) => {
        e.stopPropagation();
        const text = this._extractEdgeText(label);
        if (text) {
          this.selectElement(label, text);
        }
      });
    });
  }

  /**
   * Set up sequence diagram selection
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupSequenceSelection(svg) {
    // Participants/actors
    const actors = svg.querySelectorAll('g.actor, .actor');
    actors.forEach(actor => {
      const text = actor.querySelector('text');
      if (text) {
        text.style.cursor = 'pointer';
        text.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(text, text.textContent.trim());
        });
      }
    });
    
    // Notes and messages
    const notes = svg.querySelectorAll('g.note, .note');
    notes.forEach(note => {
      note.style.cursor = 'pointer';
      
      note.addEventListener('click', (e) => {
        e.stopPropagation();
        const text = this._extractNoteText(note);
        if (text) {
          this.selectElement(note, text);
        }
      });
    });
    
    // Numbered lines in notes
    const tspans = svg.querySelectorAll('tspan');
    tspans.forEach(tspan => {
      const text = (tspan.textContent || '').trim();
      if (/^\d+[\.\)]\s/.test(text)) {
        tspan.style.cursor = 'pointer';
        tspan.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(tspan, text);
        });
      }
    });
    
    // Background rectangles for blocks
    const rects = svg.querySelectorAll('rect');
    rects.forEach(rect => {
      if (this._isSelectableRect(rect)) {
        rect.style.cursor = 'pointer';
        rect.addEventListener('click', (e) => {
          e.stopPropagation();
          const text = this._extractBlockText(rect, svg);
          if (text) {
            this.selectElement(rect, text);
          }
        });
      }
    });
  }

  /**
   * Set up generic selection for other diagram types
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupGenericSelection(svg) {
    // Any text element
    const texts = svg.querySelectorAll('text');
    texts.forEach(text => {
      if (text.textContent.trim()) {
        text.style.cursor = 'pointer';
        text.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(text, text.textContent.trim());
        });
      }
    });
    
    // Any labeled group
    const groups = svg.querySelectorAll('g[id]');
    groups.forEach(group => {
      const text = group.querySelector('text');
      if (text && text.textContent.trim()) {
        group.style.cursor = 'pointer';
        group.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(group, text.textContent.trim());
        });
      }
    });
  }

  /**
   * Set up canvas deselection
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupCanvasDeselect(svg) {
    svg.addEventListener('click', (e) => {
      // Only deselect if clicked on SVG background
      if (e.target === svg || e.target.classList.contains('background')) {
        this.clearSelection();
      }
    });
  }

  /**
   * Apply selection styling to element
   * @private
   * @param {Element} element - Element to style
   */
  _applySelectionStyling(element) {
    element.classList.add(this.selectedClass);
    
    const tagName = element.tagName.toLowerCase();
    
    switch (tagName) {
      case 'text':
      case 'tspan':
        element.style.fontWeight = 'bold';
        element.style.filter = 'drop-shadow(0 0 4px #ffb300)';
        break;
        
      case 'rect':
        element.setAttribute('data-original-stroke', element.getAttribute('stroke') || '');
        element.setAttribute('data-original-stroke-width', element.getAttribute('stroke-width') || '');
        element.setAttribute('stroke', '#ffb300');
        element.setAttribute('stroke-width', '5');
        element.style.filter = 'drop-shadow(0 0 6px #ffb300)';
        break;
        
      case 'g':
        // For groups, highlight the shape inside
        const shape = element.querySelector('rect, circle, ellipse, polygon');
        if (shape) {
          shape.setAttribute('data-original-stroke', shape.getAttribute('stroke') || '');
          shape.setAttribute('data-original-stroke-width', shape.getAttribute('stroke-width') || '');
          shape.setAttribute('stroke', '#ffb300');
          shape.setAttribute('stroke-width', '3');
        }
        // Highlight text
        const text = element.querySelector('text');
        if (text) {
          text.style.fontWeight = 'bold';
        }
        break;
    }
  }

  /**
   * Remove selection styling from element
   * @private
   * @param {Element} element - Element to unstyle
   */
  _removeSelectionStyling(element) {
    if (!element) return;
    
    element.classList.remove(this.selectedClass);
    
    const tagName = element.tagName.toLowerCase();
    
    switch (tagName) {
      case 'text':
      case 'tspan':
        element.style.fontWeight = '';
        element.style.filter = '';
        break;
        
      case 'rect':
        const originalStroke = element.getAttribute('data-original-stroke');
        const originalWidth = element.getAttribute('data-original-stroke-width');
        if (originalStroke !== null) {
          element.setAttribute('stroke', originalStroke);
        }
        if (originalWidth !== null) {
          element.setAttribute('stroke-width', originalWidth);
        }
        element.style.filter = '';
        break;
        
      case 'g':
        // Restore group children
        const shape = element.querySelector('rect, circle, ellipse, polygon');
        if (shape) {
          const origStroke = shape.getAttribute('data-original-stroke');
          const origWidth = shape.getAttribute('data-original-stroke-width');
          if (origStroke !== null) {
            shape.setAttribute('stroke', origStroke);
          }
          if (origWidth !== null) {
            shape.setAttribute('stroke-width', origWidth);
          }
        }
        const text = element.querySelector('text');
        if (text) {
          text.style.fontWeight = '';
        }
        break;
    }
  }

  /**
   * Show selection UI
   * @private
   * @param {string} text - Selected text
   */
  _showSelectionUI(text) {
    const indicator = document.getElementById('selectionIndicator');
    const selectedTextSpan = document.getElementById('selectedText');
    const deepDiveInput = document.getElementById('deepDiveQuery');
    
    if (indicator && selectedTextSpan) {
      selectedTextSpan.textContent = text;
      this.dom.showElement(indicator);
      
      // Focus on deep dive input
      if (deepDiveInput) {
        deepDiveInput.value = '';
        deepDiveInput.focus();
      }
    }
  }

  /**
   * Extract text from node
   * @private
   * @param {Element} node - Node element
   * @returns {string} Extracted text
   */
  _extractNodeText(node) {
    // Try multiple selectors
    const textElement = node.querySelector('text, .nodeLabel, span');
    
    if (textElement) {
      // Handle tspans
      const tspans = textElement.querySelectorAll('tspan');
      if (tspans.length > 0) {
        return Array.from(tspans)
          .map(t => t.textContent.trim())
          .filter(Boolean)
          .join(' ');
      }
      
      return textElement.textContent.trim();
    }
    
    return '';
  }

  /**
   * Extract text from edge label
   * @private
   * @param {Element} label - Edge label element
   * @returns {string} Extracted text
   */
  _extractEdgeText(label) {
    const text = label.querySelector('text, span');
    return text ? text.textContent.trim() : label.textContent.trim();
  }

  /**
   * Extract text from note
   * @private
   * @param {Element} note - Note element
   * @returns {string} Extracted text
   */
  _extractNoteText(note) {
    const texts = note.querySelectorAll('text');
    return Array.from(texts)
      .map(t => t.textContent.trim())
      .filter(Boolean)
      .join('\n');
  }

  /**
   * Extract text from block (sequence diagram)
   * @private
   * @param {Element} rect - Rectangle element
   * @param {SVGElement} svg - SVG container
   * @returns {string} Extracted text
   */
  _extractBlockText(rect, svg) {
    const bbox = rect.getBBox();
    
    // Find all text elements within this rectangle
    const texts = Array.from(svg.querySelectorAll('text')).filter(text => {
      const textBox = text.getBBox();
      return (
        textBox.x >= bbox.x - 5 &&
        textBox.x + textBox.width <= bbox.x + bbox.width + 5 &&
        textBox.y >= bbox.y - 5 &&
        textBox.y + textBox.height <= bbox.y + bbox.height + 5
      );
    });
    
    return texts
      .map(t => t.textContent.trim())
      .filter(Boolean)
      .join('\n');
  }

  /**
   * Check if rect is selectable
   * @private
   * @param {Element} rect - Rectangle element
   * @returns {boolean}
   */
  _isSelectableRect(rect) {
    const fill = rect.getAttribute('fill');
    
    // Skip white/transparent/no fill
    if (!fill || ['#fff', '#ffffff', 'white', 'none', 'transparent'].includes(fill.toLowerCase())) {
      return false;
    }
    
    // Must be reasonably sized
    const width = parseFloat(rect.getAttribute('width')) || 0;
    const height = parseFloat(rect.getAttribute('height')) || 0;
    
    return width > 100 && height > 40;
  }

  /**
   * Detect diagram type from SVG
   * @private
   * @param {SVGElement} svg - SVG element
   * @returns {string} Diagram type
   */
  _detectDiagramType(svg) {
    // Check for specific class names or structures
    if (svg.querySelector('.actor, .note, sequenceDiagram')) {
      return 'sequence';
    }
    if (svg.querySelector('.node, .edgePath, .flowchart')) {
      return 'flowchart';
    }
    if (svg.querySelector('.gantt')) {
      return 'gantt';
    }
    if (svg.querySelector('.pie')) {
      return 'pie';
    }
    
    return 'generic';
  }

  /**
   * Decode HTML entities
   * @param {string} text - Text with entities
   * @returns {string} Decoded text
   */
  decodeEntities(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\selection\handler.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\ui\events.js:
// public/js/ui/events.js
/**
 * Event handler setup
 * Sets up all application event listeners
 */

import { setupKeyboardShortcuts } from './shortcuts.js';

/**
 * Set up all event listeners
 * @param {Object} app - Main app instance
 */
// In pitext-desktop/public/js/ui/events.js, update the event listeners:

export function setupEventListeners(app) {
    // Generate button
    const generateBtn = document.getElementById('generateBtn');
    if (generateBtn) {
        generateBtn.addEventListener('click', (e) => {
            e.preventDefault();
            app.handleGenerate();
        });
    }
    
    // Ask button (for deep dive)
    const askBtn = document.getElementById('askBtn');
    if (askBtn) {
        askBtn.addEventListener('click', (e) => {
            e.preventDefault();
            app.handleAsk();
        });
    }
    
    // Enter key on query input
    const queryInput = document.getElementById('query');
    if (queryInput) {
        queryInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                app.handleGenerate();
            }
        });
    }
    
    // Enter key on deep dive input
    const deepDiveInput = document.getElementById('deepDiveQuery');
    if (deepDiveInput) {
        deepDiveInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                app.handleAsk();
            }
        });
    }

    // Example buttons
    const exampleBtns = document.querySelectorAll('.example-btn');
    if (exampleBtns.length && queryInput) {
        exampleBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const queryText = btn.getAttribute('data-query');
                queryInput.value = queryText;
                queryInput.focus();
            });
        });
    }
    
    // Set up keyboard shortcuts
    setupKeyboardShortcuts(app);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\ui\events.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\ui\shortcuts.js:
// public/js/ui/shortcuts.js
/**
 * Keyboard shortcut handlers
 * Sets up global keyboard shortcuts
 */

/**
 * Set up keyboard shortcuts
 * @param {Object} app - Main app instance
 */
export function setupKeyboardShortcuts(app) {
  // Global keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + Enter to generate
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      app.handleGenerate();
    }
    
    // Escape to clear selection
    if (e.key === 'Escape' && app.state.hasSelection()) {
      app.selection.clearSelection();
    }
  });
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\ui\shortcuts.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\utils\dom.js:
// public/js/utils/dom.js
/**
 * DOM manipulation utilities
 * Provides common DOM operations and UI helpers
 */

export class DOMHelpers {
  constructor() {
    this.notificationContainer = null;
    this.notificationTimeout = null;
    this._ensureNotificationContainer();
  }

  /**
   * Get multiple elements by selectors
   * @param {Object} selectors - Object with key: selector pairs
   * @returns {Object} Object with key: element pairs
   */
  getElements(selectors) {
    const elements = {};
    
    Object.entries(selectors).forEach(([key, selector]) => {
      elements[key] = document.querySelector(selector);
      
      if (!elements[key]) {
        console.warn(`Element not found: ${selector}`);
      }
    });
    
    return elements;
  }

  /**
   * Show element with optional animation
   * @param {HTMLElement} element - Element to show
   * @param {string} animation - Animation type ('fade', 'slide', 'none')
   */
  showElement(element, animation = 'fade') {
    if (!element) return;
    
    switch (animation) {
      case 'fade':
        element.style.display = 'block';
        element.style.opacity = '0';
        element.classList.add('active');
        
        // Force reflow
        element.offsetHeight;
        
        element.style.transition = 'opacity 0.3s ease-out';
        element.style.opacity = '1';
        break;
        
      case 'slide':
        element.style.display = 'block';
        element.style.transform = 'translateY(-20px)';
        element.style.opacity = '0';
        element.classList.add('active');
        
        // Force reflow
        element.offsetHeight;
        
        element.style.transition = 'all 0.3s ease-out';
        element.style.transform = 'translateY(0)';
        element.style.opacity = '1';
        break;
        
      default:
        element.style.display = 'block';
        element.classList.add('active');
    }
  }

  /**
   * Hide element with optional animation
   * @param {HTMLElement} element - Element to hide
   * @param {string} animation - Animation type ('fade', 'slide', 'none')
   */
  hideElement(element, animation = 'fade') {
    if (!element) return;
    
    const hide = () => {
      element.style.display = 'none';
      element.classList.remove('active');
    };
    
    switch (animation) {
      case 'fade':
        element.style.transition = 'opacity 0.2s ease-in';
        element.style.opacity = '0';
        setTimeout(hide, 200);
        break;
        
      case 'slide':
        element.style.transition = 'all 0.2s ease-in';
        element.style.transform = 'translateY(-20px)';
        element.style.opacity = '0';
        setTimeout(hide, 200);
        break;
        
      default:
        hide();
    }
  }

  /**
   * Toggle element visibility
   * @param {HTMLElement} element - Element to toggle
   * @param {string} animation - Animation type
   */
  toggleElement(element, animation = 'fade') {
    if (!element) return;
    
    const isVisible = element.classList.contains('active') || 
                     element.style.display !== 'none';
    
    if (isVisible) {
      this.hideElement(element, animation);
    } else {
      this.showElement(element, animation);
    }
  }

  /**
   * Show notification
   * @param {string} message - Notification message
   * @param {string} type - Notification type ('success', 'error', 'warning', 'info')
   * @param {number} duration - Duration in ms (0 for persistent)
   */
  showNotification(message, type = 'info', duration = 3000) {
    this._ensureNotificationContainer();
    
    // Clear existing timeout
    if (this.notificationTimeout) {
      clearTimeout(this.notificationTimeout);
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    
    // Add icon
    const icon = this._getNotificationIcon(type);
    
    // Build content
    notification.innerHTML = `
      <span class="notification-icon">${icon}</span>
      <span class="notification-message">${this._escapeHtml(message)}</span>
      <button class="notification-close" onclick="this.parentElement.remove()">×</button>
    `;
    
    // Add to container
    this.notificationContainer.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.classList.add('notification-show');
    }, 10);
    
    // Auto-remove if duration > 0
    if (duration > 0) {
      this.notificationTimeout = setTimeout(() => {
        this._removeNotification(notification);
      }, duration);
    }
    
    // Click to dismiss
    notification.addEventListener('click', () => {
      this._removeNotification(notification);
    });
  }

  /**
   * Clear all notifications
   */
  clearNotifications() {
    if (this.notificationContainer) {
      this.notificationContainer.innerHTML = '';
    }
  }

  /**
   * Add loading overlay to element
   * @param {HTMLElement} element - Target element
   * @param {string} message - Loading message
   */
  addLoadingOverlay(element, message = 'Loading...') {
    if (!element) return;
    
    // Remove existing overlay
    this.removeLoadingOverlay(element);
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.innerHTML = `
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-message">${this._escapeHtml(message)}</div>
      </div>
    `;
    
    // Position relative to element
    element.style.position = 'relative';
    element.appendChild(overlay);
    
    // Animate in
    setTimeout(() => {
      overlay.classList.add('loading-overlay-show');
    }, 10);
  }

  /**
   * Remove loading overlay from element
   * @param {HTMLElement} element - Target element
   */
  removeLoadingOverlay(element) {
    if (!element) return;
    
    const overlay = element.querySelector('.loading-overlay');
    if (overlay) {
      overlay.classList.remove('loading-overlay-show');
      setTimeout(() => overlay.remove(), 200);
    }
  }

  /**
   * Disable element with optional message
   * @param {HTMLElement} element - Element to disable
   * @param {string} message - Optional tooltip message
   */
  disableElement(element, message) {
    if (!element) return;
    
    element.disabled = true;
    element.classList.add('disabled');
    
    if (message) {
      element.setAttribute('title', message);
      element.setAttribute('data-disabled-message', message);
    }
  }

  /**
   * Enable element
   * @param {HTMLElement} element - Element to enable
   */
  enableElement(element) {
    if (!element) return;
    
    element.disabled = false;
    element.classList.remove('disabled');
    element.removeAttribute('title');
    element.removeAttribute('data-disabled-message');
  }

  /**
   * Smooth scroll to element
   * @param {HTMLElement|string} target - Element or selector
   * @param {Object} options - Scroll options
   */
  scrollToElement(target, options = {}) {
    const element = typeof target === 'string' 
      ? document.querySelector(target) 
      : target;
    
    if (!element) return;
    
    const defaultOptions = {
      behavior: 'smooth',
      block: 'center',
      inline: 'nearest'
    };
    
    element.scrollIntoView({ ...defaultOptions, ...options });
  }

  /**
   * Create and show tooltip
   * @param {HTMLElement} element - Target element
   * @param {string} text - Tooltip text
   * @param {string} position - Position ('top', 'bottom', 'left', 'right')
   */
  showTooltip(element, text, position = 'top') {
    if (!element) return;
    
    // Remove existing tooltip
    this.hideTooltip(element);
    
    // Create tooltip
    const tooltip = document.createElement('div');
    tooltip.className = `tooltip tooltip-${position}`;
    tooltip.textContent = text;
    tooltip.setAttribute('role', 'tooltip');
    
    // Position tooltip
    document.body.appendChild(tooltip);
    this._positionTooltip(tooltip, element, position);
    
    // Store reference
    element._tooltip = tooltip;
    
    // Animate in
    setTimeout(() => {
      tooltip.classList.add('tooltip-show');
    }, 10);
  }

  /**
   * Hide tooltip
   * @param {HTMLElement} element - Target element
   */
  hideTooltip(element) {
    if (!element || !element._tooltip) return;
    
    const tooltip = element._tooltip;
    tooltip.classList.remove('tooltip-show');
    
    setTimeout(() => {
      tooltip.remove();
      delete element._tooltip;
    }, 200);
  }

  /**
   * Add keyboard shortcut
   * @param {string} key - Key combination (e.g., 'ctrl+s', 'cmd+enter')
   * @param {Function} handler - Handler function
   * @param {string} description - Description for help
   */
  addKeyboardShortcut(key, handler, description) {
    // Parse key combination
    const parts = key.toLowerCase().split('+');
    const modifiers = {
      ctrl: false,
      cmd: false,
      alt: false,
      shift: false
    };
    
    let mainKey = '';
    
    parts.forEach(part => {
      if (part in modifiers) {
        modifiers[part] = true;
      } else {
        mainKey = part;
      }
    });
    
    // Add event listener
    document.addEventListener('keydown', (e) => {
      const isMatch = 
        (modifiers.ctrl === (e.ctrlKey || (modifiers.cmd && e.metaKey))) &&
        (modifiers.alt === e.altKey) &&
        (modifiers.shift === e.shiftKey) &&
        (e.key.toLowerCase() === mainKey);
      
      if (isMatch) {
        e.preventDefault();
        handler(e);
      }
    });
    
    // Store for help display
    if (!window._shortcuts) {
      window._shortcuts = [];
    }
    window._shortcuts.push({ key, description });
  }

  /**
   * Ensure notification container exists
   * @private
   */
  _ensureNotificationContainer() {
    if (!this.notificationContainer) {
      this.notificationContainer = document.getElementById('notifications');
      
      if (!this.notificationContainer) {
        this.notificationContainer = document.createElement('div');
        this.notificationContainer.id = 'notifications';
        this.notificationContainer.className = 'notification-container';
        document.body.appendChild(this.notificationContainer);
      }
    }
  }

  /**
   * Remove notification with animation
   * @private
   * @param {HTMLElement} notification - Notification element
   */
  _removeNotification(notification) {
    notification.classList.remove('notification-show');
    setTimeout(() => notification.remove(), 200);
  }

  /**
   * Get notification icon
   * @private
   * @param {string} type - Notification type
   * @returns {string} Icon HTML
   */
  _getNotificationIcon(type) {
    const icons = {
      success: '✓',
      error: '✕',
      warning: '⚠',
      info: 'ℹ'
    };
    
    return icons[type] || icons.info;
  }

  /**
   * Position tooltip relative to element
   * @private
   * @param {HTMLElement} tooltip - Tooltip element
   * @param {HTMLElement} target - Target element
   * @param {string} position - Position
   */
  _positionTooltip(tooltip, target, position) {
    const targetRect = target.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    const gap = 8;
    
    let top, left;
    
    switch (position) {
      case 'top':
        top = targetRect.top - tooltipRect.height - gap;
        left = targetRect.left + (targetRect.width - tooltipRect.width) / 2;
        break;
        
      case 'bottom':
        top = targetRect.bottom + gap;
        left = targetRect.left + (targetRect.width - tooltipRect.width) / 2;
        break;
        
      case 'left':
        top = targetRect.top + (targetRect.height - tooltipRect.height) / 2;
        left = targetRect.left - tooltipRect.width - gap;
        break;
        
      case 'right':
        top = targetRect.top + (targetRect.height - tooltipRect.height) / 2;
        left = targetRect.right + gap;
        break;
    }
    
    // Ensure tooltip stays within viewport
    top = Math.max(gap, Math.min(top, window.innerHeight - tooltipRect.height - gap));
    left = Math.max(gap, Math.min(left, window.innerWidth - tooltipRect.width - gap));
    
    tooltip.style.top = `${top}px`;
    tooltip.style.left = `${left}px`;
  }

  /**
   * Escape HTML
   * @private
   * @param {string} text - Raw text
   * @returns {string} Escaped text
   */
  _escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Add CSS styles dynamically
   * @param {string} id - Style ID
   * @param {string} css - CSS content
   */
  addStyles(id, css) {
    // Check if styles already exist
    if (document.getElementById(id)) return;
    
    const style = document.createElement('style');
    style.id = id;
    style.textContent = css;
    document.head.appendChild(style);
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\utils\dom.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\utils\helpers.js:
// public/js/utils/helpers.js
/**
 * General helper functions
 * Utility functions for common operations
 */

export class Helpers {
  /**
   * Debounce function execution
   * @param {Function} func - Function to debounce
   * @param {number} wait - Wait time in ms
   * @param {boolean} immediate - Execute immediately on first call
   * @returns {Function} Debounced function
   */
  debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
      const later = () => {
        timeout = null;
        if (!immediate) func(...args);
      };
      
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      
      if (callNow) func(...args);
    };
  }

  /**
   * Throttle function execution
   * @param {Function} func - Function to throttle
   * @param {number} limit - Time limit in ms
   * @returns {Function} Throttled function
   */
  throttle(func, limit) {
    let inThrottle;
    
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        
        setTimeout(() => {
          inThrottle = false;
        }, limit);
      }
    };
  }

  /**
   * Get user-friendly error message
   * @param {Error|string} error - Error object or message
   * @returns {string} User-friendly message
   */
  getErrorMessage(error) {
    // Handle API errors
    if (error && error.getUserMessage) {
      return error.getUserMessage();
    }
    
    // Handle known error types
    const errorString = error?.message || String(error);
    
    // Network errors
    if (errorString.includes('fetch')) {
      return 'Connection failed. Please check your internet.';
    }
    
    if (errorString.includes('timeout')) {
      return 'Request timed out. Please try again.';
    }
    
    // Generation errors
    if (errorString.includes('diagram')) {
      return 'Failed to generate.';
    }
    
    if (errorString.includes('render')) {
      return 'Failed. Please try again.';
    }
    
    // Validation errors
    if (errorString.includes('empty') || errorString.includes('required')) {
      return 'Please provide all required information.';
    }
    
    // Generic message
    return 'Something went wrong. Please try again.';
  }

  /**
   * Format file size
   * @param {number} bytes - Size in bytes
   * @param {number} decimals - Decimal places
   * @returns {string} Formatted size
   */
  formatFileSize(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }
    /**
   * Escape HTML special characters
   * @param {string} text - Text to escape
   * @returns {string} Escaped text
   */
  escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
  }

  /**
   * Format relative time
   * @param {Date|number} date - Date object or timestamp
   * @returns {string} Relative time string
   */
  formatRelativeTime(date) {
    const timestamp = date instanceof Date ? date.getTime() : date;
    const now = Date.now();
    const diff = now - timestamp;
    
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (seconds < 60) {
      return 'just now';
    } else if (minutes < 60) {
      return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
    } else if (hours < 24) {
      return `${hours} hour${hours > 1 ? 's' : ''} ago`;
    } else if (days < 7) {
      return `${days} day${days > 1 ? 's' : ''} ago`;
    } else {
      return new Date(timestamp).toLocaleDateString();
    }
  }

  /**
   * Deep clone object
   * @param {any} obj - Object to clone
   * @returns {any} Cloned object
   */
  deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }
    
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    
    if (obj instanceof Array) {
      return obj.map(item => this.deepClone(item));
    }
    
    if (obj instanceof RegExp) {
      return new RegExp(obj);
    }
    
    const cloned = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        cloned[key] = this.deepClone(obj[key]);
      }
    }
    
    return cloned;
  }

  /**
   * Generate unique ID
   * @param {string} prefix - Optional prefix
   * @returns {string} Unique ID
   */
  generateId(prefix = '') {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 9);
    return prefix ? `${prefix}-${timestamp}-${random}` : `${timestamp}-${random}`;
  }

  /**
   * Parse query string
   * @param {string} query - Query string
   * @returns {Object} Parsed parameters
   */
  parseQueryString(query = window.location.search) {
    const params = new URLSearchParams(query);
    const result = {};
    
    for (const [key, value] of params) {
      // Handle array parameters
      if (key.endsWith('[]')) {
        const arrayKey = key.slice(0, -2);
        if (!result[arrayKey]) {
          result[arrayKey] = [];
        }
        result[arrayKey].push(value);
      } else {
        result[key] = value;
      }
    }
    
    return result;
  }

  /**
   * Build query string from object
   * @param {Object} params - Parameters object
   * @returns {string} Query string
   */
  buildQueryString(params) {
    const searchParams = new URLSearchParams();
    
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach(v => searchParams.append(`${key}[]`, v));
      } else if (value !== null && value !== undefined) {
        searchParams.append(key, value);
      }
    });
    
    return searchParams.toString();
  }

  /**
   * Sanitize HTML string
   * @param {string} html - HTML string
   * @param {Object} options - Sanitization options
   * @returns {string} Sanitized HTML
   */
  sanitizeHtml(html, options = {}) {
    const defaults = {
      allowedTags: ['b', 'i', 'em', 'strong', 'a', 'code', 'pre', 'br', 'p', 'ul', 'li'],
      allowedAttributes: {
        'a': ['href', 'target', 'rel']
      }
    };
    
    const config = { ...defaults, ...options };
    
    // Create temporary element
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    // Remove script tags
    const scripts = temp.querySelectorAll('script');
    scripts.forEach(script => script.remove());
    
    // Remove event handlers
    const elements = temp.querySelectorAll('*');
    elements.forEach(el => {
      // Remove event attributes
      for (const attr of el.attributes) {
        if (attr.name.startsWith('on')) {
          el.removeAttribute(attr.name);
        }
      }
      
      // Check if tag is allowed
      if (!config.allowedTags.includes(el.tagName.toLowerCase())) {
        el.replaceWith(...el.childNodes);
      } else {
        // Remove disallowed attributes
        const allowedAttrs = config.allowedAttributes[el.tagName.toLowerCase()] || [];
        for (const attr of el.attributes) {
          if (!allowedAttrs.includes(attr.name)) {
            el.removeAttribute(attr.name);
          }
        }
      }
    });
    
    return temp.innerHTML;
  }

  /**
   * Detect mobile device
   * @returns {boolean} Is mobile device
   */
  isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }

  /**
   * Detect touch device
   * @returns {boolean} Has touch support
   */
  isTouchDevice() {
    return (
      'ontouchstart' in window ||
      navigator.maxTouchPoints > 0 ||
      navigator.msMaxTouchPoints > 0
    );
  }

  /**
   * Get browser info
   * @returns {Object} Browser information
   */
  getBrowserInfo() {
    const ua = navigator.userAgent;
    let browser = 'Unknown';
    let version = '';
    
    if (ua.includes('Firefox/')) {
      browser = 'Firefox';
      version = ua.match(/Firefox\/(\d+)/)[1];
    } else if (ua.includes('Chrome/')) {
      browser = 'Chrome';
      version = ua.match(/Chrome\/(\d+)/)[1];
    } else if (ua.includes('Safari/') && !ua.includes('Chrome')) {
      browser = 'Safari';
      version = ua.match(/Version\/(\d+)/)[1];
    } else if (ua.includes('Edge/')) {
      browser = 'Edge';
      version = ua.match(/Edge\/(\d+)/)[1];
    }
    
    return {
      browser,
      version,
      userAgent: ua,
      platform: navigator.platform,
      language: navigator.language
    };
  }

  /**
   * Copy text to clipboard with fallback
   * @param {string} text - Text to copy
   * @returns {Promise<boolean>} Success status
   */
  async copyToClipboard(text) {
    // Try modern API first
    if (navigator.clipboard && window.isSecureContext) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (err) {
        console.warn('Clipboard API failed:', err);
      }
    }
    
    // Fallback method
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      const successful = document.execCommand('copy');
      document.body.removeChild(textArea);
      return successful;
    } catch (err) {
      console.error('Fallback copy failed:', err);
      document.body.removeChild(textArea);
      return false;
    }
  }

  /**
   * Download data as file
   * @param {string|Blob} data - Data to download
   * @param {string} filename - File name
   * @param {string} type - MIME type
   */
  downloadFile(data, filename, type = 'text/plain') {
    const blob = data instanceof Blob ? data : new Blob([data], { type });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up
    setTimeout(() => URL.revokeObjectURL(url), 250);
  }

  /**
   * Load external script
   * @param {string} src - Script URL
   * @param {Object} options - Load options
   * @returns {Promise} Resolves when loaded
   */
  loadScript(src, options = {}) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      
      if (options.async !== false) {
        script.async = true;
      }
      
      if (options.defer) {
        script.defer = true;
      }
      
      if (options.crossOrigin) {
        script.crossOrigin = options.crossOrigin;
      }
      
      script.onload = () => resolve(script);
      script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
      
      document.head.appendChild(script);
    });
  }

  /**
   * Retry async operation
   * @param {Function} operation - Async operation
   * @param {number} maxAttempts - Maximum attempts
   * @param {number} delay - Delay between attempts
   * @returns {Promise} Operation result
   */
  async retry(operation, maxAttempts = 3, delay = 1000) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (attempt < maxAttempts) {
          console.warn(`Attempt ${attempt} failed, retrying...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError;
  }

  /**
   * Wait for condition to be true
   * @param {Function} condition - Condition function
   * @param {number} timeout - Timeout in ms
   * @param {number} interval - Check interval in ms
   * @returns {Promise} Resolves when condition is true
   */
  waitFor(condition, timeout = 5000, interval = 100) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      const check = () => {
        if (condition()) {
          resolve();
        } else if (Date.now() - startTime > timeout) {
          reject(new Error('Timeout waiting for condition'));
        } else {
          setTimeout(check, interval);
        }
      };
      
      check();
    });
  }
}

// Export singleton instance
export const helpers = new Helpers();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\public\js\utils\helpers.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\renderer.py:
# services/renderer.py
"""
Diagram rendering service.
Handles rendering Mermaid diagrams as HTML or images.
"""

import base64
import logging
from typing import Optional

from playwright.async_api import async_playwright, Browser, Page

from core.config import get_config
from api.models import RenderResult


logger = logging.getLogger(__name__)


class DiagramRenderer:
    """Handles rendering of Mermaid diagrams."""
    
    def __init__(self):
        """Initialize the renderer with configuration."""
        self.config = get_config()
        self._browser: Optional[Browser] = None
    
    async def render(self, mermaid_code: str) -> RenderResult:
        """
        Render a Mermaid diagram based on configured mode.
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            RenderResult with type and content
            
        Raises:
            Exception: If rendering fails
        """
        if self.config.RENDER_MODE == "image":
            return await self._render_as_image(mermaid_code)
        else:
            return self._render_as_html(mermaid_code)
    
    def _render_as_html(self, mermaid_code: str) -> RenderResult:
        """
        Render diagram as HTML (client-side rendering).
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            RenderResult with HTML content
        """
        logger.debug("Rendering as HTML")
        
        return RenderResult(
            render_type="html",
            rendered_content=mermaid_code
        )
    
    async def _render_as_image(self, mermaid_code: str) -> RenderResult:
        """
        Render diagram as PNG image using Playwright.
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            RenderResult with base64-encoded image
            
        Raises:
            Exception: If browser rendering fails
        """
        logger.debug("Rendering as image using Playwright")
        
        html_content = self._create_html_page(mermaid_code)
        
        async with async_playwright() as p:
            browser = await p.chromium.launch(
                headless=True,
                args=self.config.PLAYWRIGHT_ARGS
            )
            
            try:
                page = await browser.new_page()
                
                # Set viewport for consistent rendering
                await page.set_viewport_size({"width": 1200, "height": 800})
                
                # Load the HTML content
                await page.set_content(html_content)
                
                # Wait for Mermaid to render
                try:
                    await page.wait_for_selector(
                        '.mermaid svg',
                        timeout=self.config.PLAYWRIGHT_TIMEOUT
                    )
                except Exception as e:
                    logger.error(f"Mermaid rendering timeout: {str(e)}")
                    # Try to get any error message
                    error_text = await self._get_mermaid_error(page)
                    if error_text:
                        raise ValueError(f"Mermaid error: {error_text}")
                    raise ValueError("Failed to render Mermaid diagram")
                
                # Get the diagram element
                element = await page.query_selector('.mermaid')
                if not element:
                    raise ValueError("No Mermaid diagram found in rendered page")
                
                # Take screenshot
                screenshot = await element.screenshot(
                    type='png',
                    omit_background=True
                )
                
                # Encode as base64
                encoded = base64.b64encode(screenshot).decode('utf-8')
                data_url = f"data:image/png;base64,{encoded}"
                
                logger.info("Successfully rendered diagram as image")
                
                return RenderResult(
                    render_type="image",
                    rendered_content=data_url
                )
                
            finally:
                await browser.close()
    
    def _create_html_page(self, mermaid_code: str) -> str:
        """
        Create a minimal HTML page for rendering.
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            Complete HTML page as string
        """
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{
                    margin: 0;
                    padding: 20px;
                    background: white;
                    font-family: Arial, sans-serif;
                }}
                .mermaid {{
                    text-align: center;
                }}
                .error {{
                    color: red;
                    padding: 20px;
                    border: 1px solid red;
                    background: #ffeeee;
                }}
            </style>
            <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
            <script>
                mermaid.initialize({{ 
                    startOnLoad: true,
                    theme: 'default',
                    fontFamily: 'Arial, sans-serif',
                    fontSize: 14,
                    securityLevel: 'loose'
                }});
                
                // Error handling
                window.addEventListener('error', function(e) {{
                    document.body.innerHTML = '<div class="error">Rendering error: ' + e.message + '</div>';
                }});
            </script>
        </head>
        <body>
            <div class="mermaid">
{mermaid_code}
            </div>
        </body>
        </html>
        """
    
    async def _get_mermaid_error(self, page: Page) -> Optional[str]:
        """
        Try to extract any Mermaid error message from the page.
        
        Args:
            page: Playwright page object
            
        Returns:
            Error message if found, None otherwise
        """
        try:
            # Check for error elements
            error_element = await page.query_selector('.error')
            if error_element:
                return await error_element.text_content()
            
            # Check for Mermaid error in console
            # This would require setting up console message handling
            
            return None
        except Exception:
            return None


# Create a singleton renderer instance
_renderer = DiagramRenderer()


async def render_diagram(mermaid_code: str) -> RenderResult:
    """
    Render a Mermaid diagram.
    
    This is the main entry point for diagram rendering.
    
    Args:
        mermaid_code: Mermaid diagram code
        
    Returns:
        RenderResult with render_type and rendered_content
        
    Raises:
        ValueError: If diagram is invalid
        Exception: If rendering fails
    """
    if not mermaid_code or not mermaid_code.strip():
        raise ValueError("Mermaid code cannot be empty")
    
    return await _renderer.render(mermaid_code.strip())


async def render_as_image(mermaid_code: str) -> str:
    """
    Force render a diagram as an image.
    
    Useful for testing or when you specifically need an image.
    
    Args:
        mermaid_code: Mermaid diagram code
        
    Returns:
        Base64-encoded PNG data URL
    """
    renderer = DiagramRenderer()
    # Override config temporarily
    renderer.config.RENDER_MODE = "image"
    result = await renderer.render(mermaid_code)
    return result.rendered_content

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\renderer.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\client.py:
# services/llm/client.py
"""
OpenAI client management and LLM interaction utilities.
Provides a singleton client and common LLM operations.
"""

from typing import Optional, List, Dict, Any
from functools import lru_cache
import logging

from openai import AsyncOpenAI
from openai.types.chat import ChatCompletionMessageParam

from core.config import get_config


logger = logging.getLogger(__name__)


class LLMClient:
    """Manages OpenAI client instance and provides LLM operations."""
    
    def __init__(self):
        """Initialize the OpenAI client with configuration."""
        config = get_config()
        self.api_key = config.OPENAI_API_KEY
        self.model = config.OPENAI_MODEL
        self.default_temperature = config.OPENAI_TEMPERATURE
        
        if not self.api_key:
            raise ValueError("OpenAI API key not configured")
        
        self._client = AsyncOpenAI(api_key=self.api_key)
    
    async def generate(
        self,
        messages: List[ChatCompletionMessageParam],
        temperature: Optional[float] = None,
        max_tokens: Optional[int] = None,
        model: Optional[str] = None,
        **kwargs
    ) -> str:
        """
        Generate a completion using the OpenAI API.
        
        Args:
            messages: List of chat messages
            temperature: Override default temperature
            max_tokens: Maximum tokens in response
            model: Override default model
            **kwargs: Additional OpenAI API parameters
            
        Returns:
            Generated text response
            
        Raises:
            Exception: If API call fails
        """
        try:
            response = await self._client.chat.completions.create(
                model=model or self.model,
                messages=messages,
                temperature=temperature or self.default_temperature,
                max_tokens=max_tokens,
                **kwargs
            )
            
            content = response.choices[0].message.content
            if not content:
                raise ValueError("Empty response from OpenAI")
                
            return content.strip()
            
        except Exception as e:
            logger.error(f"OpenAI API error: {str(e)}")
            raise
    
    async def generate_with_system(
        self,
        system_prompt: str,
        user_prompt: str,
        **kwargs
    ) -> str:
        """
        Convenience method for simple system/user message generation.
        
        Args:
            system_prompt: System message content
            user_prompt: User message content
            **kwargs: Additional parameters for generate()
            
        Returns:
            Generated text response
        """
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
        return await self.generate(messages, **kwargs)
    
    async def test_connection(self) -> bool:
        """
        Test the OpenAI API connection.
        
        Returns:
            True if connection successful, False otherwise
        """
        try:
            response = await self.generate_with_system(
                system_prompt="You are a helpful assistant.",
                user_prompt="Say 'OK' if you can hear me.",
                max_tokens=5,
                temperature=0
            )
            return "OK" in response
        except Exception as e:
            logger.error(f"Connection test failed: {str(e)}")
            return False


@lru_cache()
def get_llm_client() -> LLMClient:
    """
    Get singleton LLM client instance.
    
    Returns:
        Configured LLMClient instance
    """
    return LLMClient()


async def quick_generate(
    prompt: str,
    max_tokens: Optional[int] = None,
    temperature: Optional[float] = None
) -> str:
    """
    Quick generation helper for simple prompts.
    
    Args:
        prompt: User prompt
        max_tokens: Maximum response tokens
        temperature: Generation temperature
        
    Returns:
        Generated response
    """
    client = get_llm_client()
    return await client.generate_with_system(
        system_prompt="You are a helpful assistant.",
        user_prompt=prompt,
        max_tokens=max_tokens,
        temperature=temperature
    )

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\content.py:
# services/llm/content.py
"""
Content generation logic using LLM.
Handles generating structured content descriptions from user queries.
"""

import logging
import re
from typing import Dict, List, Optional

from core.config import get_config
from services.llm.client import get_llm_client
from services.llm.prompts import get_prompt_manager

logger = logging.getLogger(__name__)


class ContentGenerator:
    """Generates structured content descriptions for diagrams."""
    
    def __init__(self):
        self.client = get_llm_client()
        self.prompt_manager = get_prompt_manager()
        self.config = get_config()
    
    async def generate(
        self,
        query: str,
        diagram_type: str,
        max_items: Optional[int] = None
    ) -> str:
        """
        Generate structured content description based on query and diagram type.
        
        Args:
            query: User's query text
            diagram_type: Type of diagram (affects content structure)
            max_items: Maximum number of items to generate
            
        Returns:
            Structured content description
        
        Raises:
            ValueError: If content generation fails or validation fails
        """
        # Get appropriate prompt
        prompt = self.prompt_manager.get_content_prompt(diagram_type)
        
        # Add max items constraint if specified
        if max_items:
            user_message = f"{query}\n\nPlease limit to {max_items} main points."
        else:
            user_message = query
        
        logger.debug(f"Generating {diagram_type} content for: {query[:50]}...")
        
        try:
            response = await self.client.generate_with_system(
                system_prompt=str(prompt),
                user_prompt=user_message,
                temperature=self.config.OPENAI_TEMPERATURE,
                max_tokens=self.config.OPENAI_MAX_TOKENS_CONTENT
            )
            
            if not response:
                raise ValueError("Empty content response from LLM")
            
            # Validate content structure
            if not self._validate_content(response, diagram_type):
                raise ValueError("Invalid content structure")
            
            return response
        
        except Exception as e:
            logger.error(f"Content generation failed: {str(e)}")
            raise
    
    
    def _validate_standard_content(self, content: str) -> bool:
        """
        Validate “standard” content:
         - Must include a "Main topic:" or "Topic:" line
         - Must have at least one fact, which can be:
           * A bullet (“- …”)
           * A numbered item (“1. …”)
           * A line containing the word “fact”
        """
        lines = [l.strip() for l in content.splitlines() if l.strip()]

        # 1) Topic line
        has_topic = any(
            re.match(r'^(main topic|topic)\s*[:\-]', line, re.IGNORECASE)
            for line in lines
        )
        if not has_topic:
            return False

        # 2) Fact count
        fact_count = 0
        for line in lines:
            if line.startswith('- '):
                fact_count += 1
            elif re.match(r'^\d+\.\s+', line):
                fact_count += 1
            elif 'fact' in line.lower():
                fact_count += 1

        return fact_count >= 1
    
    
    def _validate_comparison_content(self, content: str) -> bool:
        """Validate comparison content format."""
        content_lower = content.lower()
        if 'items:' not in content_lower:
            return False
        if 'similarity' not in content_lower:
            return False
        if 'unique' not in content_lower:
            return False
        return True


    def _validate_content(self, content: str, diagram_type: str) -> bool:
        """
        Dispatch to the appropriate validator based on diagram_type.
        """
        if diagram_type == "sequence_comparison":
            return self._validate_comparison_content(content)
        else:
            return self._validate_standard_content(content)
    

    def parse_content(self, content: str, diagram_type: str) -> Dict:
        """
        Parse structured content into a dictionary.
        
        Args:
            content: Structured content string
            diagram_type: Type of content
        
        Returns:
            Parsed content dictionary
        """
        if diagram_type == "sequence_comparison":
            return self._parse_comparison_content(content)
        else:
            return self._parse_standard_content(content)
    
    
    def _parse_standard_content(self, content: str) -> Dict:
        """Parse standard content format into {'topic': str, 'facts': List[str]}."""
        lines = content.strip().split('\n')
        result = {'topic': '', 'facts': []}
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            low = line.lower()
            if low.startswith('main topic:') or low.startswith('topic:'):
                result['topic'] = line.split(':', 1)[1].strip()
            elif any(low.startswith(f'fact {i}:') for i in range(1, 10)):
                fact_text = line.split(':', 1)[1].strip()
                result['facts'].append(fact_text)
            elif line.startswith('- '):
                result['facts'].append(line[2:].strip())
            elif re.match(r'^\d+\.\s+', line):
                result['facts'].append(re.sub(r'^\d+\.\s+', '', line).strip())
        
        return result
    
    
    def _parse_comparison_content(self, content: str) -> Dict:
        """Parse comparison content format into items, similarities, and unique_features."""
        lines = content.strip().split('\n')
        result = {'items': [], 'similarities': [], 'unique_features': {}}
        current_item = None
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            low = line.lower()
            if low.startswith('items:'):
                items = line.split(':', 1)[1].split(',')
                result['items'] = [item.strip() for item in items]
                for item in result['items']:
                    result['unique_features'][item] = []
            
            elif 'similarity' in low and ':' in line:
                sim = line.split(':', 1)[1].strip()
                result['similarities'].append(sim)
            
            elif 'unique' in low and ':' in line:
                parts = line.split(' unique ')
                if parts:
                    current_item = parts[0].strip()
                    feat = line.split(':', 1)[1].strip()
                    if current_item in result['unique_features']:
                        result['unique_features'][current_item].append(feat)
        
        return result


class ContentEnricher:
    """Enriches content with additional context and details."""
    
    def __init__(self):
        self.client = get_llm_client()
        self.config = get_config()
    
    async def enrich(
        self,
        content: str,
        query: str,
        enrichment_type: str = "examples"
    ) -> str:
        """
        Enrich content with additional information.
        
        Args:
            content: Base content to enrich
            query: Original user query
            enrichment_type: Type of enrichment ('examples', 'details', 'context')
        
        Returns:
            Enriched content
        """
        enrichment_prompts = {
            "examples": "Add 1-2 concrete examples to each point:",
            "details" : "Add more specific details to each point:",
            "context" : "Add relevant context and background to each point:"
        }
        prompt = enrichment_prompts.get(enrichment_type, enrichment_prompts["examples"])
        
        system_message = (
            f"You are enriching content for better understanding.\n"
            f"{prompt}\n"
            "Keep additions concise (10-15 words per addition).\n"
            "Maintain the original structure."
        )
        user_message = f"Original query: {query}\n\nContent to enrich:\n{content}"
        
        try:
            response = await self.client.generate_with_system(
                system_prompt=system_message,
                user_prompt=user_message,
                temperature=0.7,
                max_tokens=self.config.OPENAI_MAX_TOKENS_CONTENT
            )
            return response.strip()
        except Exception as e:
            logger.warning(f"Content enrichment failed: {str(e)}")
            return content


# Convenience functions

async def generate_content(
    query: str,
    diagram_type: str,
    enrich: bool = False
) -> str:
    """
    Generate content description for a query.
    """
    generator = ContentGenerator()
    content = await generator.generate(query, diagram_type)
    if enrich:
        enricher = ContentEnricher()
        content = await enricher.enrich(content, query)
    return content


async def parse_and_validate_content(
    content: str,
    diagram_type: str
) -> Dict:
    """
    Parse and validate content structure.
    """
    generator = ContentGenerator()
    if not generator._validate_content(content, diagram_type):
        raise ValueError("Content did not pass validation")
    return generator.parse_content(content, diagram_type)

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\content.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\diagram.py:
# services/llm/diagram.py
"""
Diagram generation logic using LLM.
Handles diagram type selection, content generation, and diagram creation.
"""

import logging
from typing import Literal

from core.config import get_config
from services.llm.client import get_llm_client
from services.llm.prompts import get_prompt_manager
from services.llm.content import generate_content


logger = logging.getLogger(__name__)

# Type definitions
DiagramType = Literal["flowchart", "radial_mindmap", "sequence_comparison"]


async def select_diagram_type(query: str) -> DiagramType:
    """
    Analyze the query and select the most appropriate diagram type.
    
    Args:
        query: User's query text
        
    Returns:
        Selected diagram type
        
    Raises:
        ValueError: If LLM returns invalid diagram type
    """
    client = get_llm_client()
    config = get_config()
    
    selector_prompt = """You are a diagram-type selector.

As a response to the below query, choose which output representation would be best suited:
- flowchart        : sequential steps, how-to, decision logic
- radial_mindmap   : concept overviews, definitions, characteristics
- sequence_comparison: comparing two or more items, highlighting similarities and unique features

Respond with ONLY one word: "flowchart", "radial_mindmap", or "sequence_comparison"."""
    
    try:
        response = await client.generate_with_system(
            system_prompt=selector_prompt,
            user_prompt=query,
            temperature=0.3,
            max_tokens=config.OPENAI_MAX_TOKENS_SELECTOR
        )
        
        # Validate response
        valid_types = {"flowchart", "radial_mindmap", "sequence_comparison"}
        response_clean = response.strip().lower()
        
        if response_clean not in valid_types:
            logger.warning(f"Invalid diagram type from LLM: {response}")
            # Default to radial_mindmap for general queries
            return "radial_mindmap"
        
        return response_clean  # type: ignore
        
    except Exception as e:
        logger.error(f"Error selecting diagram type: {str(e)}")
        # Default fallback
        return "radial_mindmap"





async def generate_diagram_code(
    content_description: str,
    original_query: str,
    diagram_type: DiagramType
) -> str:
    """
    Generate Mermaid diagram code from content description.
    
    Args:
        content_description: Structured content to visualize
        original_query: Original user query for context
        diagram_type: Type of diagram to generate
        
    Returns:
        Raw Mermaid diagram code
        
    Raises:
        Exception: If diagram generation fails
    """
    client = get_llm_client()
    config = get_config()
    prompt_manager = get_prompt_manager()
    
    # Get appropriate prompt for diagram type
    diagram_prompt = prompt_manager.get_diagram_prompt(diagram_type)
    
    # Build user message based on diagram type
    if diagram_type == "flowchart":
        user_message = (
            f"Create a Mermaid flowchart that answers this query:\n\n"
            f"{original_query}\n\n"
            f"Content details:\n{content_description}"
        )
    elif diagram_type == "sequence_comparison":
        user_message = (
            f"Create a Mermaid sequence diagram for this comparison query:\n\n"
            f"{original_query}\n\n"
            f"Content details:\n{content_description}"
        )
    else:  # radial_mindmap
        user_message = (
            f"Create a radial Mermaid mind-map from this content:\n"
            f"{content_description}"
        )
    
    logger.debug(f"Generating {diagram_type} diagram code")
    
    response = await client.generate_with_system(
        system_prompt=str(diagram_prompt),
        user_prompt=user_message,
        temperature=config.OPENAI_TEMPERATURE,
        max_tokens=config.OPENAI_MAX_TOKENS_DIAGRAM
    )
    
    if not response:
        raise ValueError("Empty diagram response from LLM")
    
    return response


async def generate_deep_dive_response(
    selected_text: str,
    question: str,
    original_query: str = ""
) -> str:
    """
    Generate contextual information about selected diagram content.
    
    Args:
        selected_text: Text selected from the diagram
        question: User's question about the selection
        original_query: Original query that generated the diagram
        
    Returns:
        Detailed explanation or answer
        
    Raises:
        Exception: If generation fails
    """
    client = get_llm_client()
    config = get_config()
    prompt_manager = get_prompt_manager()
    
    # Get deep dive prompt
    deep_dive_prompt = prompt_manager.get("deep_dive")
    
    # Build context-aware user message
    user_message = f'Selected text from diagram: "{selected_text}"\n\n'
    user_message += f'User\'s question: {question}'
    
    if original_query:
        user_message += (
            f"\n\nOriginal query that generated the diagram: {original_query}"
        )
    
    logger.info(f"Generating deep dive response for: {question[:50]}...")
    
    response = await client.generate_with_system(
        system_prompt=str(deep_dive_prompt),
        user_prompt=user_message,
        temperature=config.OPENAI_TEMPERATURE,
        max_tokens=config.OPENAI_MAX_TOKENS_CONTENT
    )
    
    if not response:
        raise ValueError("Empty deep dive response from LLM")
    
    return response


# Convenience function for backward compatibility
async def generate_diagram(query: str) -> str:
    """
    Generate a complete diagram from a query.
    
    This is a convenience function that runs the full generation pipeline.
    
    Args:
        query: User's query text
        
    Returns:
        Raw Mermaid diagram code
    """
    diagram_type = await select_diagram_type(query)
    content = await generate_content(query, diagram_type)
    return await generate_diagram_code(content, query, diagram_type)
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\diagram.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\prompts.py:
# services/llm/prompts.py
"""
Prompt template management for LLM operations.
Handles loading, caching, and formatting of prompt templates.
"""

from pathlib import Path
from typing import Dict, Optional
from functools import lru_cache
import logging

from core.config import get_config


logger = logging.getLogger(__name__)


class PromptTemplate:
    """Represents a loaded prompt template with metadata."""
    
    def __init__(self, name: str, content: str, path: Path):
        self.name = name
        self.content = content
        self.path = path
        self._validate()
    
    def _validate(self):
        """Validate prompt content."""
        if not self.content.strip():
            raise ValueError(f"Prompt template '{self.name}' is empty")
    
    def format(self, **kwargs) -> str:
        """
        Format the prompt with provided variables.
        
        Args:
            **kwargs: Variables to substitute in the template
            
        Returns:
            Formatted prompt string
        """
        try:
            return self.content.format(**kwargs)
        except KeyError as e:
            logger.error(f"Missing variable in prompt '{self.name}': {e}")
            raise ValueError(f"Missing required variable: {e}")
    
    def __str__(self) -> str:
        return self.content


class PromptManager:
    """Manages loading and caching of prompt templates."""
    
    # Prompt filename mapping
    PROMPT_FILES = {
        # Content generation
        "content": "content.txt",
        "content_sequence": "content_sequence_comparison.txt",
        
        # Diagram generation
        "diagram_radial": "diagram.txt",
        "diagram_flowchart": "diagram_flowchart.txt",
        "diagram_sequence": "diagram_sequence_comparison.txt",
        
        # Other
        "deep_dive": "deep_dive.txt",
    }
    
    def __init__(self):
        self.config = get_config()
        self._cache: Dict[str, PromptTemplate] = {}
        self._load_all_prompts()
    
    def _load_all_prompts(self):
        """Pre-load all known prompts for validation."""
        for key, filename in self.PROMPT_FILES.items():
            try:
                self._load_prompt(key, filename)
            except Exception as e:
                logger.warning(f"Failed to load prompt '{key}': {e}")
    
    def _load_prompt(self, key: str, filename: str) -> PromptTemplate:
        """Load a single prompt file."""
        path = self.config.get_prompt_path(filename)
        content = path.read_text(encoding="utf-8")
        
        template = PromptTemplate(
            name=key,
            content=content,
            path=path
        )
        
        self._cache[key] = template
        logger.debug(f"Loaded prompt '{key}' from {filename}")
        return template
    
    def get(self, key: str) -> PromptTemplate:
        """
        Get a prompt template by key.
        
        Args:
            key: Prompt identifier
            
        Returns:
            PromptTemplate instance
            
        Raises:
            KeyError: If prompt not found
        """
        if key not in self._cache:
            if key not in self.PROMPT_FILES:
                raise KeyError(f"Unknown prompt key: '{key}'")
            
            # Try to load if not in cache
            self._load_prompt(key, self.PROMPT_FILES[key])
        
        return self._cache[key]
    
    def get_content_prompt(self, diagram_type: str) -> PromptTemplate:
        """
        Get the appropriate content generation prompt for a diagram type.
        
        Args:
            diagram_type: Type of diagram (flowchart, radial_mindmap, sequence_comparison)
            
        Returns:
            Appropriate content prompt template
        """
        if diagram_type == "sequence_comparison":
            return self.get("content_sequence")
        return self.get("content")
    
    def get_diagram_prompt(self, diagram_type: str) -> PromptTemplate:
        """
        Get the appropriate diagram generation prompt for a diagram type.
        
        Args:
            diagram_type: Type of diagram
            
        Returns:
            Appropriate diagram prompt template
        """
        prompt_map = {
            "flowchart": "diagram_flowchart",
            "radial_mindmap": "diagram_radial",
            "sequence_comparison": "diagram_sequence",
        }
        
        key = prompt_map.get(diagram_type, "diagram_radial")
        return self.get(key)
    
    def reload(self, key: Optional[str] = None):
        """
        Reload prompt(s) from disk.
        
        Args:
            key: Specific prompt to reload, or None for all
        """
        if key:
            if key in self.PROMPT_FILES:
                self._load_prompt(key, self.PROMPT_FILES[key])
                logger.info(f"Reloaded prompt '{key}'")
        else:
            self._cache.clear()
            self._load_all_prompts()
            logger.info("Reloaded all prompts")


@lru_cache()
def get_prompt_manager() -> PromptManager:
    """Get singleton PromptManager instance."""
    return PromptManager()


def load_prompt(key: str) -> str:
    """
    Convenience function to load a prompt by key.
    
    Args:
        key: Prompt identifier
        
    Returns:
        Prompt content string
    """
    manager = get_prompt_manager()
    return str(manager.get(key))


def get_diagram_type_prompts(diagram_type: str) -> tuple[str, str]:
    """
    Get both content and diagram prompts for a diagram type.
    
    Args:
        diagram_type: Type of diagram
        
    Returns:
        Tuple of (content_prompt, diagram_prompt)
    """
    manager = get_prompt_manager()
    content = str(manager.get_content_prompt(diagram_type))
    diagram = str(manager.get_diagram_prompt(diagram_type))
    return content, diagram

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\prompts.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-desktop\services\llm\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\.env.example:
OPENAI_API_KEY=your_api_key_here
PORT=3000
RENDER_MODE=html

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\.env.example ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\main.py:
"""Entry point for the pitext_travel micro-service.
Minimal setup that delegates route registration to routes module.
"""
import os
import secrets
from flask import Flask
from pitext_travel.routes.travel import create_travel_blueprint
from pitext_travel.api.chat import bp_chat
from flask_socketio import SocketIO
from pitext_travel.routes.websocket import TravelVoiceNS

# Get the absolute path to the directory where this file is located
base_dir = os.path.abspath(os.path.dirname(__file__))

# Create the main Flask app
app = Flask(
    __name__,
    static_url_path="/travel/static",
    static_folder=os.path.join(base_dir, 'static')
)

# Generate secret key dynamically
app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY', secrets.token_hex(32))
app.config['SESSION_COOKIE_NAME'] = 'pitext_travel_session'
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['PERMANENT_SESSION_LIFETIME'] = 3600  # 1 hour

# Register blueprints
app.register_blueprint(create_travel_blueprint(base_dir))
app.register_blueprint(bp_chat)

# Create SocketIO wrapper
socketio = SocketIO(
    app,
    async_mode="asgi",          # gives you socketio.asgi_app
    cors_allowed_origins="*",
    logger=True,
    engineio_logger=False
)


# Register your namespace
socketio.on_namespace(TravelVoiceNS('/travel/voice'))

# Export the ASGI app
asgi_app = socketio.asgi_app

# Optional: local dev runner
if __name__ == "__main__":
    socketio.run(app, port=int(os.getenv("PORT", 3000)), debug=True)
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\main.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\render.yaml:
services:
  - type: web
    name: PiText
    runtime: python
    buildCommand: |
      pip install -r requirements.txt &&
      playwright install chromium --with-deps
    startCommand: uvicorn main:app --host 0.0.0.0 --port $PORT
    envVars:
      - key: PYTHON_VERSION
        value: 3.11.0
      - key: OPENAI_API_KEY
        sync: false
      - key: PORT
        value: "10000"
      - key: RENDER_MODE
        value: html

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\render.yaml ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\requirements.txt:
Flask==2.3.2
requests==2.31.0
asgiref>=3.0.0
openai==1.12.0
python-dotenv==1.0.0
flask-cors==4.0.0

# Latest stable versions for Socket.IO
python-engineio==4.9.1
flask-socketio>=6.1 
python-socketio>=5.11
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\runtime.txt:
python-3.11.0

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\runtime.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\__init__.py:
# pitext-mobile/__init__.py

"""
PiText Mobile module initializer.
Exports the FastAPI application instance.
"""
from .main import app

__all__ = ["app"]
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\middleware.py:
# api/middleware.py
"""
Middleware configuration for PiText Desktop.
Handles CORS, logging, error handling, and request/response processing.
"""

import time
import logging
from typing import Callable
from uuid import uuid4

from fastapi import FastAPI, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from core.config import get_config
from api.models import create_error_response


logger = logging.getLogger(__name__)


def setup_cors(app: FastAPI) -> None:
    """
    Configure CORS middleware for the application.
    
    Args:
        app: FastAPI application instance
    """
    config = get_config()
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=config.CORS_ORIGINS,
        allow_credentials=config.CORS_ALLOW_CREDENTIALS,
        allow_methods=config.CORS_ALLOW_METHODS,
        allow_headers=config.CORS_ALLOW_HEADERS,
    )
    
    logger.info(f"CORS configured with origins: {config.CORS_ORIGINS}")


async def log_requests(request: Request, call_next: Callable) -> Response:
    """
    Middleware to log all incoming requests and their processing time.
    
    Args:
        request: Incoming request
        call_next: Next middleware/handler in chain
        
    Returns:
        Response from the handler
    """
    # Generate request ID for tracking
    request_id = str(uuid4())[:8]
    
    # Log request start
    start_time = time.time()
    logger.info(
        f"[{request_id}] {request.method} {request.url.path} "
        f"from {request.client.host if request.client else 'unknown'}"
    )
    
    # Process request
    response = await call_next(request)
    
    # Calculate processing time
    process_time = time.time() - start_time
    
    # Log request completion
    logger.info(
        f"[{request_id}] Completed in {process_time:.3f}s "
        f"with status {response.status_code}"
    )
    
    # Add custom headers
    response.headers["X-Request-ID"] = request_id
    response.headers["X-Process-Time"] = f"{process_time:.3f}"
    
    return response


async def handle_errors(request: Request, call_next: Callable) -> Response:
    """
    Global error handling middleware.
    
    Catches unhandled exceptions and returns consistent error responses.
    
    Args:
        request: Incoming request
        call_next: Next middleware/handler in chain
        
    Returns:
        Response from the handler or error response
    """
    try:
        return await call_next(request)
    except Exception as e:
        logger.error(
            f"Unhandled exception for {request.method} {request.url.path}: {str(e)}",
            exc_info=True
        )
        
        # Don't expose internal errors in production
        config = get_config()
        if config.is_production():
            error_detail = "An internal error occurred"
        else:
            error_detail = str(e)
        
        return JSONResponse(
            status_code=500,
            content=create_error_response(
                detail=error_detail,
                error_type="internal_error"
            )
        )


async def add_security_headers(request: Request, call_next: Callable) -> Response:
    """
    Add security headers to all responses.
    
    Args:
        request: Incoming request
        call_next: Next middleware/handler in chain
        
    Returns:
        Response with security headers
    """
    response = await call_next(request)
    
    # Add security headers
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    
    # Add cache headers for static assets
    if request.url.path.startswith(f"{get_config().API_PREFIX}/assets"):
        response.headers["Cache-Control"] = "public, max-age=31536000"  # 1 year
    elif request.url.path.endswith((".js", ".css")):
        response.headers["Cache-Control"] = "public, max-age=86400"  # 1 day
    
    return response


def setup_middleware(app: FastAPI) -> None:
    """
    Configure all middleware for the application.
    
    Order matters! Middleware is executed in reverse order for responses.
    
    Args:
        app: FastAPI application instance
    """
    # CORS should be first
    setup_cors(app)
    
    # Add custom middleware (order matters for response processing)
    app.middleware("http")(add_security_headers)
    app.middleware("http")(handle_errors)
    app.middleware("http")(log_requests)
    
    logger.info("All middleware configured")


def setup_exception_handlers(app: FastAPI) -> None:
    """
    Configure custom exception handlers.
    
    Args:
        app: FastAPI application instance
    """
    @app.exception_handler(ValueError)
    async def value_error_handler(request: Request, exc: ValueError):
        """Handle ValueError exceptions."""
        return JSONResponse(
            status_code=400,
            content=create_error_response(
                detail=str(exc),
                error_type="validation_error"
            )
        )
    
    @app.exception_handler(404)
    async def not_found_handler(request: Request, exc):
        """Handle 404 errors."""
        return JSONResponse(
            status_code=404,
            content=create_error_response(
                detail=f"Path {request.url.path} not found",
                error_type="not_found"
            )
        )
    
    logger.info("Exception handlers configured")

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\middleware.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\models.py:
# api/models.py
"""
Pydantic models for API requests and responses.
Defines the contract between frontend and backend.
"""

from typing import Optional, Literal, Dict, Any
from pydantic import BaseModel, Field, validator


# ============================================================================
# Request Models
# ============================================================================

class DescribeRequest(BaseModel):
    """Request to generate a diagram from a query."""
    query: str = Field(..., min_length=1, max_length=1000)
    
    @validator('query')
    def validate_query(cls, v):
        """Ensure query is not just whitespace."""
        if not v.strip():
            raise ValueError("Query cannot be empty or just whitespace")
        return v.strip()


class DeepDiveRequest(BaseModel):
    """Request for contextual information about selected diagram content."""
    selected_text: str = Field(..., min_length=1, max_length=5000)
    question: str = Field(..., min_length=1, max_length=500)
    original_query: str = Field(default="", max_length=1000)
    
    @validator('selected_text', 'question')
    def validate_not_empty(cls, v):
        """Ensure text fields are not just whitespace."""
        if not v.strip():
            raise ValueError("Field cannot be empty or just whitespace")
        return v.strip()


# ============================================================================
# Response Models
# ============================================================================

class DiagramResponse(BaseModel):
    """Response containing the generated diagram and metadata."""
    success: bool = True
    query: str
    description: str = Field(..., description="Text description of the content")
    diagram_type: Literal["flowchart", "radial_mindmap", "sequence_comparison"]
    diagram: str = Field(..., description="Mermaid diagram code")
    render_type: Literal["html", "image"] = "html"
    rendered_content: Optional[str] = Field(
        None, 
        description="Rendered diagram (HTML or base64 image)"
    )
    
    class Config:
        schema_extra = {
            "example": {
                "success": True,
                "query": "How do rainbows form?",
                "description": "Rainbow formation process...",
                "diagram_type": "flowchart",
                "diagram": "flowchart TD\n    A[Start] ==> B[End]",
                "render_type": "html",
                "rendered_content": "<div>...</div>"
            }
        }


class DeepDiveResponse(BaseModel):
    """Response containing contextual information about selected content."""
    success: bool = True
    response: str = Field(..., description="Detailed explanation")
    
    class Config:
        schema_extra = {
            "example": {
                "success": True,
                "response": "The selected concept refers to..."
            }
        }


class ErrorResponse(BaseModel):
    """Standard error response format."""
    success: bool = False
    detail: str = Field(..., description="Error message")
    error_type: Optional[str] = Field(None, description="Error classification")
    
    class Config:
        schema_extra = {
            "example": {
                "success": False,
                "detail": "Query is required",
                "error_type": "validation_error"
            }
        }


class HealthResponse(BaseModel):
    """Health check response."""
    message: str = "LLM Diagram Service is running!"
    status: Literal["healthy", "degraded", "unhealthy"] = "healthy"
    version: Optional[str] = Field(None, description="Application version")
    
    class Config:
        schema_extra = {
            "example": {
                "message": "LLM Diagram Service is running!",
                "status": "healthy",
                "version": "1.0.0"
            }
        }


# ============================================================================
# Internal Models (used between services)
# ============================================================================

class DiagramGenerationResult(BaseModel):
    """Internal model for diagram generation results."""
    diagram_type: Literal["flowchart", "radial_mindmap", "sequence_comparison"]
    content_description: str
    mermaid_code: str
    raw_llm_output: Optional[str] = Field(
        None, 
        description="Raw LLM output for debugging"
    )


class RenderResult(BaseModel):
    """Internal model for rendering results."""
    render_type: Literal["html", "image"]
    rendered_content: str


# ============================================================================
# Utility Functions
# ============================================================================

def create_error_response(
    detail: str, 
    error_type: Optional[str] = None
) -> Dict[str, Any]:
    """Create a standardized error response dictionary."""
    return ErrorResponse(
        detail=detail,
        error_type=error_type
    ).dict()


def create_success_response(
    data: BaseModel
) -> Dict[str, Any]:
    """Ensure response includes success=True."""
    response = data.dict()
    response["success"] = True
    return response

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\models.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\routes.py:
# api/routes.py
"""
API route definitions for PiText Desktop.
Handles all /desktop/* endpoints.
"""

from pathlib import Path
import logging

from fastapi import APIRouter, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

from api.models import (
    DescribeRequest,
    DeepDiveRequest,
    DiagramResponse,
    DeepDiveResponse,
    HealthResponse,
    create_error_response,
)
from core.config import get_config
from core.pipeline import process_pipeline
from core.sanitizer import sanitize_mermaid                 # ← NEW
from services.llm.diagram import generate_deep_dive_response

logger = logging.getLogger(__name__)
config = get_config()

# ---------------------------------------------------------------------------
# Router
# ---------------------------------------------------------------------------

router = APIRouter(prefix=config.API_PREFIX)

# ---------------------------------------------------------------------------
# API End‑points
# ---------------------------------------------------------------------------


@router.post("/describe", response_model=DiagramResponse)
async def describe(request: DescribeRequest):
    """
    Generate a diagram from a text query.

    Pipeline:
        1. Analyse query, pick diagram type
        2. Generate content description
        3. Produce Mermaid code
        4. Sanitise and return
    """
    try:
        logger.info("Processing describe request: %s...", request.query[:50])

        result = await process_pipeline(request.query)

        # Always sanitise the Mermaid before shipping it to the client
        diagram_code = result.get("diagram", "")
        diagram_code = sanitize_mermaid(diagram_code)
        result["diagram"] = diagram_code

        # Log once for debugging (guarded to avoid huge logs in prod)
        logger.debug("Sanitised Mermaid chart:\n%s", diagram_code)

        return DiagramResponse(query=request.query, **result)

    except ValueError as exc:
        logger.error("Validation error: %s", exc)
        raise HTTPException(
            status_code=400,
            detail=create_error_response(str(exc), "validation_error"),
        ) from exc
    except Exception as exc:  # noqa: BLE001
        logger.error("Unexpected error in describe: %s", exc, exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=create_error_response(
                "An error occurred while generating the diagram",
                "internal_error",
            ),
        ) from exc


@router.post("/deep-dive", response_model=DeepDiveResponse)
async def deep_dive(request: DeepDiveRequest):
    """
    Generate an explanatory answer about selected diagram content.
    """
    try:
        logger.info(
            "Deep‑dive request – Text: %s..., Question: %s...",
            request.selected_text[:30],
            request.question[:50],
        )

        response = await generate_deep_dive_response(
            selected_text=request.selected_text,
            question=request.question,
            original_query=request.original_query,
        )

        return DeepDiveResponse(response=response)

    except ValueError as exc:
        logger.error("Validation error: %s", exc)
        raise HTTPException(
            status_code=400,
            detail=create_error_response(str(exc), "validation_error"),
        ) from exc
    except Exception as exc:  # noqa: BLE001
        logger.error("Unexpected error in deep‑dive: %s", exc, exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=create_error_response(
                "An error occurred while generating the response",
                "internal_error",
            ),
        ) from exc


@router.get("/health", response_model=HealthResponse)
async def health_check():
    """
    Health‑check end‑point.
    """
    return HealthResponse(status="healthy", version="1.0.0")


# ---------------------------------------------------------------------------
# Static file serving
# ---------------------------------------------------------------------------


def setup_static_routes(app):
    """
    Register static‑file mounts for the desktop front‑end.
    """
    app.mount(
        f"{config.API_PREFIX}/assets",
        StaticFiles(directory=str(config.PUBLIC_DIR / "assets")),
        name="assets",
    )
    app.mount(
        f"{config.API_PREFIX}/js",
        StaticFiles(directory=str(config.PUBLIC_DIR / "js")),
        name="js",
    )
    app.mount(
        f"{config.API_PREFIX}/css",
        StaticFiles(directory=str(config.PUBLIC_DIR / "css")),
        name="css",
    )

    @app.get(config.API_PREFIX)
    @app.get(f"{config.API_PREFIX}/")
    async def desktop_root():  # noqa: D401, ANN001
        """Serve the main desktop application."""
        index_path = config.PUBLIC_DIR / "index.html"
        if not index_path.exists():
            logger.error("index.html not found at %s", index_path)
            raise HTTPException(
                status_code=500, detail="Application files not found"
            )
        return FileResponse(index_path)

    @app.get(f"{config.API_PREFIX}/{{path:path}}")
    async def catch_all(path: str):  # noqa: D401
        """
        Client‑side routing fall‑back.
        """
        file_path = config.PUBLIC_DIR / path
        if file_path.exists() and file_path.is_file():
            return FileResponse(file_path)

        index_path = config.PUBLIC_DIR / "index.html"
        if index_path.exists():
            return FileResponse(index_path)

        raise HTTPException(status_code=404, detail="Not found")

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\routes.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\api\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\config.py:
# core/config.py
"""
Configuration management for PiText Desktop.
Centralizes all environment variables and configuration settings.
"""

import os
from pathlib import Path
from typing import Optional, Literal
from functools import lru_cache
from dotenv import load_dotenv

# Load environment variables
load_dotenv()


class Config:
    """Application configuration singleton."""
    
    # Paths
    BASE_DIR: Path = Path(__file__).parent.parent
    PROMPTS_DIR: Path = BASE_DIR / "prompts"
    PUBLIC_DIR: Path = BASE_DIR / "public"
    
    # API Settings
    API_PREFIX: str = "/desktop"
    HOST: str = "0.0.0.0"
    PORT: int = int(os.getenv("PORT", 3000))
    
    # OpenAI Settings
    OPENAI_API_KEY: Optional[str] = os.getenv("OPENAI_API_KEY")
    OPENAI_MODEL: str = "gpt-4.1"
    OPENAI_TEMPERATURE: float = 0.7
    OPENAI_MAX_TOKENS_CONTENT: int = 500
    OPENAI_MAX_TOKENS_DIAGRAM: int = 1500
    OPENAI_MAX_TOKENS_SELECTOR: int = 5
    
    # Rendering Settings
    RENDER_MODE: Literal["html", "image"] = os.getenv("RENDER_MODE", "html").lower()  # type: ignore
    
    # Playwright Settings (for image rendering)
    PLAYWRIGHT_TIMEOUT: int = 10000  # ms
    PLAYWRIGHT_ARGS: list[str] = ['--no-sandbox', '--disable-setuid-sandbox']
    
    # CORS Settings
    CORS_ORIGINS: list[str] = ["*"]
    CORS_ALLOW_CREDENTIALS: bool = True
    CORS_ALLOW_METHODS: list[str] = ["*"]
    CORS_ALLOW_HEADERS: list[str] = ["*"]
    
    # Logging
    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO")
    LOG_FORMAT: str = "%(asctime)s [%(levelname)s] %(message)s"
    
    @classmethod
    def validate(cls) -> None:
        """Validate required configuration."""
        if not cls.OPENAI_API_KEY:
            raise ValueError(
                "OPENAI_API_KEY environment variable is required. "
                "Please set it in your .env file or environment."
            )
        
        if cls.RENDER_MODE not in ("html", "image"):
            raise ValueError(
                f"Invalid RENDER_MODE: {cls.RENDER_MODE}. "
                "Must be either 'html' or 'image'."
            )
        
        if not cls.PROMPTS_DIR.exists():
            raise ValueError(f"Prompts directory not found: {cls.PROMPTS_DIR}")
        
        if not cls.PUBLIC_DIR.exists():
            raise ValueError(f"Public directory not found: {cls.PUBLIC_DIR}")
    
    @classmethod
    def get_prompt_path(cls, filename: str) -> Path:
        """Get the full path to a prompt file."""
        path = cls.PROMPTS_DIR / filename
        if not path.exists():
            raise FileNotFoundError(f"Prompt file not found: {filename}")
        return path
    
    @classmethod
    def is_development(cls) -> bool:
        """Check if running in development mode."""
        return os.getenv("ENV", "development").lower() == "development"
    
    @classmethod
    def is_production(cls) -> bool:
        """Check if running in production mode."""
        return os.getenv("ENV", "development").lower() == "production"


@lru_cache()
def get_config() -> type[Config]:
    """Get validated configuration singleton."""
    Config.validate()
    return Config


# Validate configuration on module import
try:
    Config.validate()
except ValueError as e:
    # Only raise in production, warn in development
    if Config.is_production():
        raise
    else:
        import warnings
        warnings.warn(f"Configuration warning: {e}")

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\config.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\pipeline.py:
# core/pipeline.py
"""
Pipeline orchestration for diagram generation.
Coordinates the flow from query to final diagram.
"""

import logging
from typing import Dict, Any

from core.sanitizer import sanitize_mermaid
from services.llm.diagram import (
    select_diagram_type,
    generate_content,
    generate_diagram_code
)
from services.renderer import render_diagram
from api.models import DiagramGenerationResult, RenderResult


logger = logging.getLogger(__name__)


class DiagramPipeline:
    """Orchestrates the diagram generation pipeline."""
    
    def __init__(self):
        """Initialize the pipeline."""
        self.stages = [
            ("Selecting diagram type", self._select_type),
            ("Generating content", self._generate_content),
            ("Creating diagram", self._create_diagram),
            ("Sanitizing output", self._sanitize_diagram),
            ("Rendering diagram", self._render_diagram)
        ]
    
    async def process(self, query: str) -> Dict[str, Any]:
        """
        Process a query through the complete pipeline.
        
        Args:
            query: User's query text
            
        Returns:
            Dict containing all pipeline results
            
        Raises:
            Exception: If any pipeline stage fails
        """
        logger.info(f"Starting pipeline for query: {query[:50]}...")
        
        # Initialize pipeline context
        context = {
            "query": query,
            "diagram_type": None,
            "content_description": None,
            "raw_diagram": None,
            "sanitized_diagram": None,
            "render_result": None
        }
        
        # Execute pipeline stages
        for stage_name, stage_func in self.stages:
            logger.info(f"Stage: {stage_name}")
            try:
                await stage_func(context)
            except Exception as e:
                logger.error(f"Pipeline failed at stage '{stage_name}': {str(e)}")
                raise
        
        # Build final result
        return self._build_result(context)
    
    async def _select_type(self, context: Dict[str, Any]) -> None:
        """Stage 1: Select the appropriate diagram type."""
        context["diagram_type"] = await select_diagram_type(context["query"])
        logger.info(f"Selected diagram type: {context['diagram_type']}")
    
    async def _generate_content(self, context: Dict[str, Any]) -> None:
        """Stage 2: Generate content description."""
        context["content_description"] = await generate_content(
            query=context["query"],
            diagram_type=context["diagram_type"]
        )
        logger.debug("🟡 RAW Mermaid code ↓\n%s", context["raw_diagram"])
    
    async def _create_diagram(self, context: Dict[str, Any]) -> None:
        """Stage 3: Generate Mermaid diagram code."""
        context["raw_diagram"] = await generate_diagram_code(
            content_description=context["content_description"],
            original_query=context["query"],
            diagram_type=context["diagram_type"]
        )
        logger.debug("🟢 SANITISED Mermaid code ↓\n%s", context["sanitized_diagram"])

        if logger.isEnabledFor(logging.DEBUG) and \
           context["raw_diagram"] != context["sanitized_diagram"]:
            logger.debug("Diagram was modified during sanitisation")

    
    async def _sanitize_diagram(self, context: Dict[str, Any]) -> None:
        """Stage 4: Sanitize the Mermaid code."""
        context["sanitized_diagram"] = sanitize_mermaid(context["raw_diagram"])
        
        if logger.isEnabledFor(logging.DEBUG):
            logger.debug("Sanitization complete")
            if context["raw_diagram"] != context["sanitized_diagram"]:
                logger.debug("Diagram was modified during sanitization")
    
    async def _render_diagram(self, context: Dict[str, Any]) -> None:
        """Stage 5: Render the diagram (HTML or image)."""
        context["render_result"] = await render_diagram(
            context["sanitized_diagram"]
        )
        logger.info(f"Rendered as: {context['render_result'].render_type}")
    
    def _build_result(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Build the final result dictionary."""
        render_result = context["render_result"]
        
        return {
            "description": context["content_description"],
            "diagram_type": context["diagram_type"],
            "diagram": context["sanitized_diagram"],
            "render_type": render_result.render_type,
            "rendered_content": render_result.rendered_content
        }


# Create a singleton pipeline instance
_pipeline = DiagramPipeline()


async def process_pipeline(query: str) -> Dict[str, Any]:
    """
    Process a query through the diagram generation pipeline.
    
    This is the main entry point for diagram generation.
    
    Args:
        query: User's query text
        
    Returns:
        Dict containing:
        - description: Text description of the content
        - diagram_type: Selected diagram type
        - diagram: Sanitized Mermaid code
        - render_type: "html" or "image"
        - rendered_content: Rendered output
        
    Raises:
        ValueError: If query is invalid
        Exception: If pipeline processing fails
    """
    if not query or not query.strip():
        raise ValueError("Query cannot be empty")
    
    return await _pipeline.process(query.strip())

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\pipeline.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\sanitizer.py:
# core/sanitizer.py
"""
Mermaid diagram sanitisation utilities.
Cleans and fixes common issues in LLM‑generated Mermaid code so that it always
parses in the browser.
"""

from __future__ import annotations

import html
import re
from typing import List, Tuple


class MermaidSanitizer:
    """Static helpers that convert raw LLM output into valid Mermaid."""

    # ------------------------------------------------------------------
    # mapping tables ----------------------------------------------------
    # ------------------------------------------------------------------
    #   We express the *source* glyphs with explicit Unicode escape
    #   sequences ("\uXXXX") so that editors and linters running on
    #   Windows treat the file as pure ASCII and do not warn about
    #   ambiguous dash / quote characters.
    # ------------------------------------------------------------------
    UNICODE_REPLACEMENTS: List[Tuple[str, str]] = [
        ("\u2013", "-"),   # en dash –
        ("\u2014", "-"),   # em dash —
        ("\u201C", '"'),  # left  double quote "
        ("\u201D", '"'),  # right double quote "
        ("\u2018", "'"),   # left  single quote '
        ("\u2019", "'"),   # right single quote '
        ("\u00A0", " "),   # non‑breaking space
        ("\u200B", ""),    # zero‑width space
    ]

    HTML_ENTITIES: List[Tuple[str, str]] = [
        ("&amp;", "&"),
        ("&lt;", "<"),
        ("&gt;", ">"),
        ("&quot;", '"'),
        ("&#39;", "'"),
    ]

    # ------------------------------------------------------------------
    # public API --------------------------------------------------------
    # ------------------------------------------------------------------
    @classmethod
    def sanitize(cls, snippet: str) -> str:
        """Full sanitisation pipeline."""
        text = snippet.strip()
        text = cls._decode_html_entities(text)
        text = cls._remove_markdown_fences(text)
        text = cls._normalise_unicode(text)
        text = cls._fix_line_breaks(text)

        # line‑by‑line fixes -------------------------------------------
        fixed_lines: List[str] = [cls._process_line(line) for line in text.splitlines()]
        text = "\n".join(fixed_lines)

        # final tidy‑up -----------------------------------------------
        text = cls._final_cleanup(text)
        return text

    # ------------------------------------------------------------------
    # individual steps --------------------------------------------------
    # ------------------------------------------------------------------
    @staticmethod
    def _decode_html_entities(text: str) -> str:
        """Decode once, then again to catch double‑encoding."""
        return html.unescape(html.unescape(text))

    @staticmethod
    def _remove_markdown_fences(text: str) -> str:
        """Drop ```mermaid fences that sometimes wrap the snippet."""
        text = re.sub(r"^```(?:mermaid)?\s*", "", text, flags=re.MULTILINE | re.IGNORECASE)
        return re.sub(r"```$", "", text, flags=re.MULTILINE)

    @classmethod
    def _normalise_unicode(cls, text: str) -> str:
        """Replace smart punctuation and non‑printables with ASCII."""
        for bad, good in cls.UNICODE_REPLACEMENTS:
            text = text.replace(bad, good)
        return text

    @staticmethod
    def _fix_line_breaks(text: str) -> str:
        """Normalise all forms of <br/> to <br>."""
        return re.sub(r"<\s*br\s*/?\s*>", "<br>", text, flags=re.IGNORECASE)

    # ------------------------------------------------------------------
    # per‑line processing ----------------------------------------------
    # ------------------------------------------------------------------
    @classmethod
    def _process_line(cls, line: str) -> str:
        stripped = line.strip()

        # 1. Subgraph declarations
        if stripped.lower().startswith("subgraph"):
            # Always fix subgraph syntax to ensure it's well-formed
            fixed = cls._fix_subgraph(stripped)
            # Log the transformation for debugging
            if stripped != fixed:
                import logging
                logging.debug(f"Fixed subgraph: '{stripped}' -> '{fixed}'")
            return fixed

        # 2. Parentheses nodes  A("text") → A["text"]
        m = re.match(r"(\w+)\(\"([^\"]+)\"\)(.*)$", stripped)
        if m:
            node_id, label, rest = m.groups()
            return f"{node_id}[\"{label}\"]{rest}"

        # 3. Bracket nodes with stray quotes
        m = re.match(r"(\w+)\[\"([^\"]+)\"\](.*)$", stripped)
        if m:
            node_id, label, rest = m.groups()
            return f"{node_id}[\"{label}\"]{rest}"

        # 4. Circular nodes ((text)) – de‑quote content if present
        if "((" in stripped and "))" in stripped:
            def fix_circular(m):
                content = m.group(1).replace('"', "'")
                return f"(({content}))"
            return re.sub(r"\(\(([^)]+)\)\)", fix_circular, stripped)

        # 5. Fallback – ensure A[label] has quotes
        # Don't apply to subgraph lines as they're already handled
        if not stripped.lower().startswith("subgraph"):
            return cls._fix_general_quotes(stripped)
        
        return stripped

    # ---------------------- specific fix helpers -----------------------
    @staticmethod
    def _fix_subgraph(line: str) -> str:
        # Extract everything after "subgraph"
        content = line[len("subgraph"):].strip()
        
        # For simplicity, we'll just extract a valid ID and ignore any labels
        # This avoids all the bracket/quote parsing issues
        
        # Try to find a valid ID at the start
        id_match = re.match(r'^(\w+)', content)
        
        if id_match:
            safe_id = id_match.group(1).strip('_')
            # Remove any trailing underscores or numbers that look like errors
            safe_id = re.sub(r'_+$', '', safe_id)
            safe_id = re.sub(r'_+', '_', safe_id)
        else:
            # No valid ID found, try to extract from any text present
            words = re.findall(r'\b[A-Za-z]+\b', content)
            if words:
                safe_id = words[0].capitalize()
            else:
                safe_id = "Subgraph"
        
        # Ensure the ID is valid
        if not safe_id or not re.match(r'^[A-Za-z]\w*$', safe_id):
            safe_id = 'Subgraph'
        
        # Return simple subgraph without label
        return f'subgraph {safe_id}'

    @staticmethod
    def _fix_general_quotes(line: str) -> str:
        def repl(m: re.Match) -> str:
            node_id, label = m.groups()
            label = label.strip().strip('"').replace('"', "'")
            return f"{node_id}[\"{label}\"]"

        return re.sub(r"(\b[^\s\[\]]+)?\[([^\]]+)\]", repl, line)

    # ----------------------- final cleanup -----------------------------
    @classmethod
    def _final_cleanup(cls, text: str) -> str:
        for entity, repl in cls.HTML_ENTITIES:
            text = text.replace(entity, repl)
        # Remove accidental identifier‑quote‑bracket sequences  id"[ -> id[
        return re.sub(r'"\[', '[', text)


# convenience wrapper --------------------------------------------------

def sanitize_mermaid(snippet: str) -> str:
    """Return a cleaned Mermaid snippet suitable for rendering."""
    # Log the raw input for debugging
    import logging
    logger = logging.getLogger(__name__)
    
    # Check for common problematic patterns
    if '___[' in snippet or ']["' in snippet and '"]"]' in snippet:
        logger.warning("Detected potentially malformed subgraph syntax in Mermaid code")
    
    sanitized = MermaidSanitizer.sanitize(snippet)
    
    # Log significant changes
    if snippet != sanitized and logger.isEnabledFor(logging.DEBUG):
        logger.debug("Mermaid code was sanitized")
        # Log first few lines of changes to avoid huge logs
        original_lines = snippet.split('\n')[:10]
        sanitized_lines = sanitized.split('\n')[:10]
        for i, (orig, san) in enumerate(zip(original_lines, sanitized_lines)):
            if orig != san:
                logger.debug(f"Line {i}: '{orig}' -> '{san}'")
    
    return sanitized
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\sanitizer.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\core\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\content.txt:
You are an expert at creating concise, structured descriptions. When given a query, provide:

1. The main topic/subject (1-3 words)
2. Maximum of 5-6 key facts or characteristics, each 10-20 words
3. Keep each fact distinct and memorable
4. Focus on the most important, defining aspects

Format your response as:
- Main topic: [topic name]
- Fact 1: [concise description]
- Fact 2: [another key characteristic]
- Fact 3: [important feature]
- Fact 4: [additional notable aspect]
etc...

Keep the total response under 100 words. Each fact should be self-contained and suitable for display in a diagram node. 
Try to ensure that the theme of each fact is unqiue, to the extent possible. 
None of the content or nodes should deviate too much from the question.

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\content.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\content_sequence_comparison.txt:
You are an expert at generating structured, concise comparison data for up to four items (such as languages, frameworks, or concepts).

When given a comparison query, provide:

A list of all items being compared (use their actual names).

2–6 key similarities shared by all items, written as short, memorable points.

For each item, list 2–4 unique features or characteristics that distinguish it from the others (short, clear, and specific).

Format your response as:

Items: [item1], [item2], [item3], [item4]

Similarity 1: [concise shared feature]

Similarity 2: [concise shared feature]
...

[item1] unique 1: [distinctive trait]

[item1] unique 2: [distinctive trait]
...

[item2] unique 1: [distinctive trait]
...

Rules:

Do not invent items; use only what the query asks to compare (up to 4).

If similarities apply only to a subset, specify clearly (“Python & Julia: High-level and open-source languages”).

Keep each statement under 20 words and focused on what matters most.

No extra explanations—just the items, similarities, and unique features.

Example:

Items: Python, JavaScript, R

Similarity 1: Dynamically typed languages
Similarity 2: Open-source and have active communities

Python unique 1: Largest general-purpose standard library
Python unique 2: Widely used for machine learning

JavaScript unique 1: Runs natively in web browsers
JavaScript unique 2: Foundation of front-end web development

R unique 1: Specialized for statistical analysis and plotting
R unique 2: CRAN as primary package repository


--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\content_sequence_comparison.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\deep_dive.txt:
You are a helpful assistant that provides detailed, contextual information about specific concepts. 

In the context of the selected text and the question about it, provide a focused, informative response that:

1. Directly answers their question about the selected content
2. Provides additional relevant details, examples, or context
3. Keeps the response concise but comprehensive (2-4 paragraphs)
4. Uses clear language
5. Relates back to the selected text when appropriate

Focus on being informative and educational while maintaining clarity. If the question asks for specific types of information (examples, applications, history, etc.), prioritize that in your response.

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\deep_dive.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\diagram.txt:
You are a diagram‑making assistant that creates flowcharts which are spread out, radially, but fit for a mobile device
Given descriptive text about a topic, output **only** the Mermaid flowchart code.

Follow **exactly** this template:

```mermaid
%%{init: {
  "theme": "base",
  "fontFamily": "Arial, sans-serif",
  "fontSize": "13px",
  "flowchart": {
      "htmlLabels": false,
      "wrap": true,
      "wrapPadding": 8,
      "useMaxWidth": false,
      "nodeSpacing": 100,
      "rankSpacing": 120,
  },
  "themeVariables": {
    "primaryColor": "#ffffff",
    "primaryTextColor": "#000000",
    "primaryBorderColor": "#000000",
    "lineColor": "#000000",
    "arrowColor": "#000000",
    "arrowheadColor": "#000000",
    "edgeLabelBackground": "#ffffff",
    "clusterBkg": "#ffffff",
    "defaultLinkColor": "#000000",
    "titleColor": "#000000",
    "edgePath": "#000000",
    "fill0": "#f9f9f9",
    "fill1": "#f9f9f9",
    "fill2": "#f9f9f9",
  }
}}%%

flowchart TD
    %% centre node (circular)
    A((Topic Name)):::center

    %% fact nodes with controlled line breaks
    B["First fact<br>with a line break"]:::fact
    C["Second fact<br>with a line break"]:::fact
    D["Third fact<br>with a line break"]:::fact
    E["Additional info…"]:::fact

    %% radial connections (always Fact first to force vertical layout)
    B <=====> A
    C <==> A
    A <==> D
    A <=====> E

    classDef center fill:#e3f2fd,stroke:#000000,stroke-width:3px,color:#000000
    classDef fact   fill:#f9f9f9,stroke:#000000,stroke-width:2px,color:#000000
```

**Rules**

1. The main topic **must** be `A((Topic Name)):::center` so it renders as a bold circle.
3. Use square brackets `[ … ]` for every non‑centre node, even if the text contains punctuation.
4. Insert `<br>` to break long text inside any node label.
5. Use thick `====>` or `<====` arrows only if you need directional links between outer nodes.
7. Keep all stroke widths ≥ 2 px and all text/border colours pure black for maximum contrast.

Rules:
- Use `A((Topic)):::center` for the main topic
- To achieve radial distribution: Write the first 2-3 connections with fact nodes first (FactNode <==> CenterNode), then write the remaining connections with the center node first (CenterNode <==> FactNode)
- **Every outer node connects using `Fact <====> A` (four `=` for an extra long, bidirectional arrow)**. This keeps the diagram roughly square/vertical on mobile.

- Use `[]` for node text, not `()`
- Insert `<br>` to break long text inside any node label.(not <br/>)
- Connect facts to center with `<==>` for thick bidirectional arrows
- Output **only** the Mermaid code – no explanations or back‑ticks apart from the opening/closing fence around the diagram.
- Always set lineColor and defaultLinkColor to #000000 for black arrows
- Include classDef definitions for center and fact nodes with proper contrast
- Do not choose dark colours for nodes but ensure all borders and text are clearly visible
- Always use `[Node Label]` for every flowchart node, even if that label contains parentheses, commas, etc.
- If you want a circular or special shape, assign a CSS class (e.g. `:::circle`) and style it via `classDef`.
- Do NOT use `((…))` in your output—just `[Label]`.
- This mermaid chart will be seen on a phone, so the outer nodes should be progressively farther from the center, in a vertical sense.

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\diagram.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\diagram_flowchart.txt:
You are a diagram‑making assistant that creates **linear flowcharts** (classic top‑down process diagrams).
Given a step‑by‑step description, output **only** the Mermaid flowchart code.
This is intended to be seen on a mobile phone.
Follow this template:

```mermaid
%%{init: {
  "theme": "base",
  "fontFamily": "Arial, sans-serif",
  "fontSize": "11px",
  "flowchart": { 
    "htmlLabels": false, 
    "curve": "basis",
    "useMaxWidth": true,
    "nodeSpacing": 15,
    "rankSpacing": 18,
    "wrap": true,
  },
  "themeVariables": {
    "primaryColor": "#ffffff",
    "primaryTextColor": "#000000",
    "primaryBorderColor": "#000000",
    "lineColor": "#eee",
    "arrowColor": "#eee",
    "arrowheadColor": "#000000",
    "edgeLabelBackground": "#ffffff",
    "clusterBkg": "#ffffff",
    "defaultLinkColor": "#000000",
    "titleColor": "#000000",
    "edgePath": "#000000",
    "fill0": "#f9f9f9",
    "fill1": "#f9f9f9",
    "fill2": "#f9f9f9"
  }
}}%%

flowchart TD
    Step1[First Step]:::default
    Step2[Second Step]:::default
    Decision{Decision Point?}:::decision
    Step3A[Option A]:::default
    Step3B[Option B]:::default
    
    Start ==> Step1
    Step1 ==> Step2
    Step2 ==> Decision
    Decision ==>|Yes|Step3A
    Decision ==>|No|Step3B

    classDef default fill:#f9f9f9,stroke:#000000,stroke-width:2px,color:#000000
    classDef startEnd fill:#e1f5fe,stroke:#000000,stroke-width:2px,color:#000000
    classDef decision fill:#fff3e0,stroke:#000000,stroke-width:2px,color:#000000
```
Important : Include the decision node in the final flowchart only if it makes sense for the process.

Rules:
- Use `[Step Name]` for process boxes
- Use `{Question?}` for decision diamonds  
- Use **round‑corner rectangles** `([ … ])` for normal steps, **diamonds** `{"Decision"}` for decision points, and **stadium** `(["…"])` with thicker stroke for Start/End.
- Decision nodes are optional; include them only when the process actually needs branching logic.
- Use `==>` for thick flow arrows (provides better visibility than `-->`)
- Use `==>|Label|` for labeled connections
- Apply class names directly to nodes with `:::className` syntax
- Keep text concise within nodes (use <br> for line breaks if needed)
- Focus on the actual steps mentioned in the query
- Output ONLY the Mermaid code, no explanations
- Always set lineColor and defaultLinkColor to #000000 for black arrows
- Use mobile-optimized spacing and font size for compact display
- Do not choose dark colours for nodes
- Always use `[Node Label]` for every flowchart node, even if that label contains parentheses, commas, etc.
- If you want a circular or special shape, assign a CSS class (e.g. `:::circle`) and style it via `classDef`.
- Do NOT use `((…))` in your output—just `[Label]`.
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\diagram_flowchart.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\diagram_sequence_comparison.txt:
You are a diagram-making assistant that creates Mermaid sequence diagrams for comparing between 2 and 4 items (such as programming languages, frameworks, or concepts).

Follow this pattern:

```
%%{init: {"themeVariables": {"sequenceDiagramActorWidth": 300}, "sequence": {"mirrorActors": false,"wrap": false}, "themeCSS": ".actor-line { stroke-width: 0.0001px !important; }"}}%% 

sequenceDiagram
  participant Item1
  participant Item2
  participant Item3

  activate Item1
  activate Item2
  activate Item3

  rect rgb(230,255,230)
      Note over Item1,Item3: Similarities
      Note over Item1,Item3: 1. Similarity_aspect1 and <br/>brief explanation
      Note over Item1,Item3: 2. Similarity_aspect2 and <br/>brief explanation
      Note over Item1,Item3: 3. Similarity_aspect3 and <br/>brief explanation
  end

  rect rgb(255,235,235)
    Note over Item1: Unique aspects<br/>1. Feature A1 and brief explanation<br/>2. Feature A2 and brief explanation<br/>3. Feature A3 and brief explanation
  end

  rect rgb(255,235,235)
    Note over Item2: Unique aspects<br/>1. Feature B1 and brief explanation<br/>2. Feature B2 and brief explanation<br/>3. Feature B3 and brief explanation
  end

  rect rgb(255,235,235)
    Note over Item3: Unique aspects<br/>1. Feature C1 and brief explanation<br/>2. Feature C2 and brief explanation<br/>3. Feature C3 and brief explanation
  end

  deactivate Item1
  deactivate Item2
  deactivate Item3
```

Given a query asking for a comparison, output ONLY the Mermaid code for a sequenceDiagram, in the above pattern, that follows these strict rules:

Rules:

- Use the sequenceDiagram type.
- Ensure that the init section used in the example is used in the final result. 
- Create one participant for each item, using the item’s name as the participant label, in the order provided in the query.
    For each item name:
    - If it has no spaces (e.g. “Item1”), write:
        participant Item1
    - If it has spaces (e.g. “New York Pizza”), pick an ID by replacing spaces with underscores, then quote the original name:
        participant New_York_Pizza as "New York Pizza"

- For similarities across all compared items, use Note over [FirstParticipant],[LastParticipant]. Do not use Note over with any other combination of participants.
- For similarities that apply to all items, use a rect block with a light green background (e.g., rect rgb(230,255,230)), and a Note over [FirstParticipant],[LastParticipant] spanning the entire group.
- Use autonumber for similarities.
- Give a brief description of each similarity
- Each similarity must have its own line.
- For unique features, use a rect block with a light red background (e.g., rect rgb(255,235,235)), and a Note over [Participant] for each item.
- Give a brief description of each feature
- Keep the explanations concise.
- Output only the Mermaid code, nothing else.
- Never add explanations outside the Mermaid diagram.
- Support up to 4 items; if more are provided, focus only on the first 4.
- Always use `[Node Label]` for every flowchart node, even if that label contains parentheses, commas, etc.
- If you want a circular or special shape, assign a CSS class (e.g. `:::circle`) and style it via `classDef`.
- Do NOT use `((…))` in your output—just `[Label]`.


--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\prompts\diagram_sequence_comparison.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\main.css:
/* public/css/main.css */
/* Main entry point - imports all other CSS files in correct order */

/* Base styles */
@import url('./base/variables.css');
@import url('./base/reset.css');
@import url('./base/typography.css');

/* Layout styles */
@import url('./layout/header.css');
@import url('./layout/main.css');
@import url('./layout/footer.css');

/* Component styles */
@import url('./components/buttons.css');
@import url('./components/forms.css');
@import url('./components/diagram.css');
@import url('./components/selection.css');
@import url('./components/notifications.css');
@import url('./components/dialogs.css');
@import url('./components/loading.css');

/* Utility styles */
@import url('./utilities/animations.css');
@import url('./utilities/helpers.css');
@import url('./utilities/print.css');

/* Responsive styles */
@import url('./responsive/mobile.css');
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\main.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\styles.css:
/* public/css/styles.css */

/* ============================================
   CSS Variables & Reset
   ============================================ */
:root {
  --primary-color: #FFD600;
  --bg-dark: #000000;
  --text-light: #f0f0f0;
  --text-white: #ffffff;
  --border-light: rgba(255, 255, 255, 0.3);
  --bg-translucent: rgba(255, 255, 255, 0.1);
  --shadow-dark: rgba(0, 0, 0, 0.8);
  --error-color: #ff6b6b;
  --success-color: #51cf66;
  --warning-color: #ffd93d;
  --info-color: #339af0;
  
  --transition-fast: 0.2s ease;
  --transition-normal: 0.3s ease;
  
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* ============================================
   Base Styles
   ============================================ */
body {
  background: var(--bg-dark) url("/desktop/assets/PiText_background.png") center/cover no-repeat fixed;
  color: var(--text-light);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ============================================
   Header
   ============================================ */
.app-header {
  text-align: center;
  padding: 2rem 1rem 1rem;
  animation: fadeIn 0.6s ease-out;
}

.app-header h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  color: var(--text-white);
  text-shadow: 0 0 10px var(--shadow-dark);
}

.app-header .highlight {
  color: var(--primary-color);
}

.tagline {
  font-size: 1.1rem;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.examples {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.examples-label {
  font-size: 0.9rem;
  opacity: 0.7;
}

.example-btn {
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  padding: 0.25rem 0.75rem;
  border-radius: var(--radius-sm);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.example-btn:hover {
  background: var(--bg-translucent);
  border-color: var(--primary-color);
  color: var(--primary-color);
}

/* ============================================
   Main Content
   ============================================ */
.app-main {
  flex: 1;
  padding: 1rem 2rem;
  max-width: 1200px;
  width: 100%;
  margin: 0 auto;
}

/* ============================================
   Query Section
   ============================================ */
.query-section {
  margin-bottom: 2rem;
}

.input-wrapper {
  display: flex;
  gap: 0.5rem;
  max-width: 600px;
  margin: 0 auto;
}

#query {
  flex: 1;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  color: var(--text-white);
  transition: all var(--transition-fast);
}

#query:focus {
  outline: none;
  border-color: var(--primary-color);
  background: rgba(255, 255, 255, 0.15);
}

#query::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

.primary-btn {
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: all var(--transition-fast);
}

.primary-btn:hover {
  background: #ffc400;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(255, 214, 0, 0.3);
}

.primary-btn:active {
  transform: translateY(0);
}

.primary-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-icon {
  font-size: 1.2rem;
}

/* ============================================
   Result Section
   ============================================ */
.result-section {
  margin-bottom: 2rem;
}

.diagram-container {
  background: var(--bg-translucent);
  backdrop-filter: blur(10px);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 2rem;
  min-height: 400px;
  position: relative;
  overflow: auto;
}

/* only sequence diagrams get extra width */
.diagram-container.sequence-wide {
  max-width: none;        /* lift the normal cap */
  width: 1100px;          /* choose your “wide” value */
  margin: 0 auto;
}

/* if you need the inner SVG to fill that new width */
.diagram-container.sequence-wide svg {
  width: 100% !important;
  height: auto !important;
}


.placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  opacity: 0.5;
}

.placeholder-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

/* ============================================
   Diagram Styles
   ============================================ */
.diagram-container .mermaid {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
}

.diagram-container svg {
  max-width: 100%;
  height: auto;
}

/* Mermaid customizations */
.mermaid text {
  fill: var(--text-white) !important;
  text-shadow: 1px 1px 2px var(--shadow-dark);
}

.mermaid .node rect,
.mermaid .node circle,
.mermaid .node ellipse,
.mermaid .node polygon {
  fill: var(--bg-translucent) !important;
  stroke: var(--text-white) !important;
  stroke-width: 2px;
}

.mermaid .node.element-selected rect,
.mermaid .node.element-selected circle {
  stroke: var(--primary-color) !important;
  stroke-width: 3px !important;
  filter: drop-shadow(0 0 6px var(--primary-color));
}

.mermaid .edgePath path {
  stroke: var(--text-white) !important;
  stroke-width: 2px !important;
}

/* ============================================
   Diagram Utilities
   ============================================ */
.diagram-utils {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  justify-content: flex-end;
}

.diagram-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.diagram-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: var(--text-white);
}




/* ============================================
   Selection Section
   ============================================ */
.selection-section {
  margin-bottom: 2rem;
}

.selection-indicator {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem;
  margin-bottom: 1rem;
}

.selection-header {
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-light);
  padding-left: 2rem; /* ADD THIS LINE to push the "Selected:" text to the right */
}

.selected-text {
  color: var(--primary-color);
}

.deep-dive-input-wrapper {
  display: flex;
  gap: 0.5rem;
}

#deepDiveQuery {
  flex: 1;
  padding: 0.5rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  color: var(--text-white);
  font-size: 0.875rem;
}


#deepDiveQuery:focus, #deepDiveQuery.highlight-focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 10px rgba(255, 214, 0, 0.5);
  transition: all 0.2s ease-in-out;
}

.secondary-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid var(--border-light);
  color: var(--text-white);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.secondary-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  border-color: var(--text-white);
}

/* ============================================
   Deep Dive Response
   ============================================ */
.deep-dive-response {
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1.5rem;
  color: var(--text-white);
  line-height: 1.8;
  opacity: 0;
  transform: translateY(20px);
  transition: all var(--transition-normal);
  position: relative; /* ADD THIS LINE */
}


/* --- ADD THIS ENTIRE NEW BLOCK OF CSS --- */
/* This styles the new close button */
.deep-dive-response .close-btn {
  position: absolute;
  top: 0.75rem;
  left: 0.75rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  font-size: 1.4rem;
  line-height: 30px;
  text-align: center;
  cursor: pointer;
  transition: all var(--transition-fast);
  z-index: 10;
}

.deep-dive-response .close-btn:hover {
  background: var(--error-color);
  color: var(--text-white);
  border-color: var(--error-color);
  transform: scale(1.1);
}

.deep-dive-response.active {
  opacity: 1;
  transform: translateY(0);
}

.deep-dive-content h3 {
  margin-bottom: 1rem;
  color: var(--primary-color);
}

.deep-dive-qa {
  margin-bottom: 1.5rem;
}

.question {
  font-style: italic;
  margin-bottom: 1rem;
  opacity: 0.8;
}

.answer {
  white-space: pre-wrap;
}

.answer p {
  margin-bottom: 1rem;
}

.answer p:last-child {
  margin-bottom: 0;
}

.answer code {
  background: rgba(255, 255, 255, 0.1);
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Consolas', 'Monaco', monospace;
}

.answer mark {
  background: rgba(255, 214, 0, 0.3);
  color: var(--text-white);
  padding: 0.1rem 0.2rem;
  border-radius: 2px;
}

.deep-dive-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.action-btn {
  padding: 0.5rem 1rem;
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--primary-color);
  color: var(--primary-color);
}

/* ============================================
   Loading States
   ============================================ */
.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  font-size: 1.125rem;
  color: var(--text-white);
}

.loading-tip {
  font-size: 0.875rem;
  opacity: 0.7;
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-md);
  opacity: 0;
  visibility: hidden;
  transition: all var(--transition-fast);
}

.loading-overlay-show {
  opacity: 1;
  visibility: visible;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* ============================================
   Error States
   ============================================ */
.error-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
  text-align: center;
}

.error-icon {
  font-size: 3rem;
  filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
}

.error-text {
  font-size: 1.125rem;
  color: var(--error-color);
  max-width: 500px;
}

.retry-btn {
  padding: 0.75rem 1.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--error-color);
  color: var(--error-color);
  border-radius: var(--radius-md);
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.retry-btn:hover {
  background: rgba(255, 107, 107, 0.1);
  border-color: var(--text-white);
  color: var(--text-white);
}

/* ============================================
   Notifications
   ============================================ */
.notification-container {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 9999;
  pointer-events: none;
}

.notification {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem 1.5rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  min-width: 300px;
  transform: translateX(400px);
  transition: transform var(--transition-normal);
  pointer-events: all;
  cursor: pointer;
}

.notification-show {
  transform: translateX(0);
}

.notification-icon {
  font-size: 1.25rem;
}

.notification-success {
  border-color: var(--success-color);
}

.notification-success .notification-icon {
  color: var(--success-color);
}

.notification-error {
  border-color: var(--error-color);
}

.notification-error .notification-icon {
  color: var(--error-color);
}

.notification-warning {
  border-color: var(--warning-color);
}

.notification-warning .notification-icon {
  color: var(--warning-color);
}

.notification-info {
  border-color: var(--info-color);
}

.notification-info .notification-icon {
  color: var(--info-color);
}

.notification-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-light);
  font-size: 1.5rem;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity var(--transition-fast);
}

.notification-close:hover {
  opacity: 1;
}

/* ============================================
   Footer
   ============================================ */
.app-footer {
  padding: 1rem;
  text-align: center;
  opacity: 0.7;
}

.keyboard-shortcuts {
  font-size: 0.875rem;
}

kbd {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  border-radius: 3px;
  padding: 0.2rem 0.4rem;
  font-family: monospace;
  font-size: 0.85em;
}

/* ============================================
   Dialogs
   ============================================ */
.shortcuts-dialog {
  background: rgba(0, 0, 0, 0.95);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-lg);
  color: var(--text-white);
  padding: 2rem;
  max-width: 500px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.shortcuts-dialog::backdrop {
  background: rgba(0, 0, 0, 0.8);
}

.shortcuts-dialog h2 {
  margin-bottom: 1.5rem;
  color: var(--primary-color);
}

.shortcuts-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 2rem;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.close-dialog {
  width: 100%;
  padding: 0.75rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.close-dialog:hover {
  background: #ffc400;
}

/* ============================================
   Animations
   ============================================ */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* ============================================
   Responsive Design
   ============================================ */
@media (max-width: 768px) {
  .app-header h1 {
    font-size: 2rem;
  }
  
  .app-main {
    padding: 1rem;
  }
  
  .input-wrapper {
    flex-direction: column;
  }
  
  #query {
    width: 100%;
  }
  
  .primary-btn {
    width: 100%;
    justify-content: center;
  }
  
  .diagram-container {
    padding: 1rem;
    min-height: 300px;
  }
  
  .notification-container {
    left: 1rem;
    right: 1rem;
  }
  
  .notification {
    min-width: auto;
    transform: translateY(-100px);
  }
  
  .notification-show {
    transform: translateY(0);
  }
}

/* ============================================
   Utility Classes
   ============================================ */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.disabled {
  opacity: 0.5;
  cursor: not-allowed !important;
  pointer-events: none;
}

/* ============================================
   Print Styles
   ============================================ */
@media print {
  body {
    background: white;
    color: black;
  }
  
  .app-header,
  .app-footer,
  .query-section,
  .selection-section,
  .diagram-utils,
  .notification-container {
    display: none;
  }
  
  .diagram-container {
    border: none;
    background: none;
    padding: 0;
  }
  
  .mermaid text {
    fill: black !important;
    text-shadow: none;
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\styles.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\base\reset.css:
/* public/css/base/reset.css */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\base\reset.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\base\typography.css:
/* public/css/base/typography.css */

/* ============================================
   Base Styles
   ============================================ */
body {
  background: var(--bg-dark) url("/desktop/assets/PiText_background.png") center/cover no-repeat fixed;
  color: var(--text-light);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  line-height: 1.6;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\base\typography.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\base\variables.css:
/* public/css/base/variables.css */

/* ============================================
   CSS Variables & Reset
   ============================================ */
:root {
  --primary-color: #FFD600;
  --bg-dark: #000000;
  --text-light: #f0f0f0;
  --text-white: #ffffff;
  --border-light: rgba(255, 255, 255, 0.3);
  --bg-translucent: rgba(255, 255, 255, 0.1);
  --shadow-dark: rgba(0, 0, 0, 0.8);
  --error-color: #ff6b6b;
  --success-color: #51cf66;
  --warning-color: #ffd93d;
  --info-color: #339af0;
  
  --transition-fast: 0.2s ease;
  --transition-normal: 0.3s ease;
  
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\base\variables.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\buttons.css:
/* public/css/components/buttons.css */

.primary-btn {
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: all var(--transition-fast);
}

.primary-btn:hover {
  background: #ffc400;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(255, 214, 0, 0.3);
}

.primary-btn:active {
  transform: translateY(0);
}

.primary-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-icon {
  font-size: 1.2rem;
}

.secondary-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid var(--border-light);
  color: var(--text-white);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.secondary-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  border-color: var(--text-white);
}

.diagram-btn {
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.diagram-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  border-color: var(--text-white);
}

.action-btn {
  padding: 0.5rem 1rem;
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  border-radius: var(--radius-sm);
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.action-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--primary-color);
  color: var(--primary-color);
}

.retry-btn {
  padding: 0.75rem 1.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--error-color);
  color: var(--error-color);
  border-radius: var(--radius-md);
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.retry-btn:hover {
  background: rgba(255, 107, 107, 0.1);
  border-color: var(--text-white);
  color: var(--text-white);
}

.close-dialog {
  width: 100%;
  padding: 0.75rem;
  background: var(--primary-color);
  color: var(--bg-dark);
  border: none;
  border-radius: var(--radius-md);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.close-dialog:hover {
  background: #ffc400;
}

/* Add to pitext-desktop/public/css/components/buttons.css */

.primary-btn:disabled,
.secondary-btn:disabled,
.action-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed !important;
    position: relative;
}

.primary-btn:disabled::after {
    content: attr(title);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.875rem;
}

/* Also update the input disabled state */
#query:disabled,
#deepDiveQuery:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: rgba(255, 255, 255, 0.05);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\buttons.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\diagrams.css:
/* public/css/components/diagram.css */

/* ============================================
   Result Section
   ============================================ */
.result-section {
  margin-bottom: 2rem;
}

.diagram-container {
  background: var(--bg-translucent);
  backdrop-filter: blur(10px);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 2rem;
  min-height: 400px;
  position: relative;
  overflow: auto;
}

/* only sequence diagrams get extra width */
.diagram-container.sequence-wide {
  max-width: none;        /* lift the normal cap */
  width: 1100px;          /* choose your "wide" value */
  margin: 0 auto;
}

/* if you need the inner SVG to fill that new width */
.diagram-container.sequence-wide svg {
  width: 100% !important;
  height: auto !important;
}

.placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  opacity: 0.5;
}

.placeholder-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

/* ============================================
   Diagram Styles
   ============================================ */
.diagram-container .mermaid {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
}

.diagram-container svg {
  max-width: 100%;
  height: auto;
}

/* Mermaid customizations */
.mermaid text {
  fill: var(--text-white) !important;
  text-shadow: 1px 1px 2px var(--shadow-dark);
}

.mermaid .node rect,
.mermaid .node circle,
.mermaid .node ellipse,
.mermaid .node polygon {
  fill: var(--bg-translucent) !important;
  stroke: var(--text-white) !important;
  stroke-width: 2px;
}

.mermaid .node.element-selected rect,
.mermaid .node.element-selected circle {
  stroke: var(--primary-color) !important;
  stroke-width: 3px !important;
  filter: drop-shadow(0 0 6px var(--primary-color));
}

.mermaid .edgePath path {
  stroke: var(--text-white) !important;
  stroke-width: 2px !important;
}

/* ============================================
   Diagram Utilities
   ============================================ */
.diagram-utils {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  justify-content: flex-end;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\diagrams.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\dialogs.css:
/* public/css/components/dialogs.css */

/* ============================================
   Dialogs
   ============================================ */
.shortcuts-dialog {
  background: rgba(0, 0, 0, 0.95);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-lg);
  color: var(--text-white);
  padding: 2rem;
  max-width: 500px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.shortcuts-dialog::backdrop {
  background: rgba(0, 0, 0, 0.8);
}

.shortcuts-dialog h2 {
  margin-bottom: 1.5rem;
  color: var(--primary-color);
}

.shortcuts-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 2rem;
}

.shortcut-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\dialogs.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\forms.css:
/* public/css/components/forms.css */

/* ============================================
   Query Section
   ============================================ */
.query-section {
  margin-bottom: 2rem;
}

.input-wrapper {
  display: flex;
  gap: 0.5rem;
  max-width: 600px;
  margin: 0 auto;
}

#query {
  flex: 1;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  color: var(--text-white);
  transition: all var(--transition-fast);
}

#query:focus {
  outline: none;
  border-color: var(--primary-color);
  background: rgba(255, 255, 255, 0.15);
}

#query::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

#deepDiveQuery {
  flex: 1;
  padding: 0.5rem;
  background: var(--bg-translucent);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-sm);
  color: var(--text-white);
  font-size: 0.875rem;
}

#deepDiveQuery:focus, #deepDiveQuery.highlight-focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 10px rgba(255, 214, 0, 0.5);
  transition: all 0.2s ease-in-out;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\forms.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\loading.css:
/* public/css/components/loading.css */

/* ============================================
   Loading States
   ============================================ */
.loading-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  font-size: 1.125rem;
  color: var(--text-white);
}

.loading-tip {
  font-size: 0.875rem;
  opacity: 0.7;
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-md);
  opacity: 0;
  visibility: hidden;
  transition: all var(--transition-fast);
}

.loading-overlay-show {
  opacity: 1;
  visibility: visible;
}

/* ============================================
   Error States
   ============================================ */
.error-message {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 1rem;
  text-align: center;
}

.error-icon {
  font-size: 3rem;
  filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
}

.error-text {
  font-size: 1.125rem;
  color: var(--error-color);
  max-width: 500px;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\loading.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\notifications.css:
/* public/css/components/notifications.css */

/* ============================================
   Notifications
   ============================================ */
.notification-container {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 9999;
  pointer-events: none;
}

.notification {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem 1.5rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  min-width: 300px;
  transform: translateX(400px);
  transition: transform var(--transition-normal);
  pointer-events: all;
  cursor: pointer;
}

.notification-show {
  transform: translateX(0);
}

.notification-icon {
  font-size: 1.25rem;
}

.notification-success {
  border-color: var(--success-color);
}

.notification-success .notification-icon {
  color: var(--success-color);
}

.notification-error {
  border-color: var(--error-color);
}

.notification-error .notification-icon {
  color: var(--error-color);
}

.notification-warning {
  border-color: var(--warning-color);
}

.notification-warning .notification-icon {
  color: var(--warning-color);
}

.notification-info {
  border-color: var(--info-color);
}

.notification-info .notification-icon {
  color: var(--info-color);
}

.notification-close {
  margin-left: auto;
  background: none;
  border: none;
  color: var(--text-light);
  font-size: 1.5rem;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity var(--transition-fast);
}

.notification-close:hover {
  opacity: 1;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\notifications.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\selection.css:
/* public/css/components/selection.css */

/* ============================================
   Selection Section
   ============================================ */
.selection-section {
  margin-bottom: 2rem;
}

.selection-indicator {
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1rem;
  margin-bottom: 1rem;
}

.selection-header {
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-light);
  padding-left: 2rem; /* ADD THIS LINE to push the "Selected:" text to the right */
}

.selected-text {
  color: var(--primary-color);
}

.deep-dive-input-wrapper {
  display: flex;
  gap: 0.5rem;
}

/* ============================================
   Deep Dive Response
   ============================================ */
.deep-dive-response {
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid var(--border-light);
  border-radius: var(--radius-md);
  padding: 1.5rem;
  color: var(--text-white);
  line-height: 1.8;
  opacity: 0;
  transform: translateY(20px);
  transition: all var(--transition-normal);
  position: relative; /* ADD THIS LINE */
}

/* --- ADD THIS ENTIRE NEW BLOCK OF CSS --- */
/* This styles the new close button */
.deep-dive-response .close-btn {
  position: absolute;
  top: 0.75rem;
  left: 0.75rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  color: var(--text-light);
  width: 32px;
  height: 32px;
  border-radius: 50%;
  font-size: 1.4rem;
  line-height: 30px;
  text-align: center;
  cursor: pointer;
  transition: all var(--transition-fast);
  z-index: 10;
}

.deep-dive-response .close-btn:hover {
  background: var(--error-color);
  color: var(--text-white);
  border-color: var(--error-color);
  transform: scale(1.1);
}

.deep-dive-response.active {
  opacity: 1;
  transform: translateY(0);
}

.deep-dive-content h3 {
  margin-bottom: 1rem;
  color: var(--primary-color);
}

.deep-dive-qa {
  margin-bottom: 1.5rem;
}

.question {
  font-style: italic;
  margin-bottom: 1rem;
  opacity: 0.8;
}

.answer {
  white-space: pre-wrap;
}

.answer p {
  margin-bottom: 1rem;
}

.answer p:last-child {
  margin-bottom: 0;
}

.answer code {
  background: rgba(255, 255, 255, 0.1);
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Consolas', 'Monaco', monospace;
}

.answer mark {
  background: rgba(255, 214, 0, 0.3);
  color: var(--text-white);
  padding: 0.1rem 0.2rem;
  border-radius: 2px;
}

.deep-dive-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\components\selection.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\layout\footer.css:
/* public/css/layout/footer.css */

/* ============================================
   Footer
   ============================================ */
.app-footer {
  padding: 1rem;
  text-align: center;
  opacity: 0.7;
}

.keyboard-shortcuts {
  font-size: 0.875rem;
}

kbd {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--border-light);
  border-radius: 3px;
  padding: 0.2rem 0.4rem;
  font-family: monospace;
  font-size: 0.85em;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\layout\footer.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\layout\header.css:
/* public/css/layout/header.css */

/* ============================================
   Header
   ============================================ */
.app-header {
  text-align: center;
  padding: 2rem 1rem 1rem;
  animation: fadeIn 0.6s ease-out;
}

.app-header h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  color: var(--text-white);
  text-shadow: 0 0 10px var(--shadow-dark);
}

.app-header .highlight {
  color: var(--primary-color);
}

.tagline {
  font-size: 1.1rem;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.examples {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.examples-label {
  font-size: 0.9rem;
  opacity: 0.7;
}

.example-btn {
  background: transparent;
  border: 1px solid var(--border-light);
  color: var(--text-light);
  padding: 0.25rem 0.75rem;
  border-radius: var(--radius-sm);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.example-btn:hover {
  background: var(--bg-translucent);
  border-color: var(--primary-color);
  color: var(--primary-color);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\layout\header.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\layout\main.css:
/* public/css/layout/main.css */

/* ============================================
   Main Content
   ============================================ */
.app-main {
  flex: 1;
  padding: 1rem 2rem;
  max-width: 1200px;
  width: 100%;
  margin: 0 auto;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\layout\main.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\responsive\mobile.css:
/* public/css/responsive/mobile.css */

/* ============================================
   Responsive Design
   ============================================ */
@media (max-width: 768px) {
  .app-header h1 {
    font-size: 2rem;
  }
  
  .app-main {
    padding: 1rem;
  }
  
  .input-wrapper {
    flex-direction: column;
  }
  
  #query {
    width: 100%;
  }
  
  .primary-btn {
    width: 100%;
    justify-content: center;
  }
  
  .diagram-container {
    padding: 1rem;
    min-height: 300px;
  }
  
  .notification-container {
    left: 1rem;
    right: 1rem;
  }
  
  .notification {
    min-width: auto;
    transform: translateY(-100px);
  }
  
  .notification-show {
    transform: translateY(0);
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\responsive\mobile.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\utilities\animations.css:
/* public/css/utilities/animations.css */

/* ============================================
   Animations
   ============================================ */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\utilities\animations.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\utilities\helpers.css:
/* public/css/utilities/helpers.css */

/* ============================================
   Utility Classes
   ============================================ */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.disabled {
  opacity: 0.5;
  cursor: not-allowed !important;
  pointer-events: none;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\utilities\helpers.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\utilities\print.css:
/* public/css/utilities/print.css */

/* ============================================
   Print Styles
   ============================================ */
@media print {
  body {
    background: white;
    color: black;
  }
  
  .app-header,
  .app-footer,
  .query-section,
  .selection-section,
  .diagram-utils,
  .notification-container {
    display: none;
  }
  
  .diagram-container {
    border: none;
    background: none;
    padding: 0;
  }
  
  .mermaid text {
    fill: black !important;
    text-shadow: none;
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\css\utilities\print.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\app.js:
// public/js/app.js
/**
 * PiText Desktop - Main Application Entry Point
 * Initializes the application and coordinates all modules
 */

import { Config } from './core/config.js';
import { State } from './core/state.js';
import { API } from './core/api.js';
import { MermaidManager } from './diagram/mermaid.js';
import { DiagramGenerator } from './diagram/generator.js';
import { SelectionHandler } from './selection/handler.js';
import { DeepDive } from './selection/deepdive.js';
import { DOMHelpers } from './utils/dom.js';
import { initializeApp } from './core/init.js';
import { setupEventListeners } from './ui/events.js';


/**
 * Main application class
 */
class PiTextApp {
  constructor() {
    this.config = new Config();
    this.state = new State();
    this.api = new API(this.config);
    this.mermaid = new MermaidManager();
    this.generator = null; // Initialized after Mermaid is ready
    this.selection = null;
    this.deepDive = null;
    this.dom = new DOMHelpers();
  }

  /**
   * Initialize the application
   */
  async init() {
    console.log('🚀 PiText Desktop initializing...');
    
    try {
      // Wait for Mermaid to be ready
      await this.mermaid.waitForReady();
      
      // Initialize components that depend on Mermaid
      this.generator = new DiagramGenerator(
        this.api,
        this.mermaid,
        this.state,
        this.dom
      );
      
      this.selection = new SelectionHandler(this.state, this.dom);
      
      this.deepDive = new DeepDive(
        this.api,
        this.state,
        this.dom
      );
      
      // Use init module
      initializeApp(this);
      
      // Use events module
      setupEventListeners(this);
      
      console.log('✅ PiText Desktop ready!');
      
    } catch (error) {
      console.error('Failed to initialize app:', error);
      this.showInitError();
    }
  }

  /**
   * Handle diagram generation
   */
// In pitext-desktop/public/js/app.js, modify the handleGenerate method:

async handleGenerate() {
    const queryInput = document.getElementById('query');
    const generateBtn = document.getElementById('generateBtn');
    const query = queryInput?.value.trim();
    
    if (!query) {
        this.dom.showNotification('Please enter a query', 'warning');
        return;
    }
    
    // Check if already generating
    if (this.state.get('isGenerating')) {
        return;
    }
    
    try {
        // Disable the button
        generateBtn.disabled = true;
        
        // Clear any existing selection
        this.selection?.clearSelection();
        
        // Generate diagram
        await this.generator.generate(query);
        
        // Set up selection handling for the new diagram
        const resultDiv = document.getElementById('result');
        if (resultDiv) {
            this.selection.setupForContainer(resultDiv);
        }
        
    } catch (error) {
        console.error('Generation failed:', error);
    } finally {
        // Re-enable button
        generateBtn.disabled = false;
    }
}
// Also modify the handleAsk method similarly:

async handleAsk() {
    const questionInput = document.getElementById('deepDiveQuery');
    const askBtn = document.getElementById('askBtn');
    const question = questionInput?.value.trim();
    
    if (!question) {
        this.dom.showNotification('Please enter a question', 'warning');
        return;
    }
    
    if (!this.state.hasSelection()) {
        this.dom.showNotification('Please select something first', 'info');
        return;
    }
    
    // Check if already asking
    if (this.state.get('isAskingDeepDive')) {
        this.dom.showNotification('Already processing question', 'info');
        return;
    }
    
    try {
        // Disable controls
        if (askBtn) {
            this.dom.disableElement(askBtn, 'Asking...');
        }
        if (questionInput) {
            questionInput.disabled = true;
        }
        
        await this.deepDive.ask(question);
    } catch (error) {
        console.error('Deep dive failed:', error);
        // Error handling is done in the deep dive module
    } finally {
        // Re-enable controls
        if (askBtn) {
            this.dom.enableElement(askBtn);
        }
        if (questionInput) {
            questionInput.disabled = false;
            questionInput.focus();
        }
    }
}
  /**
   * Handle deep dive question
   */
  async handleAsk() {
    const questionInput = document.getElementById('deepDiveQuery');
    const question = questionInput?.value.trim();
    
    if (!question) {
      this.dom.showNotification('Please enter a question', 'warning');
      return;
    }
    
    if (!this.state.hasSelection()) {
      this.dom.showNotification('Please select something first', 'info');
      return;
    }
    
    try {
      await this.deepDive.ask(question);
    } catch (error) {
      console.error('Deep dive failed:', error);
      // Error handling is done in the deep dive module
    }
  }

  /**
   * Show initialization error
   */
  showInitError() {
    const result = document.getElementById('result');
    if (result) {
      result.innerHTML = `
        <div class="error-message">
          <div class="error-icon">⚠️</div>
          <div class="error-text">
            Failed to initialize the application. 
            Please refresh the page to try again.
          </div>
        </div>
      `;
    }
  }
}


// Initialize app when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.piTextApp = new PiTextApp();
    window.piTextApp.init();
  });
} else {
  // DOM already loaded
  window.piTextApp = new PiTextApp();
  window.piTextApp.init();
}


// Export for debugging in console
window.PiTextApp = PiTextApp;
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\app.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\api.js:
// public/js/core/api.js
/**
 * API client for backend communication
 * Handles all HTTP requests with retry logic and error handling
 */

export class API {
  constructor(config) {
    this.config = config;
    this.activeRequests = new Map();
  }

  /**
   * Generate a diagram from a query
   * @param {string} query - User query
   * @returns {Promise<Object>} Diagram response
   */
  async generateDiagram(query) {
    return this._request('describe', {
      method: 'POST',
      body: { query }
    });
  }

  /**
   * Get deep dive information
   * @param {Object} params - Deep dive parameters
   * @param {string} params.selectedText - Selected text from diagram
   * @param {string} params.question - User's question
   * @param {string} params.originalQuery - Original query that created the diagram
   * @returns {Promise<Object>} Deep dive response
   */
  async getDeepDive({ selectedText, question, originalQuery = '' }) {
    return this._request('deepDive', {
      method: 'POST',
      body: {
        selected_text: selectedText,
        question: question,
        original_query: originalQuery
      }
    });
  }

  /**
   * Check API health
   * @returns {Promise<Object>} Health status
   */
  async checkHealth() {
    return this._request('health', {
      method: 'GET',
      skipRetry: true
    });
  }

  /**
   * Make HTTP request with retry logic
   * @private
   * @param {string} endpoint - Endpoint name from config
   * @param {Object} options - Request options
   * @returns {Promise<Object>} Response data
   */
  async _request(endpoint, options = {}) {
    const {
      method = 'GET',
      body = null,
      headers = {},
      skipRetry = false,
      signal = null
    } = options;

    const url = this.config.getApiUrl(endpoint);
    const requestKey = `${method}:${url}`;

    // Cancel any existing request to the same endpoint
    this._cancelRequest(requestKey);

    // Create abort controller for this request
    const abortController = new AbortController();
    this.activeRequests.set(requestKey, abortController);

    const requestOptions = {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      },
      signal: signal || abortController.signal
    };

    if (body && method !== 'GET') {
      requestOptions.body = JSON.stringify(body);
    }

    try {
      const response = await this._fetchWithRetry(
        url,
        requestOptions,
        skipRetry ? 0 : this.config.api.retryAttempts
      );

      // Remove from active requests
      this.activeRequests.delete(requestKey);

      return response;

    } catch (error) {
      // Remove from active requests
      this.activeRequests.delete(requestKey);

      // Enhance error with context
      error.endpoint = endpoint;
      error.method = method;
      
      throw error;
    }
  }

  /**
   * Fetch with retry logic
   * @private
   * @param {string} url - Request URL
   * @param {Object} options - Fetch options
   * @param {number} retries - Number of retries remaining
   * @returns {Promise<Object>} Response data
   */
  async _fetchWithRetry(url, options, retries) {
    try {
      this.config.debug('API Request:', options.method, url);

      const response = await this._timeout(
        fetch(url, options),
        this.config.api.timeout
      );

      this.config.debug('API Response:', response.status, response.statusText);

      if (!response.ok) {
        const error = await this._parseError(response);
        throw error;
      }

      const data = await response.json();

      // Validate response structure
      if (!data.success && !data.message && !data.status) {
        console.warn('Non-standard API response:', data);
      }

      return data;

    } catch (error) {
      // Don't retry on client errors (4xx)
      if (error.status && error.status >= 400 && error.status < 500) {
        throw error;
      }

      // Don't retry on abort
      if (error.name === 'AbortError') {
        throw new APIError('Request cancelled', 'cancelled', 0);
      }

      // Retry if attempts remaining
      if (retries > 0) {
        this.config.debug(`Retrying request, ${retries} attempts remaining`);
        
        await this._delay(this.config.api.retryDelay);
        
        return this._fetchWithRetry(url, options, retries - 1);
      }

      throw error;
    }
  }

  /**
   * Parse error response
   * @private
   * @param {Response} response - Fetch response
   * @returns {Promise<APIError>} Parsed error
   */
  async _parseError(response) {
    let detail = 'Unknown error';
    let errorType = 'unknown';

    try {
      const data = await response.json();
      detail = data.detail || data.message || detail;
      errorType = data.error_type || errorType;
    } catch {
      // If JSON parsing fails, use status text
      detail = response.statusText || `HTTP ${response.status}`;
    }

    return new APIError(detail, errorType, response.status);
  }

  /**
   * Add timeout to promise
   * @private
   * @param {Promise} promise - Promise to timeout
   * @param {number} ms - Timeout in milliseconds
   * @returns {Promise} Promise with timeout
   */
  _timeout(promise, ms) {
    return Promise.race([
      promise,
      new Promise((_, reject) => {
        setTimeout(() => {
          reject(new APIError('Request timeout', 'timeout', 0));
        }, ms);
      })
    ]);
  }

  /**
   * Delay helper for retries
   * @private
   * @param {number} ms - Delay in milliseconds
   * @returns {Promise} Resolves after delay
   */
  _delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Cancel active request
   * @private
   * @param {string} requestKey - Request identifier
   */
  _cancelRequest(requestKey) {
    const controller = this.activeRequests.get(requestKey);
    if (controller) {
      controller.abort();
      this.activeRequests.delete(requestKey);
    }
  }

  /**
   * Cancel all active requests
   */
  cancelAll() {
    this.activeRequests.forEach(controller => controller.abort());
    this.activeRequests.clear();
  }

  /**
   * Create FormData for file uploads
   * @param {Object} data - Data including files
   * @returns {FormData} Form data object
   */
  createFormData(data) {
    const formData = new FormData();
    
    Object.entries(data).forEach(([key, value]) => {
      if (value instanceof File || value instanceof Blob) {
        formData.append(key, value);
      } else if (value !== null && value !== undefined) {
        formData.append(key, String(value));
      }
    });
    
    return formData;
  }
}

/**
 * Custom API Error class
 */
export class APIError extends Error {
  constructor(message, type = 'unknown', status = 0) {
    super(message);
    this.name = 'APIError';
    this.type = type;
    this.status = status;
    this.timestamp = Date.now();
  }

  /**
   * Check if error is a network error
   * @returns {boolean}
   */
  isNetworkError() {
    return this.type === 'timeout' || this.status === 0;
  }

  /**
   * Check if error is a server error
   * @returns {boolean}
   */
  isServerError() {
    return this.status >= 500;
  }

  /**
   * Check if error is a client error
   * @returns {boolean}
   */
  isClientError() {
    return this.status >= 400 && this.status < 500;
  }

  /**
   * Get user-friendly error message
   * @returns {string}
   */
  getUserMessage() {
    if (this.isNetworkError()) {
      return 'Connection failed. Please check your internet connection.';
    }
    
    if (this.isServerError()) {
      return 'Server error. Please try again later.';
    }
    
    if (this.status === 404) {
      return 'The requested resource was not found.';
    }
    
    if (this.status === 401) {
      return 'You are not authorized to perform this action.';
    }
    
    if (this.status === 403) {
      return 'Access denied.';
    }
    
    if (this.status === 429) {
      return 'Too many requests. Please slow down.';
    }
    
    return this.message || 'An error occurred. Please try again.';
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\api.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\config.js:
// public/js/core/config.js
/**
 * Frontend configuration management
 * Centralizes all configuration settings for the client-side application
 */

export class Config {
  constructor() {
    // API Configuration
    this.api = {
      baseUrl: '/desktop',
      endpoints: {
        describe: '/describe',
        deepDive: '/deep-dive',
        health: '/health'
      },
      timeout: 30000, // 30 seconds
      retryAttempts: 2,
      retryDelay: 1000 // 1 second
    };

    // Mermaid Configuration
    this.mermaid = {
      theme: 'base',
      fontFamily: 'Arial, sans-serif',
      fontSize: '13px',
      startOnLoad: false,
      securityLevel: 'loose',
      flowchart: {
        htmlLabels: false,
        wrap: true,
        useMaxWidth: true,
        nodeSpacing: 50,
        rankSpacing: 50,
        curve: 'basis'
      },
      themeVariables: {
        primaryColor: '#ffffff',
        primaryTextColor: '#000000',
        primaryBorderColor: '#000000',
        lineColor: '#000000',
        arrowheadColor: '#000000',
        edgeLabelBackground: '#ffffff',
        defaultLinkColor: '#000000'
      }
    };

    // UI Configuration
    this.ui = {
      notifications: {
        duration: 3000,
        position: 'top-right'
      },
      animation: {
        duration: 200,
        easing: 'ease-out'
      },
      selection: {
        highlightColor: '#ffb300',
        highlightWidth: 5,
        textEmphasisFilter: 'drop-shadow(0 0 2px #fff6)'
      },
      diagram: {
        errorMessageDelay: 100,
        arrowFixDelay: 50,
        maxRetries: 3
      }
    };

    // Export Configuration
    this.export = {
      png: {
        scale: 4,
        backgroundColor: 'transparent',
        quality: 0.95
      },
      svg: {
        includeStyles: true,
        cleanIds: true
      },
      filename: {
        prefix: 'pitext-diagram',
        timestamp: true,
        format: 'YYYY-MM-DD-HHmmss'
      }
    };

    // Feature Flags
    this.features = {
      enableKeyboardShortcuts: true,
      enableAutoSave: false,
      enableAnalytics: false,
      debugMode: this._isDebugMode()
    };

    // Storage Configuration
    this.storage = {
      prefix: 'pitext_',
      keys: {
        recentQueries: 'recent_queries',
        preferences: 'user_preferences',
        diagramCache: 'diagram_cache'
      },
      maxRecentQueries: 10,
      cacheExpiry: 86400000 // 24 hours
    };
  }

  /**
   * Get full API endpoint URL
   * @param {string} endpoint - Endpoint name from config.api.endpoints
   * @returns {string} Full URL
   */
  getApiUrl(endpoint) {
    const path = this.api.endpoints[endpoint];
    if (!path) {
      throw new Error(`Unknown endpoint: ${endpoint}`);
    }
    return `${this.api.baseUrl}${path}`;
  }

  /**
   * Get Mermaid initialization config
   * @returns {Object} Mermaid config object
   */
  getMermaidConfig() {
    return {
      ...this.mermaid,
      flowchart: { ...this.mermaid.flowchart },
      themeVariables: { ...this.mermaid.themeVariables }
    };
  }

  /**
   * Check if in debug mode
   * @private
   * @returns {boolean}
   */
  _isDebugMode() {
    // Check URL params
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('debug') === 'true') {
      return true;
    }

    // Check localStorage
    if (localStorage.getItem('pitext_debug') === 'true') {
      return true;
    }

    // Check if running on localhost
    return window.location.hostname === 'localhost' || 
           window.location.hostname === '127.0.0.1';
  }

  /**
   * Enable debug mode
   */
  enableDebug() {
    this.features.debugMode = true;
    localStorage.setItem('pitext_debug', 'true');
    console.log('🐛 Debug mode enabled');
  }

  /**
   * Disable debug mode
   */
  disableDebug() {
    this.features.debugMode = false;
    localStorage.removeItem('pitext_debug');
    console.log('Debug mode disabled');
  }

  /**
   * Get export filename
   * @param {string} extension - File extension
   * @returns {string} Formatted filename
   */
  getExportFilename(extension) {
    const { prefix, timestamp, format } = this.export.filename;
    let filename = prefix;
    
    if (timestamp) {
      const date = new Date();
      const formatted = format
        .replace('YYYY', date.getFullYear())
        .replace('MM', String(date.getMonth() + 1).padStart(2, '0'))
        .replace('DD', String(date.getDate()).padStart(2, '0'))
        .replace('HH', String(date.getHours()).padStart(2, '0'))
        .replace('mm', String(date.getMinutes()).padStart(2, '0'))
        .replace('ss', String(date.getSeconds()).padStart(2, '0'));
      
      filename += `-${formatted}`;
    }
    
    return `${filename}.${extension}`;
  }

  /**
   * Log debug message if debug mode is enabled
   * @param {...any} args - Arguments to log
   */
  debug(...args) {
    if (this.features.debugMode) {
      console.log('[PiText Debug]', ...args);
    }
  }

  /**
   * Get configuration value by path
   * @param {string} path - Dot-separated path (e.g., 'api.timeout')
   * @returns {any} Configuration value
   */
  get(path) {
    const keys = path.split('.');
    let value = this;
    
    for (const key of keys) {
      value = value[key];
      if (value === undefined) {
        throw new Error(`Configuration not found: ${path}`);
      }
    }
    
    return value;
  }

  /**
   * Override configuration value
   * @param {string} path - Dot-separated path
   * @param {any} value - New value
   */
  set(path, value) {
    const keys = path.split('.');
    const lastKey = keys.pop();
    let target = this;
    
    for (const key of keys) {
      if (!target[key]) {
        target[key] = {};
      }
      target = target[key];
    }
    
    target[lastKey] = value;
    this.debug(`Configuration updated: ${path} =`, value);
  }
}

// Export singleton instance
export const config = new Config();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\config.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\init.js:
// public/js/core/init.js
/**
 * Application initialization logic
 * Sets up initial UI state
 */

import { DOMHelpers } from '../utils/dom.js';

/**
 * Initialize the application UI
 * @param {Object} app - Main app instance
 */
export function initializeApp(app) {
  setupUI(app);
}

/**
 * Set up initial UI state
 * @param {Object} app - Main app instance
 */
function setupUI(app) {
  // Get DOM elements
  const elements = app.dom.getElements({
    query: '#query',
    result: '#result',
    selectionIndicator: '#selectionIndicator',
    deepDiveResponse: '#deepDiveResponse'
  });
  
  // Focus on query input
  elements.query?.focus();
  
  // Set initial result message
  if (elements.result) {
    elements.result.textContent = 'Textchart will appear here.';
  }
  
  // Hide selection UI initially
  app.dom.hideElement(elements.selectionIndicator);
  app.dom.hideElement(elements.deepDiveResponse);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\init.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\state.js:
// public/js/core/state.js
/**
 * Centralized state management for PiText Desktop
 * Manages application state with event emitters for reactivity
 */

export class State {
  constructor() {
    // Core state
    this._state = {
      // Current query and diagram
      currentQuery: '',
      currentDiagramType: null,
      currentDiagramCode: null,
      
      // Selection state
      selectedElement: null,
      selectedText: '',
      
      // UI state
      isGenerating: false,
      isAskingDeepDive: false,
      lastError: null,
      
      // History
      queryHistory: [],
      diagramHistory: [],
      
      // Deep dive
      deepDiveHistory: []
    };
    
    // Event listeners
    this._listeners = {
      'selection-changed': [],
      'query-changed': [],
      'diagram-generated': [],
      'state-changed': [],
      'error-occurred': []
    };
    
    // Initialize from storage if available
    this._loadFromStorage();
  }

  /**
   * Get state value
   * @param {string} key - State key
   * @returns {any} State value
   */
  get(key) {
    return this._state[key];
  }

  /**
   * Set state value
   * @param {string} key - State key
   * @param {any} value - New value
   */
  set(key, value) {
    const oldValue = this._state[key];
    this._state[key] = value;
    
    // Emit state change event
    this._emit('state-changed', { key, value, oldValue });
    
    // Emit specific events
    switch (key) {
      case 'selectedElement':
      case 'selectedText':
        this._emit('selection-changed', {
          element: this._state.selectedElement,
          text: this._state.selectedText
        });
        break;
      case 'currentQuery':
        this._emit('query-changed', value);
        break;
    }
    
    // Save to storage
    this._saveToStorage();
  }

  /**
   * Update multiple state values
   * @param {Object} updates - Object with key-value pairs to update
   */
  update(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      this.set(key, value);
    });
  }

  /**
   * Set current query
   * @param {string} query - Query text
   */
  setQuery(query) {
    this.set('currentQuery', query);
    
    // Add to history
    if (query && !this._state.queryHistory.includes(query)) {
      this._state.queryHistory.unshift(query);
      // Keep only last 20 queries
      if (this._state.queryHistory.length > 20) {
        this._state.queryHistory.pop();
      }
    }
  }

  /**
   * Set diagram data
   * @param {Object} diagramData - Diagram information
   */
  setDiagram(diagramData) {
    const { type, code, query } = diagramData;
    
    this.update({
      currentDiagramType: type,
      currentDiagramCode: code
    });
    
    // Add to history
    this._state.diagramHistory.unshift({
      query,
      type,
      code,
      timestamp: Date.now()
    });
    
    // Keep only last 10 diagrams
    if (this._state.diagramHistory.length > 10) {
      this._state.diagramHistory.pop();
    }
    
    this._emit('diagram-generated', diagramData);
  }

  /**
   * Set selection
   * @param {HTMLElement} element - Selected element
   * @param {string} text - Selected text
   */
  setSelection(element, text) {
    this.update({
      selectedElement: element,
      selectedText: text
    });
  }

  /**
   * Clear selection
   */
  clearSelection() {
    this.update({
      selectedElement: null,
      selectedText: ''
    });
  }

  /**
   * Check if there's an active selection
   * @returns {boolean}
   */
  hasSelection() {
    return Boolean(this._state.selectedText);
  }

  /**
   * Set loading state
   * @param {string} operation - Operation name ('generating', 'askingDeepDive')
   * @param {boolean} isLoading - Loading state
   */
  setLoading(operation, isLoading) {
    switch (operation) {
      case 'generating':
        this.set('isGenerating', isLoading);
        break;
      case 'askingDeepDive':
        this.set('isAskingDeepDive', isLoading);
        break;
    }
  }

  /**
   * Set error state
   * @param {Error|string|null} error - Error object or message
   */
  setError(error) {
    const errorData = error ? {
      message: error.message || String(error),
      timestamp: Date.now(),
      stack: error.stack
    } : null;
    
    this.set('lastError', errorData);
    
    if (errorData) {
      this._emit('error-occurred', errorData);
    }
  }

  /**
   * Add deep dive to history
   * @param {Object} deepDiveData - Deep dive information
   */
  addDeepDive(deepDiveData) {
    this._state.deepDiveHistory.unshift({
      ...deepDiveData,
      timestamp: Date.now()
    });
    
    // Keep only last 20 deep dives
    if (this._state.deepDiveHistory.length > 20) {
      this._state.deepDiveHistory.pop();
    }
  }

  /**
   * Get query suggestions based on history
   * @param {string} partial - Partial query
   * @returns {string[]} Suggested queries
   */
  getQuerySuggestions(partial) {
    if (!partial) return [];
    
    const lowerPartial = partial.toLowerCase();
    return this._state.queryHistory
      .filter(q => q.toLowerCase().includes(lowerPartial))
      .slice(0, 5);
  }

  /**
   * Subscribe to state events
   * @param {string} event - Event name
   * @param {Function} callback - Callback function
   * @returns {Function} Unsubscribe function
   */
  on(event, callback) {
    if (!this._listeners[event]) {
      throw new Error(`Unknown event: ${event}`);
    }
    
    this._listeners[event].push(callback);
    
    // Return unsubscribe function
    return () => {
      const index = this._listeners[event].indexOf(callback);
      if (index > -1) {
        this._listeners[event].splice(index, 1);
      }
    };
  }

  /**
   * Emit event to listeners
   * @private
   * @param {string} event - Event name
   * @param {any} data - Event data
   */
  _emit(event, data) {
    if (this._listeners[event]) {
      this._listeners[event].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in ${event} listener:`, error);
        }
      });
    }
  }

  /**
   * Save state to localStorage
   * @private
   */
  _saveToStorage() {
    try {
      const toSave = {
        queryHistory: this._state.queryHistory,
        diagramHistory: this._state.diagramHistory.slice(0, 5), // Only save recent 5
        deepDiveHistory: this._state.deepDiveHistory.slice(0, 5)
      };
      
      localStorage.setItem('pitext_state', JSON.stringify(toSave));
    } catch (error) {
      console.warn('Failed to save state:', error);
    }
  }

  /**
   * Load state from localStorage
   * @private
   */
  _loadFromStorage() {
    try {
      const saved = localStorage.getItem('pitext_state');
      if (saved) {
        const data = JSON.parse(saved);
        Object.assign(this._state, data);
      }
    } catch (error) {
      console.warn('Failed to load state:', error);
    }
  }

  /**
   * Clear all state and storage
   */
  reset() {
    // Reset to initial state
    this._state = {
      currentQuery: '',
      currentDiagramType: null,
      currentDiagramCode: null,
      selectedElement: null,
      selectedText: '',
      isGenerating: false,
      isAskingDeepDive: false,
      lastError: null,
      queryHistory: [],
      diagramHistory: [],
      deepDiveHistory: []
    };
    
    // Clear storage
    localStorage.removeItem('pitext_state');
    
    // Emit reset event
    this._emit('state-changed', { reset: true });
  }

  /**
   * Get current state snapshot
   * @returns {Object} Copy of current state
   */
  getSnapshot() {
    return JSON.parse(JSON.stringify(this._state));
  }
}

// Export singleton instance for convenience
export const state = new State();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\core\state.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\diagram\generator.js:
// public/js/diagram/generator.js
/**
 * Diagram generation orchestration – from query to rendered diagram.
 */

import { DiagramUtilities } from './utilities.js';
import { Helpers } from '../utils/helpers.js';

export class DiagramGenerator {
  constructor(api, mermaid, state, dom) {
    this.api = api;
    this.mermaid = mermaid;
    this.state = state;
    this.dom = dom;
    this.utilities = new DiagramUtilities();
    this.helpers = new Helpers();

    // Retry settings
    this.retryCount = 0;
    this.maxRetries = 3;
  }

  /**
   * Generate a diagram from the user query.
   * @param {string}  query     User's request
   * @param {boolean} isRetry   Internal flag (do not supply manually)
   **/
  async generate(query, isRetry = false) {
      const resultContainer = document.getElementById('result');

      // Reset counter only on the very first attempt
      if (!isRetry) this.retryCount = 0;

      // House‑keeping
      this.state.setQuery(query);
      this.state.setLoading('generating', true);
      this.state.setError(null);
      this._showLoading(resultContainer);

      // Ensure no leftover styling from previous diagrams
      resultContainer.classList.remove('sequence-wide');

      try {
          const response = await this.api.generateDiagram(query);

          if (!response.success) {
              throw new Error(response.detail || 'Generation failed');
          }

          // Apply width tweak for sequence‑comparison diagrams only
          if (response.diagram_type === 'sequence_comparison') {
              resultContainer.classList.add('sequence-wide');
          }

          // Store diagram in the state
          this.state.setDiagram({
              type: response.diagram_type,
              code: response.diagram,
              query,
          });

          const ok = await this._renderDiagram(response.diagram, resultContainer);

          if (!ok) {
              // DON'T retry the entire generation - just fail
              throw new Error('Failed to render diagram');
          }

          // Success – augment the SVG
          this._enhanceDiagram(resultContainer);
      } catch (err) {
          console.error('Generation error:', err);
          this.state.setError(err);
          this._showError(resultContainer, err);
      } finally {
          this.state.setLoading('generating', false);
      }
  }
  // -------------------------------------------------------------------------
  // Internal helpers
  // -------------------------------------------------------------------------

  /**
   * Attempt to render Mermaid code.
   * @returns {Promise<boolean>} true on success, false on failure
   */
  async _renderDiagram(code, container) {
    try {
      const cleaned = this.mermaid.cleanCode(code);
      const validation = this.mermaid.validateCode(cleaned);
      if (!validation.isValid) {
        console.warn('Diagram validation failed:', validation.errors);
      }

      const rendered = await this.mermaid.render(cleaned, container);
      if (!rendered) return false;

      this._fixArrowVisibility(container);
      return true;
    } catch (err) {
      console.error('Render error:', err);
      console.log('Sanitised Mermaid code:\n', code);
      return false;
    }
  }

  _showLoading(container) {
    container.innerHTML = `
      <div class="loading-state">
        <div class="loading-spinner"></div>
        <div class="loading-text">Generating textchart...</div>
        <div class="loading-tip">This may take a few seconds</div>
      </div>
    `;
    this._addLoadingAnimation();
  }

  _showError(container, error) {
    const userMessage = error.getUserMessage
      ? error.getUserMessage()
      : this.helpers.getErrorMessage(error);

    container.innerHTML = `
      <div class="error-message">
        <div class="error-icon">⚠️</div>
        <div class="error-text">${userMessage}</div>
        <button class="retry-btn" id="retryBtn">Try Again</button>
        <div class="error-details">
          <details>
            <summary>Technical details</summary>
            <pre>${error.message}</pre>
          </details>
        </div>
      </div>
    `;

    const retryBtn = container.querySelector('#retryBtn');
    if (retryBtn) {
      retryBtn.onclick = () => {
        const q = this.state.get('currentQuery');
        if (q) this.generate(q);
      };
    }
  }

  _enhanceDiagram(container) {
    this.utilities.addButtons(container);
    this._makeInteractive(container);

    if (this._isDiagramLarge(container)) {
      this.utilities.addZoomControls(container);
    }

    this.currentContainer = container;
  }

  _makeInteractive(container) {
    const svg = container.querySelector('svg');
    if (!svg) return;

    const nodes = svg.querySelectorAll('g.node, .node');
    nodes.forEach((node) => {
      node.style.cursor = 'pointer';
      node.addEventListener('mouseenter', () =>
        node.classList.add('node-hover')
      );
      node.addEventListener('mouseleave', () =>
        node.classList.remove('node-hover')
      );
    });

    const edgeLabels = svg.querySelectorAll('.edgeLabel');
    edgeLabels.forEach((label) => (label.style.cursor = 'pointer'));
  }

  _fixArrowVisibility(container) {
    setTimeout(() => {
      const svg = container.querySelector('svg');
      if (!svg) return;

      const paths = svg.querySelectorAll('path');
      paths.forEach((p) => {
        const d = p.getAttribute('d');
        if (d && d.includes('M') && d.includes('L')) {
          p.setAttribute('stroke', '#000000');
          p.setAttribute('stroke-width', '4');
          p.setAttribute('fill', 'none');
          p.style.filter = 'drop-shadow(0 0 3px rgba(255,255,255,0.9))';
        }
      });

      const markers = svg.querySelectorAll('marker path, marker polygon');
      markers.forEach((m) => {
        m.setAttribute('fill', '#000000');
        m.setAttribute('stroke', '#ffffff');
        m.setAttribute('stroke-width', '2');
      });

      const edgePaths = svg.querySelectorAll('g.edgePath path, .edgePath path');
      edgePaths.forEach((e) => {
        e.setAttribute('stroke', '#000000');
        e.setAttribute('stroke-width', '4');
        e.setAttribute('fill', 'none');
        e.style.filter = 'drop-shadow(0 0 3px rgba(255,255,255,0.9))';
      });
    }, 50);
  }

  _isDiagramLarge(container) {
    const svg = container.querySelector('svg');
    if (!svg) return false;

    const vb = svg.getAttribute('viewBox');
    if (!vb) return false;

    const [, , w, h] = vb.split(' ').map(Number);
    return w > 1000 || h > 1000;
  }

  _addLoadingAnimation() {
    if (document.getElementById('generator-loading-styles')) return;

    const style = document.createElement('style');
    style.id = 'generator-loading-styles';
    style.textContent = `
      .loading-state{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:300px;gap:1rem}
      .loading-spinner{width:40px;height:40px;border:3px solid rgba(255,255,255,0.3);border-top-color:#fff;border-radius:50%;animation:spin 1s linear infinite}
      .loading-text{font-size:18px;color:#fff}
      .loading-tip{font-size:14px;color:rgba(255,255,255,0.7)}
      @keyframes spin{to{transform:rotate(360deg)}}
      .node-hover rect,
      .node-hover circle,
      .node-hover ellipse{stroke-width:3px!important;filter:brightness(1.1)}
    `;
    document.head.appendChild(style);
  }

  /**
   * Export the diagram in PNG, SVG or Mermaid form.
   */
  async exportDiagram(format) {
    if (!this.currentContainer) {
      throw new Error('No diagram to export');
    }

    const svg = this.currentContainer.querySelector('svg');
    if (!svg && format !== 'mermaid') {
      throw new Error('No SVG found to export');
    }

    switch (format) {
      case 'png':
        await this.utilities.exportAsPNG(svg);
        break;
      case 'svg':
        await this.utilities.exportAsSVG(svg);
        break;
      case 'mermaid': {
        const code = this.state.get('currentDiagramCode');
        await this.utilities.exportAsMermaid(code);
        break;
      }
      default:
        throw new Error(`Unknown export format: ${format}`);
    }
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\diagram\generator.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\diagram\mermaid.js:
// public/js/diagram/mermaid.js
/**
 * Mermaid diagram management
 * Handles initialization, rendering, and error recovery
 */

export class MermaidManager {
  constructor() {
    this.isReady = false;
    this.mermaid = null;
    this.initPromise = null;
    this.renderCount = 0;
  }

  /**
   * Wait for Mermaid to be available on window
   * @returns {Promise} Resolves when Mermaid is ready
   */
  async waitForReady() {
    if (this.isReady) {
      return this.mermaid;
    }

    if (this.initPromise) {
      return this.initPromise;
    }

    this.initPromise = this._initialize();
    return this.initPromise;
  }

  /**
   * Initialize Mermaid
   * @private
   * @returns {Promise} Resolves when initialized
   */
  async _initialize() {
    console.log('🔄 Waiting for Mermaid...');

    // Wait for Mermaid to appear on window
    this.mermaid = await this._waitForGlobal('mermaid', 10000);
    
    if (!this.mermaid) {
      throw new Error('Mermaid failed to load');
    }

    // Configure Mermaid
    const config = this._getMermaidConfig();
    this.mermaid.initialize(config);
    
    this.isReady = true;
    console.log('✅ Mermaid initialized');
    
    return this.mermaid;
  }

  /**
   * Wait for a global variable to be defined
   * @private
   * @param {string} name - Variable name
   * @param {number} timeout - Timeout in ms
   * @returns {Promise} Resolves with the variable value
   */
  _waitForGlobal(name, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      const check = () => {
        if (window[name]) {
          resolve(window[name]);
          return;
        }
        
        if (Date.now() - startTime > timeout) {
          reject(new Error(`Timeout waiting for ${name}`));
          return;
        }
        
        setTimeout(check, 100);
      };
      
      check();
    });
  }

  /**
   * Get Mermaid configuration
   * @private
   * @returns {Object} Mermaid config
   */
  _getMermaidConfig() {
    // Import config from our config module
    return {
      startOnLoad: false,
      theme: 'base',
      fontFamily: 'Arial, sans-serif',
      fontSize: '13px',
      securityLevel: 'loose',
      logLevel: 'error',
      flowchart: {
        htmlLabels: false,
        wrap: true,
        useMaxWidth: true,
        nodeSpacing: 50,
        rankSpacing: 50,
        curve: 'basis'
      },
      themeVariables: {
        primaryColor: '#ffffff',
        primaryTextColor: '#000000',
        primaryBorderColor: '#000000',
        lineColor: '#000000',
        arrowheadColor: '#000000',
        edgeLabelBackground: '#ffffff',
        defaultLinkColor: '#000000'
      }
    };
  }

  /**
   * Render a Mermaid diagram
   * @param {string} code - Mermaid diagram code
   * @param {HTMLElement} container - Container element
   * @returns {Promise<boolean>} Success status
   */
async render(code, container) {
    if (!this.isReady) {
        await this.waitForReady();
    }

    // Clear container
    container.innerHTML = '';
    
    // Create diagram element
    const diagramId = `mermaid-${++this.renderCount}`;
    const diagramDiv = document.createElement('div');
    diagramDiv.className = 'mermaid';
    diagramDiv.id = diagramId;
    diagramDiv.textContent = code;
    
    container.appendChild(diagramDiv);

    try {
        // Remove any existing diagrams with same ID
        this.mermaid.contentLoaded();
        
        // Render the diagram
        this.mermaid.init(undefined, diagramDiv);
        
        // Wait a bit for rendering to complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Check for rendering success
        const success = await this._checkRenderSuccess(container);
        
        if (!success) {
            throw new Error('Diagram rendering failed');
        }
        
        return true;
        
    } catch (error) {
        console.error('Mermaid render error:', error);
        this._handleRenderError(container, error);
        return false;
    }
}
  /**
   * Check if diagram rendered successfully
   * @private
   * @param {HTMLElement} container - Container element
   * @returns {Promise<boolean>} Success status
   */
  async _checkRenderSuccess(container) {
    // Wait a bit for rendering to complete
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Check for SVG
    const svg = container.querySelector('svg');
    if (!svg) {
      return false;
    }
    
    // Check for error indicators
    const errorElements = container.querySelectorAll(
      '.mermaidError, [data-mermaid-error], .error'
    );
    if (errorElements.length > 0) {
      return false;
    }
    
    // Check for error text
    const text = container.textContent || '';
    const hasError = /syntax error|error in text|parse error/i.test(text);
    
    return !hasError;
  }

  /**
   * Handle render error
   * @private
   * @param {HTMLElement} container - Container element
   * @param {Error} error - Error object
   */
  _handleRenderError(container, error) {
    const errorMessage = this._extractErrorMessage(error);
    
    container.innerHTML = `
      <div class="mermaid-error">
        <div class="error-icon">⚠️</div>
        <div class="error-title">Diagram Error</div>
        <div class="error-message">${errorMessage}</div>
        <div class="error-hint">Please try regenerating with a different query.</div>
      </div>
    `;
  }

  /**
   * Extract user-friendly error message
   * @private
   * @param {Error} error - Error object
   * @returns {string} Error message
   */
  _extractErrorMessage(error) {
    const message = error.message || String(error);
    
    // Common Mermaid errors
    if (message.includes('Parse error')) {
      return 'The diagram syntax is invalid.';
    }
    
    if (message.includes('Syntax error')) {
      return 'There is a syntax error in the diagram.';
    }
    
    if (message.includes('No diagram type detected')) {
      return 'The diagram type could not be determined.';
    }
    
    // Generic message
    return 'Failed to render the diagram.';
  }

  /**
   * Parse Mermaid code to extract diagram type
   * @param {string} code - Mermaid diagram code
   * @returns {string|null} Diagram type
   */
  parseDiagramType(code) {
    const firstLine = code.trim().split('\n')[0];
    
    // Common diagram types
    if (firstLine.includes('flowchart')) return 'flowchart';
    if (firstLine.includes('sequenceDiagram')) return 'sequence';
    if (firstLine.includes('gantt')) return 'gantt';
    if (firstLine.includes('pie')) return 'pie';
    if (firstLine.includes('graph')) return 'graph';
    if (firstLine.includes('stateDiagram')) return 'state';
    if (firstLine.includes('journey')) return 'journey';
    if (firstLine.includes('gitGraph')) return 'git';
    
    return null;
  }

  /**
   * Validate Mermaid code
   * @param {string} code - Mermaid diagram code
   * @returns {Object} Validation result
   */
  validateCode(code) {
    const result = {
      isValid: true,
      errors: []
    };
    
    // Check if empty
    if (!code || !code.trim()) {
      result.isValid = false;
      result.errors.push('Diagram code is empty');
      return result;
    }
    
    // Check for basic structure
    const lines = code.trim().split('\n');
    if (lines.length < 2) {
      result.isValid = false;
      result.errors.push('Diagram appears incomplete');
    }
    
    // Check for diagram type
    const type = this.parseDiagramType(code);
    if (!type && !code.includes('%%')) {
      result.isValid = false;
      result.errors.push('No valid diagram type found');
    }
    
    // Check for common syntax errors
    const openBrackets = (code.match(/\[/g) || []).length;
    const closeBrackets = (code.match(/\]/g) || []).length;
    if (openBrackets !== closeBrackets) {
      result.isValid = false;
      result.errors.push('Mismatched brackets');
    }
    
    const openParens = (code.match(/\(/g) || []).length;
    const closeParens = (code.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      result.isValid = false;
      result.errors.push('Mismatched parentheses');
    }
    
    return result;
  }

  /**
   * Clean and prepare Mermaid code
   * @param {string} code - Raw Mermaid code
   * @returns {string} Cleaned code
   */
  cleanCode(code) {
    // Remove markdown code fences if present
    code = code.replace(/^```mermaid\s*/i, '');
    code = code.replace(/```\s*$/, '');
    
    // Ensure proper line endings
    code = code.replace(/\r\n/g, '\n');
    
    // Trim each line but preserve structure
    const lines = code.split('\n').map(line => line.trimEnd());
    
    // Remove empty lines at start and end
    while (lines.length > 0 && lines[0] === '') {
      lines.shift();
    }
    while (lines.length > 0 && lines[lines.length - 1] === '') {
      lines.pop();
    }
    
    return lines.join('\n');
  }

  /**
   * Reset Mermaid state
   */
  reset() {
    if (this.mermaid) {
      this.mermaid.contentLoaded();
    }
    this.renderCount = 0;
  }
}

// Export singleton instance
export const mermaidManager = new MermaidManager();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\diagram\mermaid.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\diagram\utilities.js:
/**
 * public/js/diagram/utilities.js
 *
 * Diagram utility functions
 * Handles Copy, Save, Export, and Zoom functionality
 */

import { state } from '../core/state.js';

export class DiagramUtilities {
  constructor() {
    this.zoomLevel = 1;
    this.minZoom = 0.5;
    this.maxZoom = 3;
    this.zoomStep = 0.25;
  }

  /**
   * Add utility buttons to diagram container
   * @param {HTMLElement} container - Diagram container
   */
  addButtons(container) {
    // Prevent duplicate buttons
    if (container.querySelector('.diagram-utils')) return;

    const utils = document.createElement('div');
    utils.className = 'diagram-utils';

    // Copy button: export visible text as .txt
    const copyBtn = this._createButton('Save txt', 'copy-icon', () => {
      this.exportVisibleText(container);
    });

    // Save PNG button: export diagram as PNG
    const saveBtn = this._createButton('Save PNG', 'save-icon', () => {
      const svg = container.querySelector('svg');
      if (svg) this.exportAsPNG(svg);
    });

    // Append only Copy and Save buttons
    utils.appendChild(copyBtn);
    utils.appendChild(saveBtn);

    // Insert at top of container
    container.insertBefore(utils, container.firstChild);
  }

  /**
   * Add zoom controls to diagram
   * @param {HTMLElement} container - Diagram container
   */
  addZoomControls(container) {
    // Check if controls already exist
    if (container.querySelector('.zoom-controls')) return;
    
    const controls = document.createElement('div');
    controls.className = 'zoom-controls';
    
    // Zoom out button
    const zoomOutBtn = this._createButton('-', 'zoom-out', () => {
      this.zoom(container, this.zoomLevel - this.zoomStep);
    });
    
    // Zoom level display
    const zoomDisplay = document.createElement('span');
    zoomDisplay.className = 'zoom-level';
    zoomDisplay.textContent = '100%';
    this.zoomDisplay = zoomDisplay;
    
    // Zoom in button
    const zoomInBtn = this._createButton('+', 'zoom-in', () => {
      this.zoom(container, this.zoomLevel + this.zoomStep);
    });
    
    // Reset zoom button
    const resetBtn = this._createButton('Reset', 'zoom-reset', () => {
      this.zoom(container, 1);
    });
    
    controls.appendChild(zoomOutBtn);
    controls.appendChild(zoomDisplay);
    controls.appendChild(zoomInBtn);
    controls.appendChild(resetBtn);
    
    container.appendChild(controls);
    
    // Add mouse wheel zoom
    this._addWheelZoom(container);
  }

  /**
   * Export diagram as PNG
   * @param {SVGElement} svg - SVG element
   */
  async exportAsPNG(svg) {
    if (!svg) return;
    
    try {
      const blob = await this._svgToBlob(svg, 'png');
      this._downloadBlob(blob, this._getFilename('png'));
      this._showNotification('PNG exported successfully!', 'success');
    } catch (error) {
      console.error('PNG export failed:', error);
      this._showNotification('Failed to export PNG', 'error');
    }
  }

  /**
   * MODIFIED: This function now extracts visible text from the diagram
   * and downloads it as a .txt file.
   * @param {HTMLElement} container - Diagram container
   */
  async exportVisibleText(container) {
    const svg = container.querySelector('svg');
    if (!svg) {
      this._showNotification('No diagram found to copy text from.', 'error');
      return;
    }

    // Get the original query from the state
    const currentQuery = state.get('currentQuery') || 'No query found';

    // Query all <text> elements for labels
    const textNodes = svg.querySelectorAll('text');
    const extractedLines = [];

    textNodes.forEach(node => {
      const line = node.textContent?.trim();
      if (line) {
        extractedLines.push(line.replace(/\s+/g, ' '));
      }
    });

    // Remove duplicates
    const uniqueLines = [...new Set(extractedLines)];

    if (uniqueLines.length === 0) {
      this._showNotification('Could not find any text in the diagram.', 'warning');
      return;
    }

    // Prepend the query to the content
    const fileContent = `Query: ${currentQuery}\n\n---\n\n${uniqueLines.join('\n')}`;

    try {
      const blob = new Blob([fileContent], { type: 'text/plain;charset=utf-8' });
      this._downloadBlob(blob, this._getFilename('txt'));
      this._showNotification('Diagram text and query downloaded!', 'success');
    } catch (error) {
      console.error('Text export failed:', error);
      this._showNotification('Failed to download diagram text.', 'error');
    }
  }

  /**
   * Zoom diagram
   * @param {HTMLElement} container - Diagram container
   * @param {number} level - Zoom level
   */
  zoom(container, level) {
    level = Math.max(this.minZoom, Math.min(this.maxZoom, level));
    this.zoomLevel = level;
    
    const svg = container.querySelector('svg');
    if (!svg) return;
    
    svg.style.transform = `scale(${level})`;
    svg.style.transformOrigin = 'center';
    
    if (this.zoomDisplay) {
      this.zoomDisplay.textContent = `${Math.round(level * 100)}%`;
    }
    
    if (level !== 1) {
      container.classList.add('diagram-zoomed');
    } else {
      container.classList.remove('diagram-zoomed');
    }
  }

  /**
   * Convert SVG to blob for download
   * @private
   * @param {SVGElement} svg - SVG element
   * @param {string} format - Output format ('png' or 'webp')
   * @returns {Promise<Blob>}
   */
  async _svgToBlob(svg, format = 'png') {
    const clone = svg.cloneNode(true);
    const viewBox = (clone.getAttribute('viewBox') || '').split(' ').map(Number);
    let width, height;

    if (viewBox.length === 4) {
      [ , , width, height ] = viewBox;
    } else {
      const bbox = svg.getBBox();
      width = bbox.width;
      height = bbox.height;
      clone.setAttribute('viewBox', `0 0 ${width} ${height}`);
    }

    const scale = 4;
    clone.setAttribute('width', width * scale);
    clone.setAttribute('height', height * scale);
    
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('width', '100%');
    rect.setAttribute('height', '100%');
    rect.setAttribute('fill', 'white');
    clone.insertBefore(rect, clone.firstChild);
    
    const svgString = new XMLSerializer().serializeToString(clone);
    const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = width * scale;
        canvas.height = height * scale;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(blob => {
          URL.revokeObjectURL(url);
          resolve(blob);
        }, `image/${format}`, 0.95);
      };
      img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Failed to load SVG')); };
      img.src = url;
    });
  }

  /**
   * Download blob as file
   * @private
   * @param {Blob} blob - File blob
   * @param {string} filename - File name
   */
  _downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 250);
  }

  /**
   * Generate filename with timestamp
   * @private
   * @param {string} extension - File extension
   * @returns {string}
   */
  _getFilename(extension) {
    const date = new Date();
    const timestamp = date.toISOString().replace(/[:.]/g, '-').slice(0, -5);
    return `pitext-diagram-${timestamp}.${extension}`;
  }

  /**
   * Create button element
   * @private
   * @param {string} text - Button text
   * @param {string} className - CSS class
   * @param {Function} onClick - Click handler
   * @returns {HTMLElement}
   */
  _createButton(text, className, onClick) {
    const button = document.createElement('button');
    button.textContent = text;
    button.className = `diagram-btn ${className}`;
    button.onclick = onClick;
    return button;
  }

  /**
   * Add mouse wheel zoom
   * @private
   * @param {HTMLElement} container - Diagram container
   */
  _addWheelZoom(container) {
    container.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -this.zoomStep : this.zoomStep;
        this.zoom(container, this.zoomLevel + delta);
      }
    });
  }

  /**
   * Show notification
   * @private
   * @param {string} message - Notification message
   * @param {string} type - Notification type
   */
  _showNotification(message, type = 'info') {
    if (window.piTextApp?.dom) {
      window.piTextApp.dom.showNotification(message, type);
      return;
    }
    console.log(`[${type.toUpperCase()}] ${message}`);
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\diagram\utilities.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\selection\deepdive.js:
// public/js/selection/deepdive.js
/**
 * Deep dive functionality for selected diagram elements
 * Handles Q&A interactions about selected content
 */

export class DeepDive {
  constructor(api, state, dom) {
    this.api = api;
    this.state = state;
    this.dom = dom;
    this.responseContainer = null;
    this.queryInput = null;
    this.isProcessing = false;
  }

  /**
   * Initialize deep dive UI elements
   */
  init() {
    this.responseContainer = document.getElementById('deepDiveResponse');
    this.queryInput = document.getElementById('deepDiveQuery');
    
    if (!this.responseContainer || !this.queryInput) {
      console.warn('Deep dive UI elements not found');
    }
  }

  /**
   * Ask a question about the selected content
   * @param {string} question - User's question
   * @returns {Promise<void>}
   */
  async ask(question) {
    // Validate inputs
    if (!question || !question.trim()) {
      this.dom.showNotification('Please enter a question', 'warning');
      return;
    }
    
    const selectedText = this.state.get('selectedText');
    if (!selectedText) {
      this.dom.showNotification('Please select something first', 'info');
      return;
    }
    
    // Prevent concurrent requests
    if (this.isProcessing) {
      return;
    }
    
    this.isProcessing = true;
    this.state.setLoading('askingDeepDive', true);
    
    try {
      // Show loading state
      this._showLoading();
      
      // Make API request
      const response = await this.api.getDeepDive({
        selectedText: selectedText,
        question: question,
        originalQuery: this.state.get('currentQuery') || ''
      });
      
      // Validate response
      if (!response.success) {
        throw new Error(response.detail || 'Failed to get response');
      }
      
      // Display response
      this._displayResponse(selectedText, question, response.response);
      
      // Add to history
      this.state.addDeepDive({
        selectedText,
        question,
        response: response.response
      });
      
      // Clear input
      if (this.queryInput) {
        this.queryInput.value = '';
      }
      
    } catch (error) {
      console.error('Deep dive error:', error);
      this._showError(error);
      
    } finally {
      this.isProcessing = false;
      this.state.setLoading('askingDeepDive', false);
    }
  }

  /**
   * Display deep dive response
   * @private
   * @param {string} selectedText - Selected text
   * @param {string} question - User's question
   * @param {string} response - API response
   */
// pitext-desktop/public/js/selection/deepdive.js

  _displayResponse(selectedText, question, response) {
    if (!this.responseContainer) {
      this.responseContainer = document.getElementById('deepDiveResponse');
    }
    
    // Format the response
    const html = `
      <div class="deep-dive-content">
        <button class="close-btn" onclick="window.piTextApp.deepDive.close()">×</button>
        <div class="deep-dive-header">
          <h3>Deep Dive: ${this._escapeHtml(this._truncate(selectedText, 50))}</h3>
        </div>
        
        <div class="deep-dive-qa">
          <div class="answer">
            ${this._formatResponse(response)}
          </div>
        </div>
        
        <div class="deep-dive-actions">
          <button class="action-btn copy-btn" onclick="window.piTextApp.deepDive.copyResponse()">
            Copy Answer
          </button>
          <button class="action-btn save-btn" onclick="window.piTextApp.deepDive.saveResponse()">
            Save as TXT
          </button>
          <button class="action-btn ask-followup-btn" onclick="window.piTextApp.deepDive.focusInput()">
            Ask Follow-up
          </button>
        </div>
        
        <div class="deep-dive-history">
          <details>
            <summary>Previous questions (${this._getHistoryCount()})</summary>
            <div class="history-list">
              ${this._renderHistory()}
            </div>
          </details>
        </div>
      </div>
    `;
    
    this.responseContainer.innerHTML = html;
    this.dom.showElement(this.responseContainer);
    
    // Store current response for actions
    this.currentResponse = {
      selectedText,
      question,
      response
    };
    
    // Animate in
    this._animateIn();
  }
  /**
   * Show loading state
   * @private
   */
  _showLoading() {
    if (!this.responseContainer) return;
    
    this.responseContainer.innerHTML = `
      <div class="deep-dive-loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Diving deep...</div>
      </div>
    `;
    
    this.dom.showElement(this.responseContainer);
  }

  /**
   * Show error state
   * @private
   * @param {Error} error - Error object
   */
  _showError(error) {
    if (!this.responseContainer) return;
    
    const userMessage = error.getUserMessage 
      ? error.getUserMessage() 
      : 'Failed to get response. Please try again.';
    
    this.responseContainer.innerHTML = `
      <div class="deep-dive-error">
        <div class="error-icon">⚠️</div>
        <div class="error-message">${userMessage}</div>
        <button class="retry-btn" onclick="window.piTextApp.deepDive.retry()">
          Try Again
        </button>
      </div>
    `;
    
    this.dom.showElement(this.responseContainer);
  }

  /**
   * Format response text
   * @private
   * @param {string} response - Raw response text
   * @returns {string} Formatted HTML
   */
  _formatResponse(response) {
    // Escape HTML first
    let formatted = this._escapeHtml(response);
    
    // Convert line breaks to paragraphs
    const paragraphs = formatted.split('\n\n').filter(p => p.trim());
    formatted = paragraphs.map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('');
    
    // Add syntax highlighting for code blocks
    formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Make lists look better
    formatted = formatted.replace(/^- (.+)$/gm, '<li>$1</li>');
    formatted = formatted.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
    
    // Highlight key terms from the selected text
    const terms = this._extractKeyTerms(this.state.get('selectedText'));
    terms.forEach(term => {
      const regex = new RegExp(`\\b(${term})\\b`, 'gi');
      formatted = formatted.replace(regex, '<mark>$1</mark>');
    });
    
    return formatted;
  }

  /**
   * Copy current response to clipboard
   */
  async copyResponse() {
    if (!this.currentResponse) return;
    
    const text = `Q: ${this.currentResponse.question}\n\nA: ${this.currentResponse.response}`;
    
    try {
      await navigator.clipboard.writeText(text);
      this.dom.showNotification('Answer copied to clipboard!', 'success');
    } catch (error) {
      console.error('Copy failed:', error);
      this.dom.showNotification('Failed to copy answer', 'error');
    }
  }

  /**
   * Save current response as text file
   */
  saveResponse() {
    if (!this.currentResponse) return;
    
    const content = [
      `Deep Dive: ${this.currentResponse.selectedText}`,
      '=' .repeat(50),
      '',
      `Q: ${this.currentResponse.question}`,
      '',
      `A: ${this.currentResponse.response}`,
      '',
      '---',
      `Generated on: ${new Date().toLocaleString()}`
    ].join('\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `deep-dive-${Date.now()}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.dom.showNotification('Response saved!', 'success');
  }

  /**
   * Focus on input for follow-up question
   */
  focusInput() {
    if (this.queryInput) {
      this.queryInput.focus();
      this.queryInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  /**
   * Close deep dive panel
   */
  close() {
    if (this.responseContainer) {
      this._animateOut(() => {
        this.dom.hideElement(this.responseContainer);
        this.currentResponse = null;
      });
    }
  }

  /**
   * Retry last question
   */
  retry() {
    if (this.queryInput && this.queryInput.value) {
      this.ask(this.queryInput.value);
    }
  }

  /**
   * Get history count for current selection
   * @private
   * @returns {number}
   */
  _getHistoryCount() {
    const selectedText = this.state.get('selectedText');
    const history = this.state.get('deepDiveHistory') || [];
    
    return history.filter(item => 
      item.selectedText === selectedText
    ).length;
  }

  /**
   * Render history for current selection
   * @private
   * @returns {string} HTML
   */
  _renderHistory() {
    const selectedText = this.state.get('selectedText');
    const history = this.state.get('deepDiveHistory') || [];
    
    const relevant = history
      .filter(item => item.selectedText === selectedText)
      .slice(0, 5);
    
    if (relevant.length === 0) {
      return '<p class="no-history">No previous questions for this selection</p>';
    }
    
    return relevant.map(item => `
      <div class="history-item" onclick="window.piTextApp.deepDive.loadFromHistory('${item.question}')">
        <div class="history-question">${this._escapeHtml(item.question)}</div>
        <div class="history-time">${this._formatTime(item.timestamp)}</div>
      </div>
    `).join('');
  }

  /**
   * Load question from history
   * @param {string} question - Historical question
   */
  loadFromHistory(question) {
    if (this.queryInput) {
      this.queryInput.value = question;
      this.focusInput();
    }
  }

  /**
   * Extract key terms from text
   * @private
   * @param {string} text - Source text
   * @returns {string[]} Key terms
   */
  _extractKeyTerms(text) {
    // Simple extraction - words longer than 4 chars
    const words = text.split(/\W+/);
    return words
      .filter(w => w.length > 4)
      .map(w => w.toLowerCase())
      .filter((w, i, arr) => arr.indexOf(w) === i) // unique
      .slice(0, 5); // limit to 5 terms
  }

  /**
   * Escape HTML
   * @private
   * @param {string} text - Raw text
   * @returns {string} Escaped text
   */
  _escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Truncate text
   * @private
   * @param {string} text - Text to truncate
   * @param {number} length - Max length
   * @returns {string} Truncated text
   */
  _truncate(text, length) {
    if (text.length <= length) return text;
    return text.substring(0, length) + '...';
  }

  /**
   * Format timestamp
   * @private
   * @param {number} timestamp - Unix timestamp
   * @returns {string} Formatted time
   */
  _formatTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    
    if (diff < 60000) return 'just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)} min ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)} hours ago`;
    
    return date.toLocaleDateString();
  }

  /**
   * Animate panel in
   * @private
   */
  _animateIn() {
    if (!this.responseContainer) return;
    
    this.responseContainer.style.opacity = '0';
    this.responseContainer.style.transform = 'translateY(20px)';
    
    setTimeout(() => {
      this.responseContainer.style.transition = 'all 0.3s ease-out';
      this.responseContainer.style.opacity = '1';
      this.responseContainer.style.transform = 'translateY(0)';
    }, 10);
  }

  /**
   * Animate panel out
   * @private
   * @param {Function} callback - Callback after animation
   */
  _animateOut(callback) {
    if (!this.responseContainer) return;
    
    this.responseContainer.style.transition = 'all 0.2s ease-in';
    this.responseContainer.style.opacity = '0';
    this.responseContainer.style.transform = 'translateY(20px)';
    
    setTimeout(callback, 200);
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\selection\deepdive.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\selection\handler.js:
// public/js/selection/handler.js
/**
 * Selection handler for diagram elements
 * Manages selection of nodes, edges, and text in Mermaid diagrams
 */

export class SelectionHandler {
  constructor(state, dom) {
    this.state = state;
    this.dom = dom;
    this.selectedClass = 'element-selected';
    this.currentContainer = null;
  }

  /**
   * Set up selection handling for a container
   * @param {HTMLElement} container - Diagram container
   */
  setupForContainer(container) {
    this.currentContainer = container;
    const svg = container.querySelector('svg');
    
    if (!svg) {
      console.warn('No SVG found in container');
      return;
    }
    
    // Clear any existing selection
    this.clearSelection();
    
    // Set up different selection types based on diagram type
    const diagramType = this._detectDiagramType(svg);
    
    switch (diagramType) {
      case 'flowchart':
      case 'graph':
        this._setupFlowchartSelection(svg);
        break;
      case 'sequence':
        this._setupSequenceSelection(svg);
        break;
      default:
        this._setupGenericSelection(svg);
    }
    
    // Set up canvas click to deselect
    this._setupCanvasDeselect(svg);
  }

  /**
   * Clear current selection
   */
  clearSelection() {
    // Remove visual selection
    if (this.state.get('selectedElement')) {
      this._removeSelectionStyling(this.state.get('selectedElement'));
    }
    
    // Clear state
    this.state.clearSelection();
    
    // Hide selection UI
    const indicator = document.getElementById('selectionIndicator');
    if (indicator) {
      this.dom.hideElement(indicator);
    }
    
    // Clear deep dive response
    const response = document.getElementById('deepDiveResponse');
    if (response) {
      this.dom.hideElement(response);
    }
  }

  /**
   * Handle element selection
   * @param {Element} element - Selected element
   * @param {string} text - Selected text
   */
  selectElement(element, text) {
    // Clear previous selection
    if (this.state.get('selectedElement')) {
      this._removeSelectionStyling(this.state.get('selectedElement'));
    }
    
    // Apply selection styling
    this._applySelectionStyling(element);
    
    // Update state
    this.state.setSelection(element, text);
    
    // Show selection UI
    this._showSelectionUI(text);
  }

  /**
   * Set up flowchart/graph selection
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupFlowchartSelection(svg) {
    // Nodes
    const nodes = svg.querySelectorAll('g.node, .node');
    nodes.forEach(node => {
      node.style.cursor = 'pointer';
      
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        const text = this._extractNodeText(node);
        if (text) {
          this.selectElement(node, text);
        }
      });
    });
    
    // Edge labels
    const edgeLabels = svg.querySelectorAll('.edgeLabel, g.edgeLabel');
    edgeLabels.forEach(label => {
      label.style.cursor = 'pointer';
      
      label.addEventListener('click', (e) => {
        e.stopPropagation();
        const text = this._extractEdgeText(label);
        if (text) {
          this.selectElement(label, text);
        }
      });
    });
  }

  /**
   * Set up sequence diagram selection
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupSequenceSelection(svg) {
    // Participants/actors
    const actors = svg.querySelectorAll('g.actor, .actor');
    actors.forEach(actor => {
      const text = actor.querySelector('text');
      if (text) {
        text.style.cursor = 'pointer';
        text.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(text, text.textContent.trim());
        });
      }
    });
    
    // Notes and messages
    const notes = svg.querySelectorAll('g.note, .note');
    notes.forEach(note => {
      note.style.cursor = 'pointer';
      
      note.addEventListener('click', (e) => {
        e.stopPropagation();
        const text = this._extractNoteText(note);
        if (text) {
          this.selectElement(note, text);
        }
      });
    });
    
    // Numbered lines in notes
    const tspans = svg.querySelectorAll('tspan');
    tspans.forEach(tspan => {
      const text = (tspan.textContent || '').trim();
      if (/^\d+[\.\)]\s/.test(text)) {
        tspan.style.cursor = 'pointer';
        tspan.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(tspan, text);
        });
      }
    });
    
    // Background rectangles for blocks
    const rects = svg.querySelectorAll('rect');
    rects.forEach(rect => {
      if (this._isSelectableRect(rect)) {
        rect.style.cursor = 'pointer';
        rect.addEventListener('click', (e) => {
          e.stopPropagation();
          const text = this._extractBlockText(rect, svg);
          if (text) {
            this.selectElement(rect, text);
          }
        });
      }
    });
  }

  /**
   * Set up generic selection for other diagram types
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupGenericSelection(svg) {
    // Any text element
    const texts = svg.querySelectorAll('text');
    texts.forEach(text => {
      if (text.textContent.trim()) {
        text.style.cursor = 'pointer';
        text.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(text, text.textContent.trim());
        });
      }
    });
    
    // Any labeled group
    const groups = svg.querySelectorAll('g[id]');
    groups.forEach(group => {
      const text = group.querySelector('text');
      if (text && text.textContent.trim()) {
        group.style.cursor = 'pointer';
        group.addEventListener('click', (e) => {
          e.stopPropagation();
          this.selectElement(group, text.textContent.trim());
        });
      }
    });
  }

  /**
   * Set up canvas deselection
   * @private
   * @param {SVGElement} svg - SVG element
   */
  _setupCanvasDeselect(svg) {
    svg.addEventListener('click', (e) => {
      // Only deselect if clicked on SVG background
      if (e.target === svg || e.target.classList.contains('background')) {
        this.clearSelection();
      }
    });
  }

  /**
   * Apply selection styling to element
   * @private
   * @param {Element} element - Element to style
   */
  _applySelectionStyling(element) {
    element.classList.add(this.selectedClass);
    
    const tagName = element.tagName.toLowerCase();
    
    switch (tagName) {
      case 'text':
      case 'tspan':
        element.style.fontWeight = 'bold';
        element.style.filter = 'drop-shadow(0 0 4px #ffb300)';
        break;
        
      case 'rect':
        element.setAttribute('data-original-stroke', element.getAttribute('stroke') || '');
        element.setAttribute('data-original-stroke-width', element.getAttribute('stroke-width') || '');
        element.setAttribute('stroke', '#ffb300');
        element.setAttribute('stroke-width', '5');
        element.style.filter = 'drop-shadow(0 0 6px #ffb300)';
        break;
        
      case 'g':
        // For groups, highlight the shape inside
        const shape = element.querySelector('rect, circle, ellipse, polygon');
        if (shape) {
          shape.setAttribute('data-original-stroke', shape.getAttribute('stroke') || '');
          shape.setAttribute('data-original-stroke-width', shape.getAttribute('stroke-width') || '');
          shape.setAttribute('stroke', '#ffb300');
          shape.setAttribute('stroke-width', '3');
        }
        // Highlight text
        const text = element.querySelector('text');
        if (text) {
          text.style.fontWeight = 'bold';
        }
        break;
    }
  }

  /**
   * Remove selection styling from element
   * @private
   * @param {Element} element - Element to unstyle
   */
  _removeSelectionStyling(element) {
    if (!element) return;
    
    element.classList.remove(this.selectedClass);
    
    const tagName = element.tagName.toLowerCase();
    
    switch (tagName) {
      case 'text':
      case 'tspan':
        element.style.fontWeight = '';
        element.style.filter = '';
        break;
        
      case 'rect':
        const originalStroke = element.getAttribute('data-original-stroke');
        const originalWidth = element.getAttribute('data-original-stroke-width');
        if (originalStroke !== null) {
          element.setAttribute('stroke', originalStroke);
        }
        if (originalWidth !== null) {
          element.setAttribute('stroke-width', originalWidth);
        }
        element.style.filter = '';
        break;
        
      case 'g':
        // Restore group children
        const shape = element.querySelector('rect, circle, ellipse, polygon');
        if (shape) {
          const origStroke = shape.getAttribute('data-original-stroke');
          const origWidth = shape.getAttribute('data-original-stroke-width');
          if (origStroke !== null) {
            shape.setAttribute('stroke', origStroke);
          }
          if (origWidth !== null) {
            shape.setAttribute('stroke-width', origWidth);
          }
        }
        const text = element.querySelector('text');
        if (text) {
          text.style.fontWeight = '';
        }
        break;
    }
  }

  /**
   * Show selection UI
   * @private
   * @param {string} text - Selected text
   */
  _showSelectionUI(text) {
    const indicator = document.getElementById('selectionIndicator');
    const selectedTextSpan = document.getElementById('selectedText');
    const deepDiveInput = document.getElementById('deepDiveQuery');
    
    if (indicator && selectedTextSpan) {
      selectedTextSpan.textContent = text;
      this.dom.showElement(indicator);
      
      // Focus on deep dive input
      if (deepDiveInput) {
        deepDiveInput.value = '';
        deepDiveInput.focus();
      }
    }
  }

  /**
   * Extract text from node
   * @private
   * @param {Element} node - Node element
   * @returns {string} Extracted text
   */
  _extractNodeText(node) {
    // Try multiple selectors
    const textElement = node.querySelector('text, .nodeLabel, span');
    
    if (textElement) {
      // Handle tspans
      const tspans = textElement.querySelectorAll('tspan');
      if (tspans.length > 0) {
        return Array.from(tspans)
          .map(t => t.textContent.trim())
          .filter(Boolean)
          .join(' ');
      }
      
      return textElement.textContent.trim();
    }
    
    return '';
  }

  /**
   * Extract text from edge label
   * @private
   * @param {Element} label - Edge label element
   * @returns {string} Extracted text
   */
  _extractEdgeText(label) {
    const text = label.querySelector('text, span');
    return text ? text.textContent.trim() : label.textContent.trim();
  }

  /**
   * Extract text from note
   * @private
   * @param {Element} note - Note element
   * @returns {string} Extracted text
   */
  _extractNoteText(note) {
    const texts = note.querySelectorAll('text');
    return Array.from(texts)
      .map(t => t.textContent.trim())
      .filter(Boolean)
      .join('\n');
  }

  /**
   * Extract text from block (sequence diagram)
   * @private
   * @param {Element} rect - Rectangle element
   * @param {SVGElement} svg - SVG container
   * @returns {string} Extracted text
   */
  _extractBlockText(rect, svg) {
    const bbox = rect.getBBox();
    
    // Find all text elements within this rectangle
    const texts = Array.from(svg.querySelectorAll('text')).filter(text => {
      const textBox = text.getBBox();
      return (
        textBox.x >= bbox.x - 5 &&
        textBox.x + textBox.width <= bbox.x + bbox.width + 5 &&
        textBox.y >= bbox.y - 5 &&
        textBox.y + textBox.height <= bbox.y + bbox.height + 5
      );
    });
    
    return texts
      .map(t => t.textContent.trim())
      .filter(Boolean)
      .join('\n');
  }

  /**
   * Check if rect is selectable
   * @private
   * @param {Element} rect - Rectangle element
   * @returns {boolean}
   */
  _isSelectableRect(rect) {
    const fill = rect.getAttribute('fill');
    
    // Skip white/transparent/no fill
    if (!fill || ['#fff', '#ffffff', 'white', 'none', 'transparent'].includes(fill.toLowerCase())) {
      return false;
    }
    
    // Must be reasonably sized
    const width = parseFloat(rect.getAttribute('width')) || 0;
    const height = parseFloat(rect.getAttribute('height')) || 0;
    
    return width > 100 && height > 40;
  }

  /**
   * Detect diagram type from SVG
   * @private
   * @param {SVGElement} svg - SVG element
   * @returns {string} Diagram type
   */
  _detectDiagramType(svg) {
    // Check for specific class names or structures
    if (svg.querySelector('.actor, .note, sequenceDiagram')) {
      return 'sequence';
    }
    if (svg.querySelector('.node, .edgePath, .flowchart')) {
      return 'flowchart';
    }
    if (svg.querySelector('.gantt')) {
      return 'gantt';
    }
    if (svg.querySelector('.pie')) {
      return 'pie';
    }
    
    return 'generic';
  }

  /**
   * Decode HTML entities
   * @param {string} text - Text with entities
   * @returns {string} Decoded text
   */
  decodeEntities(text) {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = text;
    return textarea.value;
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\selection\handler.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\ui\events.js:
// public/js/ui/events.js
/**
 * Event handler setup
 * Sets up all application event listeners
 */

import { setupKeyboardShortcuts } from './shortcuts.js';

/**
 * Set up all event listeners
 * @param {Object} app - Main app instance
 */
// In pitext-desktop/public/js/ui/events.js, update the event listeners:

export function setupEventListeners(app) {
    // Generate button
    const generateBtn = document.getElementById('generateBtn');
    if (generateBtn) {
        generateBtn.addEventListener('click', (e) => {
            e.preventDefault();
            app.handleGenerate();
        });
    }
    
    // Ask button (for deep dive)
    const askBtn = document.getElementById('askBtn');
    if (askBtn) {
        askBtn.addEventListener('click', (e) => {
            e.preventDefault();
            app.handleAsk();
        });
    }
    
    // Enter key on query input
    const queryInput = document.getElementById('query');
    if (queryInput) {
        queryInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                app.handleGenerate();
            }
        });
    }
    
    // Enter key on deep dive input
    const deepDiveInput = document.getElementById('deepDiveQuery');
    if (deepDiveInput) {
        deepDiveInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                app.handleAsk();
            }
        });
    }

    // Example buttons
    const exampleBtns = document.querySelectorAll('.example-btn');
    if (exampleBtns.length && queryInput) {
        exampleBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const queryText = btn.getAttribute('data-query');
                queryInput.value = queryText;
                queryInput.focus();
            });
        });
    }
    
    // Set up keyboard shortcuts
    setupKeyboardShortcuts(app);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\ui\events.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\ui\shortcuts.js:
// public/js/ui/shortcuts.js
/**
 * Keyboard shortcut handlers
 * Sets up global keyboard shortcuts
 */

/**
 * Set up keyboard shortcuts
 * @param {Object} app - Main app instance
 */
export function setupKeyboardShortcuts(app) {
  // Global keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + Enter to generate
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      app.handleGenerate();
    }
    
    // Escape to clear selection
    if (e.key === 'Escape' && app.state.hasSelection()) {
      app.selection.clearSelection();
    }
  });
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\ui\shortcuts.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\utils\dom.js:
// public/js/utils/dom.js
/**
 * DOM manipulation utilities
 * Provides common DOM operations and UI helpers
 */

export class DOMHelpers {
  constructor() {
    this.notificationContainer = null;
    this.notificationTimeout = null;
    this._ensureNotificationContainer();
  }

  /**
   * Get multiple elements by selectors
   * @param {Object} selectors - Object with key: selector pairs
   * @returns {Object} Object with key: element pairs
   */
  getElements(selectors) {
    const elements = {};
    
    Object.entries(selectors).forEach(([key, selector]) => {
      elements[key] = document.querySelector(selector);
      
      if (!elements[key]) {
        console.warn(`Element not found: ${selector}`);
      }
    });
    
    return elements;
  }

  /**
   * Show element with optional animation
   * @param {HTMLElement} element - Element to show
   * @param {string} animation - Animation type ('fade', 'slide', 'none')
   */
  showElement(element, animation = 'fade') {
    if (!element) return;
    
    switch (animation) {
      case 'fade':
        element.style.display = 'block';
        element.style.opacity = '0';
        element.classList.add('active');
        
        // Force reflow
        element.offsetHeight;
        
        element.style.transition = 'opacity 0.3s ease-out';
        element.style.opacity = '1';
        break;
        
      case 'slide':
        element.style.display = 'block';
        element.style.transform = 'translateY(-20px)';
        element.style.opacity = '0';
        element.classList.add('active');
        
        // Force reflow
        element.offsetHeight;
        
        element.style.transition = 'all 0.3s ease-out';
        element.style.transform = 'translateY(0)';
        element.style.opacity = '1';
        break;
        
      default:
        element.style.display = 'block';
        element.classList.add('active');
    }
  }

  /**
   * Hide element with optional animation
   * @param {HTMLElement} element - Element to hide
   * @param {string} animation - Animation type ('fade', 'slide', 'none')
   */
  hideElement(element, animation = 'fade') {
    if (!element) return;
    
    const hide = () => {
      element.style.display = 'none';
      element.classList.remove('active');
    };
    
    switch (animation) {
      case 'fade':
        element.style.transition = 'opacity 0.2s ease-in';
        element.style.opacity = '0';
        setTimeout(hide, 200);
        break;
        
      case 'slide':
        element.style.transition = 'all 0.2s ease-in';
        element.style.transform = 'translateY(-20px)';
        element.style.opacity = '0';
        setTimeout(hide, 200);
        break;
        
      default:
        hide();
    }
  }

  /**
   * Toggle element visibility
   * @param {HTMLElement} element - Element to toggle
   * @param {string} animation - Animation type
   */
  toggleElement(element, animation = 'fade') {
    if (!element) return;
    
    const isVisible = element.classList.contains('active') || 
                     element.style.display !== 'none';
    
    if (isVisible) {
      this.hideElement(element, animation);
    } else {
      this.showElement(element, animation);
    }
  }

  /**
   * Show notification
   * @param {string} message - Notification message
   * @param {string} type - Notification type ('success', 'error', 'warning', 'info')
   * @param {number} duration - Duration in ms (0 for persistent)
   */
  showNotification(message, type = 'info', duration = 3000) {
    this._ensureNotificationContainer();
    
    // Clear existing timeout
    if (this.notificationTimeout) {
      clearTimeout(this.notificationTimeout);
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    
    // Add icon
    const icon = this._getNotificationIcon(type);
    
    // Build content
    notification.innerHTML = `
      <span class="notification-icon">${icon}</span>
      <span class="notification-message">${this._escapeHtml(message)}</span>
      <button class="notification-close" onclick="this.parentElement.remove()">×</button>
    `;
    
    // Add to container
    this.notificationContainer.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.classList.add('notification-show');
    }, 10);
    
    // Auto-remove if duration > 0
    if (duration > 0) {
      this.notificationTimeout = setTimeout(() => {
        this._removeNotification(notification);
      }, duration);
    }
    
    // Click to dismiss
    notification.addEventListener('click', () => {
      this._removeNotification(notification);
    });
  }

  /**
   * Clear all notifications
   */
  clearNotifications() {
    if (this.notificationContainer) {
      this.notificationContainer.innerHTML = '';
    }
  }

  /**
   * Add loading overlay to element
   * @param {HTMLElement} element - Target element
   * @param {string} message - Loading message
   */
  addLoadingOverlay(element, message = 'Loading...') {
    if (!element) return;
    
    // Remove existing overlay
    this.removeLoadingOverlay(element);
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.className = 'loading-overlay';
    overlay.innerHTML = `
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-message">${this._escapeHtml(message)}</div>
      </div>
    `;
    
    // Position relative to element
    element.style.position = 'relative';
    element.appendChild(overlay);
    
    // Animate in
    setTimeout(() => {
      overlay.classList.add('loading-overlay-show');
    }, 10);
  }

  /**
   * Remove loading overlay from element
   * @param {HTMLElement} element - Target element
   */
  removeLoadingOverlay(element) {
    if (!element) return;
    
    const overlay = element.querySelector('.loading-overlay');
    if (overlay) {
      overlay.classList.remove('loading-overlay-show');
      setTimeout(() => overlay.remove(), 200);
    }
  }

  /**
   * Disable element with optional message
   * @param {HTMLElement} element - Element to disable
   * @param {string} message - Optional tooltip message
   */
  disableElement(element, message) {
    if (!element) return;
    
    element.disabled = true;
    element.classList.add('disabled');
    
    if (message) {
      element.setAttribute('title', message);
      element.setAttribute('data-disabled-message', message);
    }
  }

  /**
   * Enable element
   * @param {HTMLElement} element - Element to enable
   */
  enableElement(element) {
    if (!element) return;
    
    element.disabled = false;
    element.classList.remove('disabled');
    element.removeAttribute('title');
    element.removeAttribute('data-disabled-message');
  }

  /**
   * Smooth scroll to element
   * @param {HTMLElement|string} target - Element or selector
   * @param {Object} options - Scroll options
   */
  scrollToElement(target, options = {}) {
    const element = typeof target === 'string' 
      ? document.querySelector(target) 
      : target;
    
    if (!element) return;
    
    const defaultOptions = {
      behavior: 'smooth',
      block: 'center',
      inline: 'nearest'
    };
    
    element.scrollIntoView({ ...defaultOptions, ...options });
  }

  /**
   * Create and show tooltip
   * @param {HTMLElement} element - Target element
   * @param {string} text - Tooltip text
   * @param {string} position - Position ('top', 'bottom', 'left', 'right')
   */
  showTooltip(element, text, position = 'top') {
    if (!element) return;
    
    // Remove existing tooltip
    this.hideTooltip(element);
    
    // Create tooltip
    const tooltip = document.createElement('div');
    tooltip.className = `tooltip tooltip-${position}`;
    tooltip.textContent = text;
    tooltip.setAttribute('role', 'tooltip');
    
    // Position tooltip
    document.body.appendChild(tooltip);
    this._positionTooltip(tooltip, element, position);
    
    // Store reference
    element._tooltip = tooltip;
    
    // Animate in
    setTimeout(() => {
      tooltip.classList.add('tooltip-show');
    }, 10);
  }

  /**
   * Hide tooltip
   * @param {HTMLElement} element - Target element
   */
  hideTooltip(element) {
    if (!element || !element._tooltip) return;
    
    const tooltip = element._tooltip;
    tooltip.classList.remove('tooltip-show');
    
    setTimeout(() => {
      tooltip.remove();
      delete element._tooltip;
    }, 200);
  }

  /**
   * Add keyboard shortcut
   * @param {string} key - Key combination (e.g., 'ctrl+s', 'cmd+enter')
   * @param {Function} handler - Handler function
   * @param {string} description - Description for help
   */
  addKeyboardShortcut(key, handler, description) {
    // Parse key combination
    const parts = key.toLowerCase().split('+');
    const modifiers = {
      ctrl: false,
      cmd: false,
      alt: false,
      shift: false
    };
    
    let mainKey = '';
    
    parts.forEach(part => {
      if (part in modifiers) {
        modifiers[part] = true;
      } else {
        mainKey = part;
      }
    });
    
    // Add event listener
    document.addEventListener('keydown', (e) => {
      const isMatch = 
        (modifiers.ctrl === (e.ctrlKey || (modifiers.cmd && e.metaKey))) &&
        (modifiers.alt === e.altKey) &&
        (modifiers.shift === e.shiftKey) &&
        (e.key.toLowerCase() === mainKey);
      
      if (isMatch) {
        e.preventDefault();
        handler(e);
      }
    });
    
    // Store for help display
    if (!window._shortcuts) {
      window._shortcuts = [];
    }
    window._shortcuts.push({ key, description });
  }

  /**
   * Ensure notification container exists
   * @private
   */
  _ensureNotificationContainer() {
    if (!this.notificationContainer) {
      this.notificationContainer = document.getElementById('notifications');
      
      if (!this.notificationContainer) {
        this.notificationContainer = document.createElement('div');
        this.notificationContainer.id = 'notifications';
        this.notificationContainer.className = 'notification-container';
        document.body.appendChild(this.notificationContainer);
      }
    }
  }

  /**
   * Remove notification with animation
   * @private
   * @param {HTMLElement} notification - Notification element
   */
  _removeNotification(notification) {
    notification.classList.remove('notification-show');
    setTimeout(() => notification.remove(), 200);
  }

  /**
   * Get notification icon
   * @private
   * @param {string} type - Notification type
   * @returns {string} Icon HTML
   */
  _getNotificationIcon(type) {
    const icons = {
      success: '✓',
      error: '✕',
      warning: '⚠',
      info: 'ℹ'
    };
    
    return icons[type] || icons.info;
  }

  /**
   * Position tooltip relative to element
   * @private
   * @param {HTMLElement} tooltip - Tooltip element
   * @param {HTMLElement} target - Target element
   * @param {string} position - Position
   */
  _positionTooltip(tooltip, target, position) {
    const targetRect = target.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    const gap = 8;
    
    let top, left;
    
    switch (position) {
      case 'top':
        top = targetRect.top - tooltipRect.height - gap;
        left = targetRect.left + (targetRect.width - tooltipRect.width) / 2;
        break;
        
      case 'bottom':
        top = targetRect.bottom + gap;
        left = targetRect.left + (targetRect.width - tooltipRect.width) / 2;
        break;
        
      case 'left':
        top = targetRect.top + (targetRect.height - tooltipRect.height) / 2;
        left = targetRect.left - tooltipRect.width - gap;
        break;
        
      case 'right':
        top = targetRect.top + (targetRect.height - tooltipRect.height) / 2;
        left = targetRect.right + gap;
        break;
    }
    
    // Ensure tooltip stays within viewport
    top = Math.max(gap, Math.min(top, window.innerHeight - tooltipRect.height - gap));
    left = Math.max(gap, Math.min(left, window.innerWidth - tooltipRect.width - gap));
    
    tooltip.style.top = `${top}px`;
    tooltip.style.left = `${left}px`;
  }

  /**
   * Escape HTML
   * @private
   * @param {string} text - Raw text
   * @returns {string} Escaped text
   */
  _escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Add CSS styles dynamically
   * @param {string} id - Style ID
   * @param {string} css - CSS content
   */
  addStyles(id, css) {
    // Check if styles already exist
    if (document.getElementById(id)) return;
    
    const style = document.createElement('style');
    style.id = id;
    style.textContent = css;
    document.head.appendChild(style);
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\utils\dom.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\utils\helpers.js:
// public/js/utils/helpers.js
/**
 * General helper functions
 * Utility functions for common operations
 */

export class Helpers {
  /**
   * Debounce function execution
   * @param {Function} func - Function to debounce
   * @param {number} wait - Wait time in ms
   * @param {boolean} immediate - Execute immediately on first call
   * @returns {Function} Debounced function
   */
  debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
      const later = () => {
        timeout = null;
        if (!immediate) func(...args);
      };
      
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      
      if (callNow) func(...args);
    };
  }

  /**
   * Throttle function execution
   * @param {Function} func - Function to throttle
   * @param {number} limit - Time limit in ms
   * @returns {Function} Throttled function
   */
  throttle(func, limit) {
    let inThrottle;
    
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        
        setTimeout(() => {
          inThrottle = false;
        }, limit);
      }
    };
  }

  /**
   * Get user-friendly error message
   * @param {Error|string} error - Error object or message
   * @returns {string} User-friendly message
   */
  getErrorMessage(error) {
    // Handle API errors
    if (error && error.getUserMessage) {
      return error.getUserMessage();
    }
    
    // Handle known error types
    const errorString = error?.message || String(error);
    
    // Network errors
    if (errorString.includes('fetch')) {
      return 'Connection failed. Please check your internet.';
    }
    
    if (errorString.includes('timeout')) {
      return 'Request timed out. Please try again.';
    }
    
    // Generation errors
    if (errorString.includes('diagram')) {
      return 'Failed to generate.';
    }
    
    if (errorString.includes('render')) {
      return 'Failed. Please try again.';
    }
    
    // Validation errors
    if (errorString.includes('empty') || errorString.includes('required')) {
      return 'Please provide all required information.';
    }
    
    // Generic message
    return 'Something went wrong. Please try again.';
  }

  /**
   * Format file size
   * @param {number} bytes - Size in bytes
   * @param {number} decimals - Decimal places
   * @returns {string} Formatted size
   */
  formatFileSize(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

  /**
   * Format relative time
   * @param {Date|number} date - Date object or timestamp
   * @returns {string} Relative time string
   */
  formatRelativeTime(date) {
    const timestamp = date instanceof Date ? date.getTime() : date;
    const now = Date.now();
    const diff = now - timestamp;
    
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (seconds < 60) {
      return 'just now';
    } else if (minutes < 60) {
      return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
    } else if (hours < 24) {
      return `${hours} hour${hours > 1 ? 's' : ''} ago`;
    } else if (days < 7) {
      return `${days} day${days > 1 ? 's' : ''} ago`;
    } else {
      return new Date(timestamp).toLocaleDateString();
    }
  }

  /**
   * Deep clone object
   * @param {any} obj - Object to clone
   * @returns {any} Cloned object
   */
  deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }
    
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    
    if (obj instanceof Array) {
      return obj.map(item => this.deepClone(item));
    }
    
    if (obj instanceof RegExp) {
      return new RegExp(obj);
    }
    
    const cloned = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        cloned[key] = this.deepClone(obj[key]);
      }
    }
    
    return cloned;
  }

  /**
   * Generate unique ID
   * @param {string} prefix - Optional prefix
   * @returns {string} Unique ID
   */
  generateId(prefix = '') {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 9);
    return prefix ? `${prefix}-${timestamp}-${random}` : `${timestamp}-${random}`;
  }

  /**
   * Parse query string
   * @param {string} query - Query string
   * @returns {Object} Parsed parameters
   */
  parseQueryString(query = window.location.search) {
    const params = new URLSearchParams(query);
    const result = {};
    
    for (const [key, value] of params) {
      // Handle array parameters
      if (key.endsWith('[]')) {
        const arrayKey = key.slice(0, -2);
        if (!result[arrayKey]) {
          result[arrayKey] = [];
        }
        result[arrayKey].push(value);
      } else {
        result[key] = value;
      }
    }
    
    return result;
  }

  /**
   * Build query string from object
   * @param {Object} params - Parameters object
   * @returns {string} Query string
   */
  buildQueryString(params) {
    const searchParams = new URLSearchParams();
    
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach(v => searchParams.append(`${key}[]`, v));
      } else if (value !== null && value !== undefined) {
        searchParams.append(key, value);
      }
    });
    
    return searchParams.toString();
  }

  /**
   * Sanitize HTML string
   * @param {string} html - HTML string
   * @param {Object} options - Sanitization options
   * @returns {string} Sanitized HTML
   */
  sanitizeHtml(html, options = {}) {
    const defaults = {
      allowedTags: ['b', 'i', 'em', 'strong', 'a', 'code', 'pre', 'br', 'p', 'ul', 'li'],
      allowedAttributes: {
        'a': ['href', 'target', 'rel']
      }
    };
    
    const config = { ...defaults, ...options };
    
    // Create temporary element
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    // Remove script tags
    const scripts = temp.querySelectorAll('script');
    scripts.forEach(script => script.remove());
    
    // Remove event handlers
    const elements = temp.querySelectorAll('*');
    elements.forEach(el => {
      // Remove event attributes
      for (const attr of el.attributes) {
        if (attr.name.startsWith('on')) {
          el.removeAttribute(attr.name);
        }
      }
      
      // Check if tag is allowed
      if (!config.allowedTags.includes(el.tagName.toLowerCase())) {
        el.replaceWith(...el.childNodes);
      } else {
        // Remove disallowed attributes
        const allowedAttrs = config.allowedAttributes[el.tagName.toLowerCase()] || [];
        for (const attr of el.attributes) {
          if (!allowedAttrs.includes(attr.name)) {
            el.removeAttribute(attr.name);
          }
        }
      }
    });
    
    return temp.innerHTML;
  }

  /**
   * Detect mobile device
   * @returns {boolean} Is mobile device
   */
  isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }

  /**
   * Detect touch device
   * @returns {boolean} Has touch support
   */
  isTouchDevice() {
    return (
      'ontouchstart' in window ||
      navigator.maxTouchPoints > 0 ||
      navigator.msMaxTouchPoints > 0
    );
  }

  /**
   * Get browser info
   * @returns {Object} Browser information
   */
  getBrowserInfo() {
    const ua = navigator.userAgent;
    let browser = 'Unknown';
    let version = '';
    
    if (ua.includes('Firefox/')) {
      browser = 'Firefox';
      version = ua.match(/Firefox\/(\d+)/)[1];
    } else if (ua.includes('Chrome/')) {
      browser = 'Chrome';
      version = ua.match(/Chrome\/(\d+)/)[1];
    } else if (ua.includes('Safari/') && !ua.includes('Chrome')) {
      browser = 'Safari';
      version = ua.match(/Version\/(\d+)/)[1];
    } else if (ua.includes('Edge/')) {
      browser = 'Edge';
      version = ua.match(/Edge\/(\d+)/)[1];
    }
    
    return {
      browser,
      version,
      userAgent: ua,
      platform: navigator.platform,
      language: navigator.language
    };
  }

  /**
   * Copy text to clipboard with fallback
   * @param {string} text - Text to copy
   * @returns {Promise<boolean>} Success status
   */
  async copyToClipboard(text) {
    // Try modern API first
    if (navigator.clipboard && window.isSecureContext) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (err) {
        console.warn('Clipboard API failed:', err);
      }
    }
    
    // Fallback method
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      const successful = document.execCommand('copy');
      document.body.removeChild(textArea);
      return successful;
    } catch (err) {
      console.error('Fallback copy failed:', err);
      document.body.removeChild(textArea);
      return false;
    }
  }

  /**
   * Download data as file
   * @param {string|Blob} data - Data to download
   * @param {string} filename - File name
   * @param {string} type - MIME type
   */
  downloadFile(data, filename, type = 'text/plain') {
    const blob = data instanceof Blob ? data : new Blob([data], { type });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up
    setTimeout(() => URL.revokeObjectURL(url), 250);
  }

  /**
   * Load external script
   * @param {string} src - Script URL
   * @param {Object} options - Load options
   * @returns {Promise} Resolves when loaded
   */
  loadScript(src, options = {}) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      
      if (options.async !== false) {
        script.async = true;
      }
      
      if (options.defer) {
        script.defer = true;
      }
      
      if (options.crossOrigin) {
        script.crossOrigin = options.crossOrigin;
      }
      
      script.onload = () => resolve(script);
      script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
      
      document.head.appendChild(script);
    });
  }

  /**
   * Retry async operation
   * @param {Function} operation - Async operation
   * @param {number} maxAttempts - Maximum attempts
   * @param {number} delay - Delay between attempts
   * @returns {Promise} Operation result
   */
  async retry(operation, maxAttempts = 3, delay = 1000) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (attempt < maxAttempts) {
          console.warn(`Attempt ${attempt} failed, retrying...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError;
  }

  /**
   * Wait for condition to be true
   * @param {Function} condition - Condition function
   * @param {number} timeout - Timeout in ms
   * @param {number} interval - Check interval in ms
   * @returns {Promise} Resolves when condition is true
   */
  waitFor(condition, timeout = 5000, interval = 100) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      const check = () => {
        if (condition()) {
          resolve();
        } else if (Date.now() - startTime > timeout) {
          reject(new Error('Timeout waiting for condition'));
        } else {
          setTimeout(check, interval);
        }
      };
      
      check();
    });
  }
}

// Export singleton instance
export const helpers = new Helpers();

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\public\js\utils\helpers.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\renderer.py:
# services/renderer.py
"""
Diagram rendering service.
Handles rendering Mermaid diagrams as HTML or images.
"""

import base64
import logging
from typing import Optional

from playwright.async_api import async_playwright, Browser, Page

from core.config import get_config
from api.models import RenderResult


logger = logging.getLogger(__name__)


class DiagramRenderer:
    """Handles rendering of Mermaid diagrams."""
    
    def __init__(self):
        """Initialize the renderer with configuration."""
        self.config = get_config()
        self._browser: Optional[Browser] = None
    
    async def render(self, mermaid_code: str) -> RenderResult:
        """
        Render a Mermaid diagram based on configured mode.
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            RenderResult with type and content
            
        Raises:
            Exception: If rendering fails
        """
        if self.config.RENDER_MODE == "image":
            return await self._render_as_image(mermaid_code)
        else:
            return self._render_as_html(mermaid_code)
    
    def _render_as_html(self, mermaid_code: str) -> RenderResult:
        """
        Render diagram as HTML (client-side rendering).
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            RenderResult with HTML content
        """
        logger.debug("Rendering as HTML")
        
        return RenderResult(
            render_type="html",
            rendered_content=mermaid_code
        )
    
    async def _render_as_image(self, mermaid_code: str) -> RenderResult:
        """
        Render diagram as PNG image using Playwright.
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            RenderResult with base64-encoded image
            
        Raises:
            Exception: If browser rendering fails
        """
        logger.debug("Rendering as image using Playwright")
        
        html_content = self._create_html_page(mermaid_code)
        
        async with async_playwright() as p:
            browser = await p.chromium.launch(
                headless=True,
                args=self.config.PLAYWRIGHT_ARGS
            )
            
            try:
                page = await browser.new_page()
                
                # Set viewport for consistent rendering
                await page.set_viewport_size({"width": 1200, "height": 800})
                
                # Load the HTML content
                await page.set_content(html_content)
                
                # Wait for Mermaid to render
                try:
                    await page.wait_for_selector(
                        '.mermaid svg',
                        timeout=self.config.PLAYWRIGHT_TIMEOUT
                    )
                except Exception as e:
                    logger.error(f"Mermaid rendering timeout: {str(e)}")
                    # Try to get any error message
                    error_text = await self._get_mermaid_error(page)
                    if error_text:
                        raise ValueError(f"Mermaid error: {error_text}")
                    raise ValueError("Failed to render Mermaid diagram")
                
                # Get the diagram element
                element = await page.query_selector('.mermaid')
                if not element:
                    raise ValueError("No Mermaid diagram found in rendered page")
                
                # Take screenshot
                screenshot = await element.screenshot(
                    type='png',
                    omit_background=True
                )
                
                # Encode as base64
                encoded = base64.b64encode(screenshot).decode('utf-8')
                data_url = f"data:image/png;base64,{encoded}"
                
                logger.info("Successfully rendered diagram as image")
                
                return RenderResult(
                    render_type="image",
                    rendered_content=data_url
                )
                
            finally:
                await browser.close()
    
    def _create_html_page(self, mermaid_code: str) -> str:
        """
        Create a minimal HTML page for rendering.
        
        Args:
            mermaid_code: Mermaid diagram code
            
        Returns:
            Complete HTML page as string
        """
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{
                    margin: 0;
                    padding: 20px;
                    background: white;
                    font-family: Arial, sans-serif;
                }}
                .mermaid {{
                    text-align: center;
                }}
                .error {{
                    color: red;
                    padding: 20px;
                    border: 1px solid red;
                    background: #ffeeee;
                }}
            </style>
            <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
            <script>
                mermaid.initialize({{ 
                    startOnLoad: true,
                    theme: 'default',
                    fontFamily: 'Arial, sans-serif',
                    fontSize: 14,
                    securityLevel: 'loose'
                }});
                
                // Error handling
                window.addEventListener('error', function(e) {{
                    document.body.innerHTML = '<div class="error">Rendering error: ' + e.message + '</div>';
                }});
            </script>
        </head>
        <body>
            <div class="mermaid">
{mermaid_code}
            </div>
        </body>
        </html>
        """
    
    async def _get_mermaid_error(self, page: Page) -> Optional[str]:
        """
        Try to extract any Mermaid error message from the page.
        
        Args:
            page: Playwright page object
            
        Returns:
            Error message if found, None otherwise
        """
        try:
            # Check for error elements
            error_element = await page.query_selector('.error')
            if error_element:
                return await error_element.text_content()
            
            # Check for Mermaid error in console
            # This would require setting up console message handling
            
            return None
        except Exception:
            return None


# Create a singleton renderer instance
_renderer = DiagramRenderer()


async def render_diagram(mermaid_code: str) -> RenderResult:
    """
    Render a Mermaid diagram.
    
    This is the main entry point for diagram rendering.
    
    Args:
        mermaid_code: Mermaid diagram code
        
    Returns:
        RenderResult with render_type and rendered_content
        
    Raises:
        ValueError: If diagram is invalid
        Exception: If rendering fails
    """
    if not mermaid_code or not mermaid_code.strip():
        raise ValueError("Mermaid code cannot be empty")
    
    return await _renderer.render(mermaid_code.strip())


async def render_as_image(mermaid_code: str) -> str:
    """
    Force render a diagram as an image.
    
    Useful for testing or when you specifically need an image.
    
    Args:
        mermaid_code: Mermaid diagram code
        
    Returns:
        Base64-encoded PNG data URL
    """
    renderer = DiagramRenderer()
    # Override config temporarily
    renderer.config.RENDER_MODE = "image"
    result = await renderer.render(mermaid_code)
    return result.rendered_content

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\renderer.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\client.py:
# services/llm/client.py
"""
OpenAI client management and LLM interaction utilities.
Provides a singleton client and common LLM operations.
"""

from typing import Optional, List, Dict, Any
from functools import lru_cache
import logging

from openai import AsyncOpenAI
from openai.types.chat import ChatCompletionMessageParam

from core.config import get_config


logger = logging.getLogger(__name__)


class LLMClient:
    """Manages OpenAI client instance and provides LLM operations."""
    
    def __init__(self):
        """Initialize the OpenAI client with configuration."""
        config = get_config()
        self.api_key = config.OPENAI_API_KEY
        self.model = config.OPENAI_MODEL
        self.default_temperature = config.OPENAI_TEMPERATURE
        
        if not self.api_key:
            raise ValueError("OpenAI API key not configured")
        
        self._client = AsyncOpenAI(api_key=self.api_key)
    
    async def generate(
        self,
        messages: List[ChatCompletionMessageParam],
        temperature: Optional[float] = None,
        max_tokens: Optional[int] = None,
        model: Optional[str] = None,
        **kwargs
    ) -> str:
        """
        Generate a completion using the OpenAI API.
        
        Args:
            messages: List of chat messages
            temperature: Override default temperature
            max_tokens: Maximum tokens in response
            model: Override default model
            **kwargs: Additional OpenAI API parameters
            
        Returns:
            Generated text response
            
        Raises:
            Exception: If API call fails
        """
        try:
            response = await self._client.chat.completions.create(
                model=model or self.model,
                messages=messages,
                temperature=temperature or self.default_temperature,
                max_tokens=max_tokens,
                **kwargs
            )
            
            content = response.choices[0].message.content
            if not content:
                raise ValueError("Empty response from OpenAI")
                
            return content.strip()
            
        except Exception as e:
            logger.error(f"OpenAI API error: {str(e)}")
            raise
    
    async def generate_with_system(
        self,
        system_prompt: str,
        user_prompt: str,
        **kwargs
    ) -> str:
        """
        Convenience method for simple system/user message generation.
        
        Args:
            system_prompt: System message content
            user_prompt: User message content
            **kwargs: Additional parameters for generate()
            
        Returns:
            Generated text response
        """
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
        return await self.generate(messages, **kwargs)
    
    async def test_connection(self) -> bool:
        """
        Test the OpenAI API connection.
        
        Returns:
            True if connection successful, False otherwise
        """
        try:
            response = await self.generate_with_system(
                system_prompt="You are a helpful assistant.",
                user_prompt="Say 'OK' if you can hear me.",
                max_tokens=5,
                temperature=0
            )
            return "OK" in response
        except Exception as e:
            logger.error(f"Connection test failed: {str(e)}")
            return False


@lru_cache()
def get_llm_client() -> LLMClient:
    """
    Get singleton LLM client instance.
    
    Returns:
        Configured LLMClient instance
    """
    return LLMClient()


async def quick_generate(
    prompt: str,
    max_tokens: Optional[int] = None,
    temperature: Optional[float] = None
) -> str:
    """
    Quick generation helper for simple prompts.
    
    Args:
        prompt: User prompt
        max_tokens: Maximum response tokens
        temperature: Generation temperature
        
    Returns:
        Generated response
    """
    client = get_llm_client()
    return await client.generate_with_system(
        system_prompt="You are a helpful assistant.",
        user_prompt=prompt,
        max_tokens=max_tokens,
        temperature=temperature
    )

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\content.py:
# services/llm/content.py
"""
Content generation logic using LLM.
Handles generating structured content descriptions from user queries.
"""

import logging
import re
from typing import Dict, List, Optional

from core.config import get_config
from services.llm.client import get_llm_client
from services.llm.prompts import get_prompt_manager

logger = logging.getLogger(__name__)


class ContentGenerator:
    """Generates structured content descriptions for diagrams."""
    
    def __init__(self):
        self.client = get_llm_client()
        self.prompt_manager = get_prompt_manager()
        self.config = get_config()
    
    async def generate(
        self,
        query: str,
        diagram_type: str,
        max_items: Optional[int] = None
    ) -> str:
        """
        Generate structured content description based on query and diagram type.
        
        Args:
            query: User's query text
            diagram_type: Type of diagram (affects content structure)
            max_items: Maximum number of items to generate
            
        Returns:
            Structured content description
        
        Raises:
            ValueError: If content generation fails or validation fails
        """
        # Get appropriate prompt
        prompt = self.prompt_manager.get_content_prompt(diagram_type)
        
        # Add max items constraint if specified
        if max_items:
            user_message = f"{query}\n\nPlease limit to {max_items} main points."
        else:
            user_message = query
        
        logger.debug(f"Generating {diagram_type} content for: {query[:50]}...")
        
        try:
            response = await self.client.generate_with_system(
                system_prompt=str(prompt),
                user_prompt=user_message,
                temperature=self.config.OPENAI_TEMPERATURE,
                max_tokens=self.config.OPENAI_MAX_TOKENS_CONTENT
            )
            
            if not response:
                raise ValueError("Empty content response from LLM")
            
            # Validate content structure
            if not self._validate_content(response, diagram_type):
                raise ValueError("Invalid content structure")
            
            return response
        
        except Exception as e:
            logger.error(f"Content generation failed: {str(e)}")
            raise
    
    
    def _validate_standard_content(self, content: str) -> bool:
        """
        Validate “standard” content:
         - Must include a "Main topic:" or "Topic:" line
         - Must have at least one fact, which can be:
           * A bullet (“- …”)
           * A numbered item (“1. …”)
           * A line containing the word “fact”
        """
        lines = [l.strip() for l in content.splitlines() if l.strip()]

        # 1) Topic line
        has_topic = any(
            re.match(r'^(main topic|topic)\s*[:\-]', line, re.IGNORECASE)
            for line in lines
        )
        if not has_topic:
            return False

        # 2) Fact count
        fact_count = 0
        for line in lines:
            if line.startswith('- '):
                fact_count += 1
            elif re.match(r'^\d+\.\s+', line):
                fact_count += 1
            elif 'fact' in line.lower():
                fact_count += 1

        return fact_count >= 1
    
    
    def _validate_comparison_content(self, content: str) -> bool:
        """Validate comparison content format."""
        content_lower = content.lower()
        if 'items:' not in content_lower:
            return False
        if 'similarity' not in content_lower:
            return False
        if 'unique' not in content_lower:
            return False
        return True


    def _validate_content(self, content: str, diagram_type: str) -> bool:
        """
        Dispatch to the appropriate validator based on diagram_type.
        """
        if diagram_type == "sequence_comparison":
            return self._validate_comparison_content(content)
        else:
            return self._validate_standard_content(content)
    

    def parse_content(self, content: str, diagram_type: str) -> Dict:
        """
        Parse structured content into a dictionary.
        
        Args:
            content: Structured content string
            diagram_type: Type of content
        
        Returns:
            Parsed content dictionary
        """
        if diagram_type == "sequence_comparison":
            return self._parse_comparison_content(content)
        else:
            return self._parse_standard_content(content)
    
    
    def _parse_standard_content(self, content: str) -> Dict:
        """Parse standard content format into {'topic': str, 'facts': List[str]}."""
        lines = content.strip().split('\n')
        result = {'topic': '', 'facts': []}
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            low = line.lower()
            if low.startswith('main topic:') or low.startswith('topic:'):
                result['topic'] = line.split(':', 1)[1].strip()
            elif any(low.startswith(f'fact {i}:') for i in range(1, 10)):
                fact_text = line.split(':', 1)[1].strip()
                result['facts'].append(fact_text)
            elif line.startswith('- '):
                result['facts'].append(line[2:].strip())
            elif re.match(r'^\d+\.\s+', line):
                result['facts'].append(re.sub(r'^\d+\.\s+', '', line).strip())
        
        return result
    
    
    def _parse_comparison_content(self, content: str) -> Dict:
        """Parse comparison content format into items, similarities, and unique_features."""
        lines = content.strip().split('\n')
        result = {'items': [], 'similarities': [], 'unique_features': {}}
        current_item = None
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            low = line.lower()
            if low.startswith('items:'):
                items = line.split(':', 1)[1].split(',')
                result['items'] = [item.strip() for item in items]
                for item in result['items']:
                    result['unique_features'][item] = []
            
            elif 'similarity' in low and ':' in line:
                sim = line.split(':', 1)[1].strip()
                result['similarities'].append(sim)
            
            elif 'unique' in low and ':' in line:
                parts = line.split(' unique ')
                if parts:
                    current_item = parts[0].strip()
                    feat = line.split(':', 1)[1].strip()
                    if current_item in result['unique_features']:
                        result['unique_features'][current_item].append(feat)
        
        return result


class ContentEnricher:
    """Enriches content with additional context and details."""
    
    def __init__(self):
        self.client = get_llm_client()
        self.config = get_config()
    
    async def enrich(
        self,
        content: str,
        query: str,
        enrichment_type: str = "examples"
    ) -> str:
        """
        Enrich content with additional information.
        
        Args:
            content: Base content to enrich
            query: Original user query
            enrichment_type: Type of enrichment ('examples', 'details', 'context')
        
        Returns:
            Enriched content
        """
        enrichment_prompts = {
            "examples": "Add 1-2 concrete examples to each point:",
            "details" : "Add more specific details to each point:",
            "context" : "Add relevant context and background to each point:"
        }
        prompt = enrichment_prompts.get(enrichment_type, enrichment_prompts["examples"])
        
        system_message = (
            f"You are enriching content for better understanding.\n"
            f"{prompt}\n"
            "Keep additions concise (10-15 words per addition).\n"
            "Maintain the original structure."
        )
        user_message = f"Original query: {query}\n\nContent to enrich:\n{content}"
        
        try:
            response = await self.client.generate_with_system(
                system_prompt=system_message,
                user_prompt=user_message,
                temperature=0.7,
                max_tokens=self.config.OPENAI_MAX_TOKENS_CONTENT
            )
            return response.strip()
        except Exception as e:
            logger.warning(f"Content enrichment failed: {str(e)}")
            return content


# Convenience functions

async def generate_content(
    query: str,
    diagram_type: str,
    enrich: bool = False
) -> str:
    """
    Generate content description for a query.
    """
    generator = ContentGenerator()
    content = await generator.generate(query, diagram_type)
    if enrich:
        enricher = ContentEnricher()
        content = await enricher.enrich(content, query)
    return content


async def parse_and_validate_content(
    content: str,
    diagram_type: str
) -> Dict:
    """
    Parse and validate content structure.
    """
    generator = ContentGenerator()
    if not generator._validate_content(content, diagram_type):
        raise ValueError("Content did not pass validation")
    return generator.parse_content(content, diagram_type)

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\content.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\diagram.py:
# services/llm/diagram.py
"""
Diagram generation logic using LLM.
Handles diagram type selection, content generation, and diagram creation.
"""

import logging
from typing import Literal

from core.config import get_config
from services.llm.client import get_llm_client
from services.llm.prompts import get_prompt_manager
from services.llm.content import generate_content


logger = logging.getLogger(__name__)

# Type definitions
DiagramType = Literal["flowchart", "radial_mindmap", "sequence_comparison"]


async def select_diagram_type(query: str) -> DiagramType:
    """
    Analyze the query and select the most appropriate diagram type.
    
    Args:
        query: User's query text
        
    Returns:
        Selected diagram type
        
    Raises:
        ValueError: If LLM returns invalid diagram type
    """
    client = get_llm_client()
    config = get_config()
    
    selector_prompt = """You are a diagram-type selector.

As a response to the below query, choose which output representation would be best suited:
- flowchart        : sequential steps, how-to, decision logic
- radial_mindmap   : concept overviews, definitions, characteristics
- sequence_comparison: comparing two or more items, highlighting similarities and unique features

Respond with ONLY one word: "flowchart", "radial_mindmap", or "sequence_comparison"."""
    
    try:
        response = await client.generate_with_system(
            system_prompt=selector_prompt,
            user_prompt=query,
            temperature=0.3,
            max_tokens=config.OPENAI_MAX_TOKENS_SELECTOR
        )
        
        # Validate response
        valid_types = {"flowchart", "radial_mindmap", "sequence_comparison"}
        response_clean = response.strip().lower()
        
        if response_clean not in valid_types:
            logger.warning(f"Invalid diagram type from LLM: {response}")
            # Default to radial_mindmap for general queries
            return "radial_mindmap"
        
        return response_clean  # type: ignore
        
    except Exception as e:
        logger.error(f"Error selecting diagram type: {str(e)}")
        # Default fallback
        return "radial_mindmap"





async def generate_diagram_code(
    content_description: str,
    original_query: str,
    diagram_type: DiagramType
) -> str:
    """
    Generate Mermaid diagram code from content description.
    
    Args:
        content_description: Structured content to visualize
        original_query: Original user query for context
        diagram_type: Type of diagram to generate
        
    Returns:
        Raw Mermaid diagram code
        
    Raises:
        Exception: If diagram generation fails
    """
    client = get_llm_client()
    config = get_config()
    prompt_manager = get_prompt_manager()
    
    # Get appropriate prompt for diagram type
    diagram_prompt = prompt_manager.get_diagram_prompt(diagram_type)
    
    # Build user message based on diagram type
    if diagram_type == "flowchart":
        user_message = (
            f"Create a Mermaid flowchart that answers this query:\n\n"
            f"{original_query}\n\n"
            f"Content details:\n{content_description}"
        )
    elif diagram_type == "sequence_comparison":
        user_message = (
            f"Create a Mermaid sequence diagram for this comparison query:\n\n"
            f"{original_query}\n\n"
            f"Content details:\n{content_description}"
        )
    else:  # radial_mindmap
        user_message = (
            f"Create a radial Mermaid mind-map from this content:\n"
            f"{content_description}"
        )
    
    logger.debug(f"Generating {diagram_type} diagram code")
    
    response = await client.generate_with_system(
        system_prompt=str(diagram_prompt),
        user_prompt=user_message,
        temperature=config.OPENAI_TEMPERATURE,
        max_tokens=config.OPENAI_MAX_TOKENS_DIAGRAM
    )
    
    if not response:
        raise ValueError("Empty diagram response from LLM")
    
    return response


async def generate_deep_dive_response(
    selected_text: str,
    question: str,
    original_query: str = ""
) -> str:
    """
    Generate contextual information about selected diagram content.
    
    Args:
        selected_text: Text selected from the diagram
        question: User's question about the selection
        original_query: Original query that generated the diagram
        
    Returns:
        Detailed explanation or answer
        
    Raises:
        Exception: If generation fails
    """
    client = get_llm_client()
    config = get_config()
    prompt_manager = get_prompt_manager()
    
    # Get deep dive prompt
    deep_dive_prompt = prompt_manager.get("deep_dive")
    
    # Build context-aware user message
    user_message = f'Selected text from diagram: "{selected_text}"\n\n'
    user_message += f'User\'s question: {question}'
    
    if original_query:
        user_message += (
            f"\n\nOriginal query that generated the diagram: {original_query}"
        )
    
    logger.info(f"Generating deep dive response for: {question[:50]}...")
    
    response = await client.generate_with_system(
        system_prompt=str(deep_dive_prompt),
        user_prompt=user_message,
        temperature=config.OPENAI_TEMPERATURE,
        max_tokens=config.OPENAI_MAX_TOKENS_CONTENT
    )
    
    if not response:
        raise ValueError("Empty deep dive response from LLM")
    
    return response


# Convenience function for backward compatibility
async def generate_diagram(query: str) -> str:
    """
    Generate a complete diagram from a query.
    
    This is a convenience function that runs the full generation pipeline.
    
    Args:
        query: User's query text
        
    Returns:
        Raw Mermaid diagram code
    """
    diagram_type = await select_diagram_type(query)
    content = await generate_content(query, diagram_type)
    return await generate_diagram_code(content, query, diagram_type)
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\diagram.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\prompts.py:
# services/llm/prompts.py
"""
Prompt template management for LLM operations.
Handles loading, caching, and formatting of prompt templates.
"""

from pathlib import Path
from typing import Dict, Optional
from functools import lru_cache
import logging

from core.config import get_config


logger = logging.getLogger(__name__)


class PromptTemplate:
    """Represents a loaded prompt template with metadata."""
    
    def __init__(self, name: str, content: str, path: Path):
        self.name = name
        self.content = content
        self.path = path
        self._validate()
    
    def _validate(self):
        """Validate prompt content."""
        if not self.content.strip():
            raise ValueError(f"Prompt template '{self.name}' is empty")
    
    def format(self, **kwargs) -> str:
        """
        Format the prompt with provided variables.
        
        Args:
            **kwargs: Variables to substitute in the template
            
        Returns:
            Formatted prompt string
        """
        try:
            return self.content.format(**kwargs)
        except KeyError as e:
            logger.error(f"Missing variable in prompt '{self.name}': {e}")
            raise ValueError(f"Missing required variable: {e}")
    
    def __str__(self) -> str:
        return self.content


class PromptManager:
    """Manages loading and caching of prompt templates."""
    
    # Prompt filename mapping
    PROMPT_FILES = {
        # Content generation
        "content": "content.txt",
        "content_sequence": "content_sequence_comparison.txt",
        
        # Diagram generation
        "diagram_radial": "diagram.txt",
        "diagram_flowchart": "diagram_flowchart.txt",
        "diagram_sequence": "diagram_sequence_comparison.txt",
        
        # Other
        "deep_dive": "deep_dive.txt",
    }
    
    def __init__(self):
        self.config = get_config()
        self._cache: Dict[str, PromptTemplate] = {}
        self._load_all_prompts()
    
    def _load_all_prompts(self):
        """Pre-load all known prompts for validation."""
        for key, filename in self.PROMPT_FILES.items():
            try:
                self._load_prompt(key, filename)
            except Exception as e:
                logger.warning(f"Failed to load prompt '{key}': {e}")
    
    def _load_prompt(self, key: str, filename: str) -> PromptTemplate:
        """Load a single prompt file."""
        path = self.config.get_prompt_path(filename)
        content = path.read_text(encoding="utf-8")
        
        template = PromptTemplate(
            name=key,
            content=content,
            path=path
        )
        
        self._cache[key] = template
        logger.debug(f"Loaded prompt '{key}' from {filename}")
        return template
    
    def get(self, key: str) -> PromptTemplate:
        """
        Get a prompt template by key.
        
        Args:
            key: Prompt identifier
            
        Returns:
            PromptTemplate instance
            
        Raises:
            KeyError: If prompt not found
        """
        if key not in self._cache:
            if key not in self.PROMPT_FILES:
                raise KeyError(f"Unknown prompt key: '{key}'")
            
            # Try to load if not in cache
            self._load_prompt(key, self.PROMPT_FILES[key])
        
        return self._cache[key]
    
    def get_content_prompt(self, diagram_type: str) -> PromptTemplate:
        """
        Get the appropriate content generation prompt for a diagram type.
        
        Args:
            diagram_type: Type of diagram (flowchart, radial_mindmap, sequence_comparison)
            
        Returns:
            Appropriate content prompt template
        """
        if diagram_type == "sequence_comparison":
            return self.get("content_sequence")
        return self.get("content")
    
    def get_diagram_prompt(self, diagram_type: str) -> PromptTemplate:
        """
        Get the appropriate diagram generation prompt for a diagram type.
        
        Args:
            diagram_type: Type of diagram
            
        Returns:
            Appropriate diagram prompt template
        """
        prompt_map = {
            "flowchart": "diagram_flowchart",
            "radial_mindmap": "diagram_radial",
            "sequence_comparison": "diagram_sequence",
        }
        
        key = prompt_map.get(diagram_type, "diagram_radial")
        return self.get(key)
    
    def reload(self, key: Optional[str] = None):
        """
        Reload prompt(s) from disk.
        
        Args:
            key: Specific prompt to reload, or None for all
        """
        if key:
            if key in self.PROMPT_FILES:
                self._load_prompt(key, self.PROMPT_FILES[key])
                logger.info(f"Reloaded prompt '{key}'")
        else:
            self._cache.clear()
            self._load_all_prompts()
            logger.info("Reloaded all prompts")


@lru_cache()
def get_prompt_manager() -> PromptManager:
    """Get singleton PromptManager instance."""
    return PromptManager()


def load_prompt(key: str) -> str:
    """
    Convenience function to load a prompt by key.
    
    Args:
        key: Prompt identifier
        
    Returns:
        Prompt content string
    """
    manager = get_prompt_manager()
    return str(manager.get(key))


def get_diagram_type_prompts(diagram_type: str) -> tuple[str, str]:
    """
    Get both content and diagram prompts for a diagram type.
    
    Args:
        diagram_type: Type of diagram
        
    Returns:
        Tuple of (content_prompt, diagram_prompt)
    """
    manager = get_prompt_manager()
    content = str(manager.get_content_prompt(diagram_type))
    diagram = str(manager.get_diagram_prompt(diagram_type))
    return content, diagram

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\prompts.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext-mobile\services\llm\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\main.py:
from __future__ import annotations

import logging
from pathlib import Path
import os
import sys

import uvicorn
from fastapi import FastAPI

# Add the project's parent directory to the system path
sys.path.insert(0, str(Path(__file__).parent))

from pitext_codegen.api.routes import router as api_router, setup_static_routes
from pitext_codegen.api.middleware import setup_middleware
from pitext_codegen.core.config import get_config

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

config = get_config()

# Update the API_PREFIX to /codegen
config.API_PREFIX = "/codegen"

app = FastAPI(title="PiText CodeGen", version="0.1.0")

# 1. Setup Middleware
setup_middleware(app)

# 2. Include the API routes under the /codegen prefix
app.include_router(api_router, prefix=config.API_PREFIX)

# 3. Setup static routes (this handles serving the UI)
setup_static_routes(app)

if __name__ == "__main__":
    port = int(os.getenv("PORT", 8000))
    uvicorn.run("pitext_codegen.main:app", host="0.0.0.0", port=port, reload=True)
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\main.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\render.yaml:
services:

* type: web
  name: pitext-codegen
  env: python
  buildCommand: |
  pip install -r requirements.txt
  startCommand: |
  python -m pitext\_codegen.main
  plan: free
  envVars:

  * key: OPENAI\_API\_KEY
    sync: false  # set via Render dashboard
  * key: PYTHONUNBUFFERED
    value: "1"
    autoDeploy: true

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\render.yaml ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\requirements.txt:
fastapi>=0.110
uvicorn[standard]==0.24.0
openai>=1.14
python-dotenv>=1.0

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\middleware.py:
# api/middleware.py
"""
Middleware configuration for PiText CodeGen.
"""

import logging
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

logger = logging.getLogger(__name__)

def setup_middleware(app: FastAPI) -> None:
    """
    Configure all middleware for the application.
    
    Args:
        app: FastAPI application instance
    """
    # Configure CORS
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    logger.info("CORS middleware configured to allow all origins.")
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\middleware.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\models.py:
# api/models.py
"""
Pydantic models for the CodeGen API.
Defines the contract between the frontend and backend.
"""

from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field

# ============================================================================
# Request Models
# ============================================================================

class GenRequest(BaseModel):
    """Request to generate a diagram."""
    prompt: str = Field(..., description="Natural-language description of what to build")
    language: str = Field("python", examples=["python", "typescript"])

class CodeGenRequest(BaseModel):
    """Request to generate code files after diagram approval."""
    prompt: str
    language: str
    diagram_mermaid: str
    diagram_type: str

class DeepDiveRequest(BaseModel):
    """Request for a detailed explanation of a flowchart node."""
    node_name: str = Field(..., description="The text content of the selected node")
    question: str = Field(..., description="The user's question about the node")
    original_prompt: str = Field(..., description="The initial requirement prompt")
    flowchart: str = Field(..., description="The complete Mermaid flowchart for context")

# ============================================================================
# Response Models
# ============================================================================

class FileStub(BaseModel):
    """Represents a single generated code file."""
    path: str
    content: str

class DiagramResponse(BaseModel):
    """Response for the diagram generation step."""
    diagram_mermaid: str
    diagram_type: str = "flowchart"
    prompt: str
    language: str

class CodeResponse(BaseModel):
    """Response for the code generation step."""
    files: List[FileStub]
    deepdive_md: str

class DeepDiveResponse(BaseModel):
    """Response for a deep-dive explanation."""
    success: bool = True
    explanation: str
    node_name: str

class ErrorResponse(BaseModel):
    """Standard error response format."""
    success: bool = False
    detail: str = Field(..., description="Error message")
    error_type: Optional[str] = Field(None, description="Error classification")

class HealthResponse(BaseModel):
    """Health check response."""
    message: str = "CodeGen Service is running!"
    workflow: str = "2-step"

# ============================================================================
# Utility Functions
# ============================================================================

def create_error_response(
    detail: str, 
    error_type: Optional[str] = None
) -> Dict[str, Any]:
    """Create a standardized error response dictionary."""
    return ErrorResponse(
        detail=detail,
        error_type=error_type
    ).dict()
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\models.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\routes.py:
# api/routes.py
"""
API route definitions for PiText CodeGen.
"""

import logging
from pathlib import Path

from fastapi import APIRouter, FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse

from pitext_codegen.api.models import (
    GenRequest,
    CodeGenRequest,
    DeepDiveRequest,
    DiagramResponse,
    CodeResponse,
    DeepDiveResponse,
    HealthResponse,
    FileStub
)
from pitext_codegen.core.config import get_config
# Assuming the logic will be moved to services.llm.codegen
from pitext_codegen.services.llm.codegen import (
        generate_mermaid_direct,
    generate_single_code_file,
    deepdive_node
)

logger = logging.getLogger(__name__)
config = get_config()

# Create the main router
router = APIRouter()


# ============================================================================
# 2-Step Workflow Routes
# ============================================================================

@router.post("/generate-diagram", response_model=DiagramResponse)
async def generate_diagram_only(req: GenRequest):
    """STEP 1: Generate only the diagram for user approval."""
    try:
        logger.info(f"Generating diagram for prompt: {req.prompt[:50]}...")
        diagram = await generate_mermaid_direct(req.prompt)
        logger.info("Diagram generation completed successfully")
        return DiagramResponse(
            diagram_mermaid=diagram,
            prompt=req.prompt,
            language=req.language
        )
    except Exception as e:
        logger.error(f"Diagram generation failed: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/generate-code", response_model=CodeResponse)
async def generate_code_files(req: CodeGenRequest):
    """STEP 2: Generate the actual code files after diagram approval."""
    try:
        logger.info(f"Generating code files for {req.language} project...")
        files = await generate_single_code_file(req.prompt, req.diagram_mermaid, req.language)
        
        deepdive = f"# Implementation Overview\n\nThis code implements: {req.prompt}\n\n## Files Generated\n"
        for filename in files.keys():
            deepdive += f"- **{filename}**: Main implementation file\n"
        
        logger.info(f"Code generation completed with {len(files)} files")
        return CodeResponse(
            files=[FileStub(path=p, content=c) for p, c in files.items()],
            deepdive_md=deepdive
        )
    except Exception as e:
        logger.error(f"Code generation failed: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/deepdive-node", response_model=DeepDiveResponse)
async def deepdive_node_endpoint(req: DeepDiveRequest):
    """Generate detailed explanation for a specific flowchart node."""
    try:
        logger.info(f"Generating deepdive for node: {req.node_name} with question: {req.question}")
        explanation = await deepdive_node(
            node_name=req.node_name,
            original_prompt=req.original_prompt,
            flowchart=req.flowchart,
            question=req.question # Pass question to the service layer
        )
        return DeepDiveResponse(explanation=explanation, node_name=req.node_name)
    except Exception as e:
        logger.error(f"Node deepdive failed: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/health", response_model=HealthResponse)
def health_check():
    """Health check endpoint."""
    return HealthResponse()

# ============================================================================
# Static File Serving - FIXED
# ============================================================================

def setup_static_routes(app: FastAPI):
    """
    Set up static file serving for the CodeGen frontend.
    
    Args:
        app: FastAPI application instance
    """
    public_dir = config.BASE_DIR / "public"
    
    # Mount static assets (CSS, JS, images) under subdirectories
    app.mount(
        f"{config.API_PREFIX}/css",
        StaticFiles(directory=str(public_dir / "css")),
        name="codegen_css"
    )
    
    app.mount(
        f"{config.API_PREFIX}/js",
        StaticFiles(directory=str(public_dir / "js")),
        name="codegen_js"
    )
    
    # Mount other assets if they exist
    assets_dir = public_dir / "assets"
    if assets_dir.exists():
        app.mount(
            f"{config.API_PREFIX}/assets",
            StaticFiles(directory=str(assets_dir)),
            name="codegen_assets"
        )
    
    # Explicit route handlers for the main page
    @app.get(config.API_PREFIX, include_in_schema=False)
    @app.get(f"{config.API_PREFIX}/", include_in_schema=False)
    async def codegen_root():
        """Serve the CodeGen web interface."""
        index_path = public_dir / "index.html"
        if not index_path.exists():
            logger.error(f"index.html not found at {index_path}")
            raise HTTPException(
                status_code=500,
                detail="Application files not found"
            )
        return FileResponse(index_path)
    
    # Serve favicon if it exists
    favicon_path = public_dir / "PiText_favicon.ico"
    if favicon_path.exists():
        @app.get(f"{config.API_PREFIX}/PiText_favicon.ico", include_in_schema=False)
        async def favicon():
            return FileResponse(favicon_path)
    
    # Serve background image if it exists
    bg_path = public_dir / "PiText_background.png"
    if bg_path.exists():
        @app.get(f"{config.API_PREFIX}/PiText_background.png", include_in_schema=False)
        async def background():
            return FileResponse(bg_path)
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\routes.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\api\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\core\config.py:
# core/config.py
"""
Configuration management for PiText CodeGen.
Centralizes all environment variables and configuration settings.
"""

import os
from pathlib import Path
from typing import Optional
from functools import lru_cache
from dotenv import load_dotenv

# Load environment variables
load_dotenv()


class Config:
    """Application configuration singleton."""
    
    # Paths
    BASE_DIR: Path = Path(__file__).parent.parent
    PROMPTS_DIR: Path = BASE_DIR / "prompts"
    
    # API Settings
    API_PREFIX: str = ""
    HOST: str = "0.0.0.0"
    PORT: int = int(os.getenv("PORT", 8000))
    
    # OpenAI Settings
    OPENAI_API_KEY: Optional[str] = os.getenv("OPENAI_API_KEY")
    OPENAI_MODEL: str = "gpt-4.1"
    
    @classmethod
    def validate(cls) -> None:
        """Validate required configuration."""
        if not cls.OPENAI_API_KEY:
            raise ValueError(
                "OPENAI_API_KEY environment variable is required. "
                "Please set it in your .env file or environment."
            )
        
        if not cls.PROMPTS_DIR.exists():
            raise ValueError(f"Prompts directory not found: {cls.PROMPTS_DIR}")

    @classmethod
    def get_prompt_path(cls, filename: str) -> Path:
        """Get the full path to a prompt file."""
        path = cls.PROMPTS_DIR / filename
        if not path.exists():
            raise FileNotFoundError(f"Prompt file not found: {filename}")
        return path

@lru_cache()
def get_config() -> type(Config):
    """Get validated configuration singleton."""
    Config.validate()
    return Config

# Validate configuration on module import
try:
    Config.validate()
except ValueError as e:
    import warnings
    warnings.warn(f"Configuration warning: {e}")
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\core\config.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\core\sanitizer.py:
# core/sanitizer.py
"""
Mermaid diagram sanitization utilities for CodeGen.
"""

import re

def sanitize_mermaid(snippet: str) -> str:
    """
    Sanitizes and fixes Mermaid diagram code from LLM output.
    
    Args:
        snippet: Raw Mermaid code from LLM
        
    Returns:
        Cleaned Mermaid code ready for rendering
    """
    content = snippet.strip()
    
    # Remove code block markers if present
    if content.startswith("```"):
        lines = content.split('\n')
        # Remove first line if it's just ``` or ```mermaid
        if lines[0].strip().startswith("```"):
            lines = lines[1:]
        # Remove last line if it's just ```
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        content = '\n'.join(lines)
            
    return content.strip()
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\core\sanitizer.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\core\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\core\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\prompts\code_generator.txt:
You are a senior {language} developer. Given a software requirement and its corresponding flowchart, generate a single, complete code file that implements the functionality.

Input:
- Original requirement/prompt
- Mermaid flowchart showing the architecture

Output:
Generate ONE complete, working code file that follows the flowchart structure. Include:
- All necessary imports
- Proper function definitions
- Main execution logic
- Error handling where appropriate
- Clear comments explaining key sections
- Docstrings for functions/classes
- Follow {language} best practices

Format your response as:
```filename.ext
[complete code here]
```

Focus on:
- Implementing the logical flow shown in the diagram
- Clean, readable code structure
- Proper separation of concerns within the single file
- Realistic, working implementation
- Comments that map back to flowchart nodes where helpful

Generate practical, executable code that directly corresponds to the flowchart architecture.
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\prompts\code_generator.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\prompts\deepdive.txt:
You are a technical mentor providing detailed explanations of code architecture components. 

You will be given:
- A specific node/component from a flowchart representing a code piece
- A user's specific question about that node
- Context about the overall code requirement

Your task is to directly answer the user's question about the selected component in the context of the overall code.

Focus on:
- Directly answering their specific question
- Providing practical implementation guidance relevant to their question
- Mentioning specific tools, libraries, or patterns when relevant

Keep your response concise but informative (around 100 words). Be conversational and helpful, as if you're mentoring a developer who clicked on a specific part of their code diagram to learn more about it.

If the question is vague, provide the most useful general information about that component's purpose and implementation.
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\prompts\deepdive.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\prompts\mermaid_generator.txt:
You are a diagram-making assistant that creates flowcharts which represent the code process flow.
Given a coding requirement, output **only** the Mermaid flowchart code showing the logical flow and structure.

Follow this pattern:

```mermaid
%%{init:{
  "theme":"base",
  "flowchart":{
    "useMaxWidth":true,
    "fontFamily":"sans-serif",
    "fontSize":"14px"
  },
  "themeVariables":{
    "lineColor":"#fbbf24",
    "arrowColor":"#fbbf24",
    "arrowheadColor":"#fbbf24"
  }
}}%%
flowchart TB
  %% styles
  classDef subgraphStyle fill:#0f0f0f,stroke:#fbbf24,stroke-width:2px,color:#ffffff;
  classDef processStyle fill:#fbbf24,stroke:#f59e0b,stroke-width:2px,color:#000000,font-weight:bold;
  classDef decisionStyle fill:#10b981,stroke:#059669,stroke-width:2px,color:#ffffff,font-weight:bold;

  %% top setup bar (unchanged)
  subgraph Setup[" Setup "]
    direction LR
    Import[Import modules/libraries]:::processStyle
    DefineVars[Define variables/constants]:::processStyle
    DefineFunc[Define functions]:::processStyle
    Import ~~~ DefineVars ~~~ DefineFunc
  end

  %% invisible container for the execution logic (no border or fill)
  subgraph Execution_Logic_head[" "]
    direction TB
    ExecLabel[Execution Logic]:::subgraphStyle
    Input[Input Data]:::processStyle

  %% Invisible connection to the Input node

    ExecLabel~~~Input

  %% Full execution logic, decide these as needed

    Input-->Process[Process data]:::processStyle
    Process-->Decision{Condition checks}:::decisionStyle
    Decision-->|True|Action1[Perform action A]:::processStyle
    Decision-->|False|Action2[Perform action B]:::processStyle
    Action1-->Output[Display/Save results]:::processStyle
    Action2-->Output
    Output-->Cleanup[Cleanup/Close resources]:::processStyle

  %% Numbering layout, Link the first one to the execlabel for vertical orientation
    ExecLabel~~~1
  %% The rest should be created and linked, as many as functional execution steps are needed, and match the flow vertically
    1~~~2~~~3~~~4~~~5~~~6
end

  %% connect setup section to the execution section using a invisible connector, for orientation
  Setup ~~~ Execution_Logic_head

  %% styling directives
  class Setup subgraphStyle
  style Execution_Logic_head fill:transparent,stroke:transparent
  ```

Rules:

* Use `[Step Name]` for process boxes
* Use `{Question?}` for decision diamonds
* Use `([Label])` for start/end nodes
* Use `-->` for flow arrows
* Use `-->|Label|` for labeled connections
* Every process step must reside in one of two subgraphs: `Setup` or `Execution_Logic_head`
* Group initialization steps in the `Setup` subgraph
* Use `direction LR` inside `Setup` and `direction TB` inside execution logic
* Use `<br/>` for line breaks in node labels
* Show key components: imports, setup, main logic, output, cleanup
* Include decision points only when they apply to the requirement
* Keep text slightly descriptive within nodes
* Do not use any special characters in the node texts. Give simple representation
* Always use the same styling and fonts shown in the example
* Use `style Execution_Logic_head fill:transparent,stroke:transparent` exactly once
* Do not include comments other than the `%% styles` and `%% connect` markers
* Ensure all node IDs are unique and numeric labels are sequential
* Decide the number of setup steps and execution steps based on the specific code request
* Do not use any special characters inside the node text whatsoever. Only text and numbers
* **Numeric spacer node rules**:

  * Label spacer nodes with plain numbers `1`, `2`, `3`, …
  * Chain them in order using `~~~` (e.g. `ExecLabel~~~1`, `1~~~2`, …)
  * Start numbering at `1` and increment by `1` with no gaps
  * Include one spacer per vertical gap needed before the first real execution step
  * Do not style spacer nodes or reuse numbers for other nodes
  * Spacer chain must appear immediately after `ExecLabel` and before any real arrow flows

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\prompts\mermaid_generator.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\index.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>PiText CodeGen</title>
  <link rel="icon" href="/codegen/PiText_favicon.ico" type="image/x-icon"/>
  <link rel="apple-touch-icon" href="/codegen/PiText_favicon.ico">

  <link rel="stylesheet" href="/codegen/css/styles.css">

  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
</head>
<body>
  <h1>PiText <span style="color:#FFD600;">CodeGen!</span></h1>
  <p class="banner-sub">Get Code. But first, the <b>codeflow.</b></p>
  <p class="banner-example">Try:<br><span class="eg">"Build a Flask API for a todo app"</span><br><span class="eg">"Create a React component for user profiles"</span></p>

  <div class="input-area">
    <textarea id="prompt" placeholder="Describe the code you want to generate..." rows="4"></textarea>
    <div class="input-options">
      <select id="language">
        <option value="python">Python</option>
        <option value="typescript">TypeScript</option>
        <option value="javascript">JavaScript</option>
        <option value="go">Go</option>
        <option value="rust">Rust</option>
      </select>
      <button id="generateBtn">Create Diagram</button>
    </div>
  </div>

  <div id="diagram-section" class="diagram-section" style="display: none;">
    <h3>Proposed Code Flow</h3>
    
    <div class="diagram-layout">
      <div class="diagram-main">
        <div id="diagram-container" class="diagram-container">
          </div>
      </div>
      
      <div class="diagram-sidebar">
        <div id="selectionIndicator" class="selection-indicator">
          <div class="selection-display">
            <strong>Selected:</strong> <span id="selectedText"></span>
          </div>
          <div class="deep-dive-input">
            <input id="deepDiveQuery" placeholder="Ask about this node..." />
            <button id="askBtn">Ask</button>
          </div>
        </div>

        <div id="deepDiveResponse" class="deep-dive-response"></div>
      </div>
    </div>
    
    <div class="approval-section">
      <div class="action-buttons">
        <button id="approveBtn" class="approve-btn">
          ✅ Generate Code File
        </button>
        <button id="rejectBtn" class="reject-btn">
          🔄 Start Over
        </button>
      </div>
    </div>
  </div>

  <div id="results" class="results-container">
    <div class="placeholder">Your code will appear here.</div>
  </div>

  <script type="module" src="/codegen/js/app.js"></script>
</body>
</html>
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\index.html ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\styles.css:
/* public/styles.css */
/* Main entry point - imports all other CSS files in correct order */

/* Base styles */
@import url('./base/reset.css');
@import url('./base/typography.css');

/* Layout styles */
@import url('./layout/main.css');

/* Component styles */
@import url('./components/forms.css');
@import url('./components/buttons.css');
@import url('./components/diagram.css');
@import url('./components/selection.css');
@import url('./components/results.css');

/* Responsive styles */
@import url('./responsive/mobile.css');
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\styles.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\base\reset.css:
/* css/base/reset.css */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\base\reset.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\base\typography.css:
/* css/base/typography.css */
body {
  background: #000 url("/codegen/PiText_background.png") center/100% auto no-repeat fixed;
  color: #f0f0f0;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  margin: 2rem;
  text-align: center;
  min-height: 100vh;
}

h1 {
  color: #fff;
  text-shadow: 0 0 8px rgba(0,0,0,.8);
  font-size: 2.5rem;
  margin-bottom: 1rem;
}

.banner-sub {
  font-size: 1.1rem;
  margin: 0.5rem auto;
  color: rgba(255, 255, 255, 0.9);
}

.banner-example {
  font-size: 0.95rem;
  margin: 0.5rem auto 2rem;
  color: rgba(255, 255, 255, 0.7);
}

.eg {
  color: #FFD600;
  font-weight: 500;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\base\typography.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\buttons.css:
/* css/components/buttons.css */
#generateBtn {
  padding: 0.75rem 2rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: 8px;
  border: none;
  background: linear-gradient(45deg, #FFD600, #FFA000);
  color: #000;
  cursor: pointer;
  transition: all 0.3s ease;
}

#generateBtn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(255, 214, 0, 0.4);
}

#generateBtn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.approve-btn {
  padding: 0.75rem 2rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: 8px;
  border: none;
  background: linear-gradient(45deg, #4CAF50, #45a049);
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
}

.approve-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}

.approve-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.reject-btn, .restart-btn {
  padding: 0.75rem 2rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: 8px;
  border: 2px solid #FFD600;
  background: transparent;
  color: #FFD600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.reject-btn:hover, .restart-btn:hover {
  background: rgba(255, 214, 0, 0.1);
  transform: translateY(-2px);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\buttons.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\diagram.css:
/* css/components/diagram.css */
.diagram-container {
  width: 100%;
  min-height: 300px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.mermaid {
  background: rgba(255,255,255,.95);
  border-radius: 8px;
  padding: 1.5rem;
  margin: 0 auto;
  display: block;
  width: 100%;
  max-width: 100%;
  overflow-x: auto;
  box-sizing: border-box;
}

.mermaid text {
  cursor: text;
  user-select: text;
  text-shadow: 1px 1px 2px rgba(255,255,255,.8) !important;
}

.mermaid .nodeLabel {
  filter: drop-shadow(0 0 3px rgba(255,255,255,.9)) !important;
}

.mermaid g.node {
  cursor: pointer;
}

.mermaid g.node:hover rect,
.mermaid g.node:hover circle,
.mermaid g.node:hover ellipse,
.mermaid g.node:hover polygon {
  stroke-width: 3px !important;
  stroke: #FFD600 !important;
}

.node-selected rect,
.node-selected circle,
.node-selected ellipse,
.node-selected polygon {
  stroke-width: 4px !important;
  stroke: #FFD600 !important;
}

.node-selected text,
.node-selected tspan,
.node-selected .nodeLabel {
  font-weight: bold !important;
  font-size: 15px !important;
  filter: drop-shadow(0 0 2px #FFD600) !important;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\diagram.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\forms.css:
/* css/components/forms.css */
.input-options {
  display: flex;
  gap: 1rem;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
}

#prompt {
  width: 100%;
  padding: 1rem;
  font-size: 1rem;
  border-radius: 8px;
  border: 2px solid rgba(255,255,255,.2);
  background: rgba(255,255,255,.1);
  color: #fff;
  resize: vertical;
  min-height: 100px;
  font-family: inherit;
  margin-bottom: 1rem;
  box-sizing: border-box;
}

#prompt:focus {
  outline: none;
  border-color: #FFD600;
  background: rgba(255,255,255,.15);
}

#prompt::placeholder {
  color: rgba(255,255,255,.6);
}

select {
  padding: 0.75rem;
  font-size: 0.95rem;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,.3);
  background: rgba(255,255,255,.1);
  color: #fff;
  min-width: 150px;
}

select option {
  background: #333;
  color: #fff;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\forms.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\results.css:
/* css/components/results.css */
.loading {
  color: #FFD600;
  font-size: 1.2rem;
  padding: 2rem;
}

.error {
  color: #ff6b6b;
  padding: 2rem;
}

.success {
  color: #4CAF50;
  font-size: 1.2rem;
  margin-bottom: 2rem;
  font-weight: 600;
}

.file-item {
  margin: 1.5rem 0;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,.2);
  text-align: left;
}

.file-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem 1rem;
  background: rgba(255,255,255,.1);
  border-bottom: 1px solid rgba(255,255,255,.2);
}

.file-path {
  font-family: 'Courier New', monospace;
  font-weight: 600;
  color: #FFD600;
  font-size: 0.9rem;
}

.file-actions {
  display: flex;
  gap: 0.5rem;
}

.copy-btn, .download-btn {
  padding: 0.25rem 0.75rem;
  font-size: 0.8rem;
  border: 1px solid rgba(255,255,255,.3);
  border-radius: 3px;
  background: rgba(255,255,255,.1);
  color: #fff;
  cursor: pointer;
  transition: all 0.2s ease;
}

.copy-btn:hover, .download-btn:hover {
  background: rgba(255,255,255,.2);
  border-color: rgba(255,255,255,.5);
}

.file-content {
  padding: 0;
  background: rgba(0,0,0,.5);
  overflow-x: auto;
}

.file-content pre {
  margin: 0;
  padding: 1rem;
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  line-height: 1.4;
  color: #f8f8f2;
  white-space: pre-wrap;
  overflow-x: auto;
}

.file-content code {
  font-family: 'Courier New', monospace;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\results.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\selection.css:
/* css/components/selection.css */
.selection-indicator {
  display: none;
  margin-bottom: 1rem;
  padding: 1rem;
  background: rgba(0,0,0,.8);
  color: #fff;
  border-radius: 8px;
  font-size: 14px;
  text-align: left;
}

.selection-indicator.active {
  display: block;
}

.selection-display {
  margin-bottom: 1rem;
  padding-bottom: .5rem;
  border-bottom: 1px solid rgba(255,255,255,.3);
}

.deep-dive-input {
  display: flex;
  gap: .5rem;
  align-items: center;
}

.deep-dive-input input {
  flex: 1;
  padding: .5rem;
  font-size: 14px;
  background: rgba(255,255,255,.1);
  border: 1px solid rgba(255,255,255,.3);
  color: #fff;
  border-radius: 4px;
}

.deep-dive-input input::placeholder {
  color: rgba(255,255,255,.6);
}

.deep-dive-input button {
  padding: .5rem 1rem;
  font-size: 14px;
  background: rgba(255,255,255,.2);
  color: #fff;
  border: 1px solid rgba(255,255,255,.3);
  border-radius: 4px;
  transition: background .2s;
  cursor: pointer;
}

.deep-dive-input button:hover {
  background: rgba(255,255,255,.3);
}

.deep-dive-response {
  display: none;
  margin-top: 1rem;
  padding: 1.5rem;
  background: rgba(0,0,0,.7);
  color: #fff;
  border-radius: 8px;
  font-size: 14px;
  line-height: 1.6;
  text-align: left;
}

.deep-dive-response.active {
  display: block;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\components\selection.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\layout\main.css:
/* css/layout/main.css */
.input-area {
  max-width: 800px;
  margin: 0 auto 2rem;
  padding: 1.5rem;
  background: rgba(255,255,255,.1);
  border-radius: 12px;
  backdrop-filter: blur(10px);
}

.diagram-section {
  max-width: 95vw;
  margin: 2rem auto;
  background: rgba(255,255,255,.1);
  border-radius: 12px;
  backdrop-filter: blur(2px);
  border: 1px solid rgba(255,255,255,.3);
  padding: 2rem;
}

.diagram-layout {
  display: flex;
  gap: 2rem;
  align-items: flex-start;
  margin: 1.5rem 0;
}

.diagram-main {
  flex: 0 0 70%;
  min-height: 300px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.diagram-sidebar {
  flex: 0 0 30%;
  min-width: 300px;
  max-width: 400px;
}

.results-container {
  max-width: 95vw;
  margin: 2rem auto;
  min-height: 60vh;
  background: rgba(255,255,255,.1);
  border-radius: 12px;
  backdrop-filter: blur(2px);
  border: 1px solid rgba(255,255,255,.3);
  padding: 2rem;
}

.placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 50vh;
  font-size: 1.2rem;
  color: rgba(255,255,255,.6);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\layout\main.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\responsive\mobile.css:
/* css/responsive/mobile.css */
@media (max-width: 768px) {
  body {
    margin: 1rem;
  }
  
  h1 {
    font-size: 2rem;
  }
  
  .input-options {
    flex-direction: column;
  }
  
  .input-options > * {
    width: 100%;
    max-width: 300px;
  }
  
  .action-buttons {
    flex-direction: column;
  }
  
  .approve-btn, .reject-btn, .restart-btn {
    width: 100%;
    max-width: 300px;
  }
  
  .diagram-section, .results-container {
    margin: 1rem auto;
    padding: 1rem;
  }
  
  .diagram-layout {
    flex-direction: column;
    gap: 1rem;
  }
  
  .diagram-sidebar {
    min-width: auto;
    max-width: none;
  }
  
  .file-header {
    flex-direction: column;
    gap: 0.5rem;
    align-items: stretch;
  }
  
  .selection-indicator {
    margin: 0.5rem 0;
    padding: 0.75rem;
  }
  
  .deep-dive-response {
    margin: 0.5rem 0;
    padding: 1rem;
  }
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\css\responsive\mobile.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\app.js:
// js/app.js
import { state } from './state.js';
import { setupTextSelection, resetSelection } from './selectionHandler.js';
import { askAboutSelection } from './deepDive.js';

let mermaidReady = false;

// Initialize Mermaid
const checkMermaid = setInterval(() => {
  if (window.mermaid) {
    mermaidReady = true;
    clearInterval(checkMermaid);
    console.log('Mermaid ready');
  }
}, 100);

// Wire up event listeners
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('generateBtn').addEventListener('click', createDiagram);
  document.getElementById('approveBtn').addEventListener('click', generateCodeFiles);
  document.getElementById('rejectBtn').addEventListener('click', startOver);
  document.getElementById('askBtn').addEventListener('click', askAboutSelection);
  
  document.getElementById('prompt').addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'Enter') {
      createDiagram();
    }
  });

  document.getElementById('deepDiveQuery').addEventListener('keypress', e => {
    if (e.key === 'Enter') askAboutSelection();
  });
});

// STEP 1: Create Mermaid diagram
async function createDiagram() {
  const prompt = document.getElementById('prompt').value.trim();
  if (!prompt) {
    alert('Please enter a description of the code you want to generate.');
    return;
  }

  const language = document.getElementById('language').value;
  const generateBtn = document.getElementById('generateBtn');
  const diagramSection = document.getElementById('diagram-section');
  const diagramContainer = document.getElementById('diagram-container');

  resetSelection();
  state.currentQuery = prompt;

  generateBtn.disabled = true;
  generateBtn.textContent = 'Creating Diagram...';
  diagramContainer.innerHTML = '<p class="loading">🔄 Creating code flow... Please wait.</p>';
  diagramSection.style.display = 'block';

  try {
    const response = await fetch('/codegen/generate-diagram', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        prompt: prompt,
        language: language,
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || `HTTP ${response.status}`);
    }

    const diagramData = await response.json();
    state.currentDiagramData = diagramData;
    showDiagramPreview(diagramData);

  } catch (error) {
    diagramContainer.innerHTML = `<p class="error">❌ Diagram creation failed: ${error.message}</p>`;
  } finally {
    generateBtn.disabled = false;
    generateBtn.textContent = 'Create Diagram';
  }
}

function showDiagramPreview(diagramData) {
  const diagramContainer = document.getElementById('diagram-container');
  
  diagramContainer.innerHTML = `<div class="mermaid">${diagramData.diagram_mermaid}</div>`;
  
  if (mermaidReady) {
    setTimeout(async () => {
      try {
        await window.mermaid.init(undefined, diagramContainer.querySelector('.mermaid'));
        console.log('Diagram rendered successfully');
        setupTextSelection(diagramContainer);
      } catch (error) {
        console.error('Mermaid rendering failed:', error);
        diagramContainer.innerHTML = `
          <div class="error">
            <h4>❌ Diagram Rendering Failed</h4>
            <p>Raw Mermaid code:</p>
            <pre>${escapeHtml(diagramData.diagram_mermaid)}</pre>
          </div>
        `;
      }
    }, 100);
  } else {
    diagramContainer.innerHTML = '<p class="error">Mermaid not ready. Please refresh the page.</p>';
  }
}

// STEP 2: Generate code files after user approval
async function generateCodeFiles() {
  if (!state.currentDiagramData) {
    alert('No diagram data available. Please start over.');
    return;
  }

  const approveBtn = document.getElementById('approveBtn');
  const rejectBtn = document.getElementById('rejectBtn');
  const resultsDiv = document.getElementById('results');

  approveBtn.disabled = true;
  rejectBtn.disabled = true;
  approveBtn.textContent = 'Generating Code...';
  resultsDiv.innerHTML = '<p class="loading">🔄 Generating code file... This may take 20-30 seconds.</p>';

  try {
    const response = await fetch('/codegen/generate-code', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(state.currentDiagramData)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || `HTTP ${response.status}`);
    }

    const codeData = await response.json();
    showFinalResults(codeData);

  } catch (error) {
    resultsDiv.innerHTML = `<p class="error">❌ Code generation failed: ${error.message}</p>`;
  } finally {
    approveBtn.disabled = false;
    rejectBtn.disabled = false;
    approveBtn.textContent = '✅ Generate Code Files';
  }
}

function showFinalResults(codeData) {
  const resultsDiv = document.getElementById('results');
  
  let html = '<div class="success">🎉 Complete! Your code has been generated successfully.</div>';
  
  if (codeData.files && codeData.files.length > 0) {
    html += `<h3>📁 Generated Code File(s)</h3>`;
    codeData.files.forEach(file => {
      html += `
        <div class="file-item">
          <div class="file-header">
            <span class="file-path">${file.path}</span>
            <div class="file-actions">
              <button onclick="copyFileContent(this)" class="copy-btn">Copy</button>
              <button onclick="downloadFile(this)" class="download-btn">Download</button>
            </div>
          </div>
          <div class="file-content">
            <pre><code>${escapeHtml(file.content)}</code></pre>
          </div>
        </div>
      `;
    });
  }

  html += `
    <div class="final-actions">
      <button onclick="startOver()" class="restart-btn">🔄 Generate New Code</button>
    </div>
  `;
  
  resultsDiv.innerHTML = html;
}

function startOver() {
  state.currentDiagramData = null;
  state.currentQuery = '';
  resetSelection();
  
  document.getElementById('prompt').value = '';
  document.getElementById('diagram-section').style.display = 'none';
  document.getElementById('results').innerHTML = '<div class="placeholder">Your generated code will appear here.</div>';
  document.getElementById('generateBtn').textContent = 'Create Diagram';
  
  document.getElementById('prompt').focus();
}

function copyFileContent(button) {
    const fileItem = button.closest('.file-item');
    const code = fileItem.querySelector('code').textContent;
    navigator.clipboard.writeText(code).then(() => {
        showToast('Copied to clipboard!');
    }).catch(err => {
        console.error('Copy failed:', err);
    });
}

function downloadFile(button) {
    const fileItem = button.closest('.file-item');
    const code = fileItem.querySelector('code').textContent;
    const path = fileItem.querySelector('.file-path').textContent;
    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = path;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function showToast(message) {
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #4CAF50;
    color: white;
    padding: 1rem;
    border-radius: 4px;
    z-index: 1001;
    animation: fadeIn 0.3s ease-in;
  `;
  document.body.appendChild(toast);

  setTimeout(() => {
    toast.style.animation = 'fadeOut 0.3s ease-out';
    setTimeout(() => document.body.removeChild(toast), 300);
  }, 2000);
}

// Make functions globally available for inline event handlers
window.copyFileContent = copyFileContent;
window.downloadFile = downloadFile;
window.startOver = startOver;
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\app.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\deepDive.js:
// js/deepDive.js
import { state } from './state.js';

function addDeepDiveUtilities(panel) {
  if (!panel || panel.querySelector('.deep-utils')) return;
  
  const utils = document.createElement('div');
  utils.className = 'deep-utils';

  const copyBtn = document.createElement('button');
  copyBtn.textContent = 'Copy';
  copyBtn.onclick = () => navigator.clipboard.writeText(panel.innerText.trim());

  const saveBtn = document.createElement('button');
  saveBtn.textContent = 'Save TXT';
  saveBtn.onclick = () => {
    const blob = new Blob([panel.innerText.trim()], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'deep-dive.txt';
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 250);
  };

  utils.append(copyBtn, saveBtn);
  panel.prepend(utils);
}

export async function askAboutSelection() {
  const q = document.getElementById('deepDiveQuery').value.trim();
  if (!q || !state.selectedText) return;

  const respDiv = document.getElementById('deepDiveResponse');
  respDiv.innerHTML = '<div>Answering...</div>';
  respDiv.classList.add('active');

  try {
    const r = await fetch('/codegen/deepdive-node', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        node_name: state.selectedText,
        question: q,
        original_prompt: state.currentQuery,
        flowchart: state.currentDiagramData ? state.currentDiagramData.diagram_mermaid : ''
      })
    });

    const data = await r.json();
    if (!data.success) {
      throw new Error(data.detail || 'Unknown error');
    }

    respDiv.innerHTML = `
      <h3>Deep Dive: ${state.selectedText}</h3>
      <div class="question">Q: ${q}</div>
      <div class="answer">${data.explanation}</div>
    `;
    addDeepDiveUtilities(respDiv);
    document.getElementById('deepDiveQuery').value = '';
  } catch (err) {
    respDiv.innerHTML = `<div style="color:#ff6b6b;">Error: ${err.message}</div>`;
  }
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\deepDive.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\helpers.js:
// js/helpers.js
export function decodeHTMLEntities(text) {
  const ta = document.createElement('textarea');
  ta.innerHTML = text;
  return ta.value;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\helpers.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\selectionHandler.js:
// js/selectionHandler.js
import { state } from './state.js';
import { decodeHTMLEntities } from './helpers.js';

export function setupTextSelection(container) {
  const svg = container.querySelector('svg');
  if (!svg) return;

  function deselectPrevious() {
    if (state.selectedElement) {
      state.selectedElement.classList.remove('node-selected');
    }
    state.selectedElement = null;
  }

  function updateSelectionUI(text, el) {
    state.selectedText = text;
    state.selectedElement = el;
    document.getElementById('selectedText').textContent = text;
    document.getElementById('selectionIndicator').classList.add('active');
    document.getElementById('deepDiveQuery').focus();
  }

  const nodes = svg.querySelectorAll('g.node');
  nodes.forEach(node => {
    node.style.cursor = 'pointer';
    node.addEventListener('click', function (e) {
      e.stopPropagation();
      deselectPrevious();
      this.classList.add('node-selected');
      let nodeText = '';
      const textEl = this.querySelector('text');
      if (textEl) {
        const tspans = textEl.querySelectorAll('tspan');
        nodeText = tspans.length
          ? Array.from(tspans).map(t => t.textContent.trim()).filter(Boolean).join(' ')
          : textEl.textContent.trim();
      }
      updateSelectionUI(decodeHTMLEntities(nodeText), this);
    });
  });

  svg.addEventListener('click', function (e) {
    if (e.target === svg || (e.target.tagName === 'rect' && e.target.getAttribute('fill') === 'none')) {
      resetSelection();
    }
  });
}

export function resetSelection() {
  if (state.selectedElement) {
    state.selectedElement.classList.remove('node-selected');
    state.selectedElement = null;
  }
  state.selectedText = '';
  document.getElementById('selectionIndicator').classList.remove('active');
  document.getElementById('deepDiveQuery').value = '';
  document.getElementById('deepDiveResponse').classList.remove('active');
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\selectionHandler.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\state.js:
// js/state.js
export const state = {
  selectedElement: null,
  selectedText: '',
  currentQuery: '',
  currentDiagramData: null
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\public\js\state.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\client.py:
# services/llm/client.py
"""
OpenAI client management and LLM interaction utilities for CodeGen.
Provides a singleton client and common LLM operations.
"""

from typing import Optional, List, Dict, Any
from functools import lru_cache
import logging

from openai import AsyncOpenAI
from openai.types.chat import ChatCompletionMessageParam

from pitext_codegen.core.config import get_config

logger = logging.getLogger(__name__)


class LLMClient:
    """Manages OpenAI client instance and provides LLM operations."""
    
    def __init__(self):
        """Initialize the OpenAI client with configuration."""
        config = get_config()
        self.api_key = config.OPENAI_API_KEY
        self.model = config.OPENAI_MODEL
        
        if not self.api_key:
            raise ValueError("OpenAI API key not configured")
        
        self._client = AsyncOpenAI(api_key=self.api_key)
    
    async def generate(
        self,
        messages: List[ChatCompletionMessageParam],
        temperature: float = 0.5,
        max_tokens: Optional[int] = None,
        model: Optional[str] = None,
        **kwargs
    ) -> str:
        """
        Generate a completion using the OpenAI API.
        
        Args:
            messages: List of chat messages
            temperature: Override default temperature
            max_tokens: Maximum tokens in response
            model: Override default model
            **kwargs: Additional OpenAI API parameters
            
        Returns:
            Generated text response
            
        Raises:
            Exception: If API call fails
        """
        try:
            response = await self._client.chat.completions.create(
                model=model or self.model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
                **kwargs
            )
            
            content = response.choices[0].message.content
            if not content:
                raise ValueError("Empty response from OpenAI")
                
            return content.strip()
            
        except Exception as e:
            logger.error(f"OpenAI API error: {str(e)}", exc_info=True)
            raise
    
    async def generate_with_system(
        self,
        system_prompt: str,
        user_prompt: str,
        **kwargs
    ) -> str:
        """
        Convenience method for simple system/user message generation.
        """
        messages: List[ChatCompletionMessageParam] = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
        return await self.generate(messages, **kwargs)


@lru_cache()
def get_llm_client() -> LLMClient:
    """
    Get singleton LLM client instance.
    
    Returns:
        Configured LLMClient instance
    """
    return LLMClient()
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\codegen.py:
# services/llm/codegen.py
"""
Core code generation logic using the LLM.
"""

import logging
from typing import Dict
from pitext_codegen.services.llm.client import get_llm_client
from pitext_codegen.services.llm.prompts import get_prompt_manager
from pitext_codegen.core.sanitizer import sanitize_mermaid

logger = logging.getLogger(__name__)


def _get_extension(language: str) -> str:
    """Get file extension for the given language."""
    extensions = {
        "python": "py",
        "javascript": "js",
        "typescript": "ts",
        "go": "go",
        "rust": "rs",
        "java": "java",
        "cpp": "cpp",
        "c": "c"
    }
    return extensions.get(language.lower(), "txt")

async def generate_mermaid_direct(prompt: str) -> str:
    """Generate Mermaid flowchart directly from user prompt."""
    client = get_llm_client()
    prompt_manager = get_prompt_manager()
    system_prompt = prompt_manager.get("mermaid")
    
    response = await client.generate_with_system(
        system_prompt=system_prompt,
        user_prompt=prompt,
        temperature=0.3,
        max_tokens=1000,
    )
    return sanitize_mermaid(response)

async def generate_single_code_file(prompt: str, diagram: str, language: str) -> Dict[str, str]:
    """Generate a single complete code file from prompt + diagram."""
    client = get_llm_client()
    prompt_manager = get_prompt_manager()
    system_prompt = prompt_manager.get("code").format(language=language)
    user_content = f"## Requirement\n{prompt}\n\n## Architecture Diagram\n{diagram}"
    
    response = await client.generate_with_system(
        system_prompt=system_prompt,
        user_prompt=user_content,
        temperature=0.5,
        max_tokens=2500,
    )
    
    # Parse the response to extract the single file
    files = {}
    lines = response.splitlines()
    current_path = None
    current_lines = []
    
    for line in lines:
        if line.startswith("```") and not current_path:
            parts = line.strip("` ").split()
            current_path = parts[0] if parts and "." in parts[0] else f"main.{_get_extension(language)}"
        elif line.startswith("```") and current_path:
            files[current_path] = "\n".join(current_lines) + "\n"
            current_path, current_lines = None, []
        elif current_path:
            current_lines.append(line)
    
    # If no code blocks found, use entire content as a single file
    if not files and response:
        filename = f"main.{_get_extension(language)}"
        files[filename] = response

    return files

async def deepdive_node(node_name: str, original_prompt: str, flowchart: str, question: str) -> str:
    """Generate detailed explanation for a specific flowchart node."""
    client = get_llm_client()
    prompt_manager = get_prompt_manager()
    system_prompt = prompt_manager.get("deepdive")
    
    user_content = f"""## Original Requirement
{original_prompt}

## Flowchart Context
{flowchart}

## Specific Node to Explain
{node_name}

## User's Question
{question}

Please provide a detailed technical explanation for the "{node_name}" component, directly answering the user's question in the context of the overall system."""
    
    response = await client.generate_with_system(
        system_prompt=system_prompt,
        user_prompt=user_content,
        temperature=0.7,
        max_tokens=600,
    )
    return response
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\codegen.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\prompts.py:
# services/llm/prompts.py
"""
Prompt template management for CodeGen LLM operations.
"""

from pathlib import Path
from typing import Dict
from functools import lru_cache
import logging

from pitext_codegen.core.config import get_config

logger = logging.getLogger(__name__)


class PromptManager:
    """Manages loading and caching of prompt templates."""
    
    PROMPT_FILES = {
        "mermaid": "mermaid_generator.txt",
        "code": "code_generator.txt",
        "deepdive": "deepdive.txt",
    }
    
    def __init__(self):
        self.config = get_config()
        self._cache: Dict[str, str] = {}
        self._load_all_prompts()
    
    def _load_all_prompts(self):
        """Pre-load all known prompts for validation."""
        for key in self.PROMPT_FILES:
            try:
                self.get(key)
            except Exception as e:
                logger.warning(f"Failed to load prompt '{key}': {e}")
    
    def get(self, key: str) -> str:
        """
        Get a prompt template by key.
        
        Args:
            key: Prompt identifier (e.g., "mermaid", "code")
            
        Returns:
            The prompt content string.
            
        Raises:
            KeyError: If prompt not found
        """
        if key not in self._cache:
            if key not in self.PROMPT_FILES:
                raise KeyError(f"Unknown prompt key: '{key}'")
            
            filename = self.PROMPT_FILES[key]
            path = self.config.get_prompt_path(filename)
            content = path.read_text(encoding="utf-8")
            self._cache[key] = content
            logger.debug(f"Loaded prompt '{key}' from {filename}")
        
        return self._cache[key]

@lru_cache()
def get_prompt_manager() -> PromptManager:
    """Get singleton PromptManager instance."""
    return PromptManager()
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\prompts.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_codegen\services\llm\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\.env.example:
OPENAI_API_KEY=your_api_key_here
# Google Maps Authentication - use either API key OR Client ID (not both)
GOOGLE_MAPS_API_KEY=your_google_maps_api_key_here
maps_client_id=your_google_maps_client_id_here
maps_client_secret=your_google_maps_client_secret_here
PORT=3000
RENDER_MODE=html
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\.env.example ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\main.py:
"""Entry point for the pitext_travel micro-service.
Minimal setup that delegates route registration to routes module.
"""
import os
import secrets
from flask import Flask
from pitext_travel.routes.travel import create_travel_blueprint
from pitext_travel.api.chat import bp_chat
from flask_socketio import SocketIO
from pitext_travel.routes.websocket import TravelVoiceNS

# Get the absolute path to the directory where this file is located
base_dir = os.path.abspath(os.path.dirname(__file__))

# Create the main Flask app
app = Flask(
    __name__,
    static_url_path="/travel/static",
    static_folder=os.path.join(base_dir, 'static')
)

# Generate secret key dynamically
app.config['SECRET_KEY'] = os.environ.get('FLASK_SECRET_KEY', secrets.token_hex(32))
app.config['SESSION_COOKIE_NAME'] = 'pitext_travel_session'
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['PERMANENT_SESSION_LIFETIME'] = 3600  # 1 hour

# Register blueprints
app.register_blueprint(create_travel_blueprint(base_dir))
app.register_blueprint(bp_chat)

# Create SocketIO wrapper with async_mode='asyncio'
socketio = SocketIO(app, async_mode='asyncio', cors_allowed_origins="*")

# Register your namespace
socketio.on_namespace(TravelVoiceNS('/travel/voice'))

# The socketio object is the ASGI app
asgi_app = socketio

# Optional: local dev runner
if __name__ == "__main__":
    socketio.run(app, port=int(os.getenv("PORT", 3000)), debug=True)
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\main.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\requirements.txt:
Flask==2.3.2
requests==2.31.0
asgiref>=3.0.0
openai==1.12.0
python-dotenv==1.0.0
flask-cors==4.0.0

python-socketio==5.12.0      # pulled automatically, but pin for safety
python-engineio==4.11.2      # latest 4.x (supports Engine.IO protocol 4)
flask_socketio ==5.3.2
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\__init__.py:
from flask import Flask
from .api.chat import bp_chat     # new import

def create_app():
    app = Flask(__name__)

    app.register_blueprint(bp_chat)
    return app
# This file makes src a Python package

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\chat.py:
# pitext_travel/api/chat.py
import os, json
from flask import Blueprint, request, jsonify, session
import openai
from pitext_travel.api.llm import generate_trip_itinerary

bp_chat = Blueprint("chat", __name__, url_prefix="/travel/api")

# Initialize OpenAI
openai.api_key = os.environ["OPENAI_API_KEY"]

# Keep conversation context
MAX_HISTORY = 20

# Improved function schemas
FUNCTIONS = [
    {
        "name": "plan_trip",
        "description": "Plan a multi-day itinerary for a city. Use this when the user provides BOTH a city name AND number of days.",
        "parameters": {
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "The city name for the trip"
                },
                "days": {
                    "type": "integer", 
                    "description": "Number of days for the trip",
                    "minimum": 1, 
                    "maximum": 14
                }
            },
            "required": ["city", "days"]
        }
    },
    {
        "name": "explain_day",
        "description": "Explain the itinerary for a specific day or provide an overview of all days",
        "parameters": {
            "type": "object",
            "properties": {
                "day_number": {
                    "type": "integer",
                    "description": "The day number to explain (1-based), or 0 for overview",
                    "minimum": 0
                }
            },
            "required": ["day_number"]
        }
    }
]

@bp_chat.route("/chat", methods=["POST"])
def chat():
    user_text = request.json.get("text", "").strip()
    if not user_text:
        return jsonify({"reply": "I didn't catch that."})

    # Initialize session data if needed
    if 'chat_history' not in session:
        session['chat_history'] = []
        session['pending_trip'] = {}
    
    history = session.get('chat_history', [])
    
    # System message that helps the model understand context better
    system_message = {
        "role": "system", 
        "content": """You are a friendly travel planning assistant. Your main job is to help users plan trips by creating detailed itineraries.

IMPORTANT INSTRUCTIONS:
1. When a user mentions wanting to plan a trip to a city but doesn't specify days, ask them how many days they'd like to spend there.
2. When you have BOTH the city name AND number of days, immediately call the plan_trip function.
3. If a user provides a number after you've asked about days, understand that's the number of days for the previously mentioned city.
4. Be conversational but focused on gathering the needed information.
5. Common phrases: "3 days", "three days", "a week" (7 days), "weekend" (2 days), "long weekend" (3 days).
6. When users ask about specific days or want an overview, use the explain_day function.
7. Phrases like "first day", "day 1", "explain the trip", "tell me about day 2" should trigger explain_day.

Current context: """ + json.dumps(session.get('pending_trip', {}))
    }
    
    # Add user message
    history.append({"role": "user", "content": user_text})
    
    # Keep history manageable but include system message
    messages = [system_message] + history[-MAX_HISTORY:]

    try:
        resp = openai.chat.completions.create(
            model="gpt-4.1",
            messages=messages,
            functions=FUNCTIONS,
            function_call="auto",
            temperature=0.7
        ).choices[0].message

        # Handle function calls
        if resp.function_call:
            name = resp.function_call.name
            args = json.loads(resp.function_call.arguments or "{}")

            if name == "plan_trip":
                try:
                    # Generate itinerary
                    itinerary = generate_trip_itinerary(args["city"], args["days"])
                    
                    # Store the itinerary in session
                    session['current_itinerary'] = itinerary
                    session['current_city'] = args["city"]
                    session['current_days'] = args["days"]
                    
                    # Clear pending trip
                    session['pending_trip'] = {}

                    # Add to history
                    history.append({
                        "role": "assistant",
                        "content": f"I've created a wonderful {args['days']}-day itinerary for {args['city']}!"
                    })
                    session['chat_history'] = history
                    session.modified = True

                    return jsonify({
                        "reply": f"I've created a wonderful {args['days']}-day itinerary for {args['city']}! You can see it on the map. Would you like me to explain any specific day or give you an overview?",
                        "itinerary": itinerary
                    })
                except Exception as e:
                    return jsonify({"reply": f"Sorry, I couldn't plan that trip: {str(e)}"})
                    
            elif name == "explain_day":
                if 'current_itinerary' not in session:
                    return jsonify({"reply": "I don't have a current itinerary to explain. Would you like me to plan a trip first?"})
                
                itinerary = session['current_itinerary']
                city = session.get('current_city', 'your destination')
                day_num = args.get("day_number", 0)
                
                if day_num == 0:
                    # Overview
                    reply = f"Here's an overview of your {len(itinerary['days'])}-day trip to {city}:\n\n"
                    for i, day in enumerate(itinerary['days']):
                        reply += f"**{day.get('label', f'Day {i+1}')}**: "
                        stops = [stop['name'] for stop in day['stops']]
                        reply += ", ".join(stops) + "\n"
                else:
                    # Specific day
                    if 0 < day_num <= len(itinerary['days']):
                        day = itinerary['days'][day_num - 1]
                        reply = f"On {day.get('label', f'Day {day_num}')} in {city}, you'll visit:\n\n"
                        for j, stop in enumerate(day['stops'], 1):
                            reply += f"{j}. **{stop['name']}**"
                            if 'placeType' in stop:
                                reply += f" ({stop['placeType'].replace('_', ' ')})"
                            reply += "\n"
                        reply += f"\nThis day includes {len(day['stops'])} stops. Would you like details about any other day?"
                    else:
                        reply = f"I don't have information for day {day_num}. Your trip is {len(itinerary['days'])} days long."
                
                history.append({"role": "assistant", "content": reply})
                session['chat_history'] = history
                session.modified = True
                
                return jsonify({"reply": reply})

        # Regular text response
        else:
            # Add assistant response to history
            history.append({"role": "assistant", "content": resp.content})
            session['chat_history'] = history
            session.modified = True
            
            return jsonify({"reply": resp.content})

    except Exception as e:
        print(f"Chat error: {str(e)}")
        return jsonify({"reply": "I encountered an error. Please try again."})
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\chat.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\config.py:
# api/config.py
"""Configuration management for the travel planner API."""
import os
from dotenv import load_dotenv

load_dotenv()


def get_openai_api_key():
    """Get OpenAI API key from environment."""
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY not set")
    return api_key


def get_google_maps_config():
    """Get Google Maps configuration."""
    return {
        "api_key": os.getenv("GOOGLE_MAPS_API_KEY", ""),
        "client_id": os.getenv("maps_client_id", ""),
        "client_secret": os.getenv("maps_client_secret", "")
    }


def get_port():
    """Get port configuration."""
    return int(os.getenv("PORT", 3000))


def get_render_mode():
    """Get render mode configuration."""
    return os.getenv("RENDER_MODE", "html")
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\config.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\geocoding.py:
# api/geocoding.py
"""Google Maps geocoding and coordinate management."""
import logging
import random
import requests
from pitext_travel.api.config import get_google_maps_config

logger = logging.getLogger(__name__)

# City coordinates database
CITY_COORDS = {
    "paris": (48.8566, 2.3522),
    "london": (51.5074, -0.1278),
    "new york": (40.7128, -74.0060),
    "tokyo": (35.6762, 139.6503),
    "rome": (41.9028, 12.4964),
    "barcelona": (41.3851, 2.1734),
    "amsterdam": (52.3676, 4.9041),
    "berlin": (52.5200, 13.4050),
    "prague": (50.0755, 14.4378),
    "vienna": (48.2082, 16.3738),
    "budapest": (47.4979, 19.0402),
    "madrid": (40.4168, -3.7038),
    "lisbon": (38.7223, -9.1393),
    "dublin": (53.3498, -6.2603),
    "stockholm": (59.3293, 18.0686),
    "copenhagen": (55.6761, 12.5683),
    "oslo": (59.9139, 10.7522),
    "helsinki": (60.1699, 24.9384),
    "athens": (37.9838, 23.7275),
    "istanbul": (41.0082, 28.9784),
    "moscow": (55.7558, 37.6173),
    "dubai": (25.2048, 55.2708),
    "singapore": (1.3521, 103.8198),
    "hong kong": (22.3193, 114.1694),
    "sydney": (33.8688, 151.2093),
    "melbourne": (37.8136, 144.9631),
    "los angeles": (34.0522, -118.2437),
    "san francisco": (37.7749, -122.4194),
    "chicago": (41.8781, -87.6298),
    "miami": (25.7617, -80.1918),
    "toronto": (43.6532, -79.3832),
    "vancouver": (49.2827, -123.1207),
    "mexico city": (19.4326, -99.1332),
    "buenos aires": (34.6118, -58.3960),
    "rio de janeiro": (22.9068, -43.1729),
    "sao paulo": (23.5505, -46.6333),
    "cairo": (30.0444, 31.2357),
    "marrakech": (31.6295, -7.9811),
    "cape town": (33.9249, 18.4241),
    "mumbai": (19.0760, 72.8777),
    "delhi": (28.7041, 77.1025),
    "bangkok": (13.7563, 100.5018),
    "seoul": (37.5665, 126.9780),
    "beijing": (39.9042, 116.4074),
    "shanghai": (31.2304, 121.4737)
}

def get_place_details(place_name, city):
    """
    Use Google Places API Text Search to get coordinates and place types.
    """
    config = get_google_maps_config()
    google_api_key = config.get("api_key")
    
    if not google_api_key:
        logger.warning("No Google Maps API key found, using estimated coordinates")
        lat, lng = get_estimated_coordinates(city)
        return lat, lng, None, None

    try:
        url = "https://maps.googleapis.com/maps/api/place/textsearch/json"
        params = {
            "query": f"{place_name}, {city}",
            "key": google_api_key
        }
        
        response = requests.get(url, params=params, timeout=10)
        data = response.json()

        if data.get("status") == "OK" and data.get("results"):
            result = data["results"][0]
            location = result["geometry"]["location"]
            place_types = result.get("types", [])
            
            # Get the primary type for icon selection
            primary_type = place_types[0] if place_types else None
            
            logger.info(f"Found details for {place_name}: {location['lat']}, {location['lng']}, Types: {place_types}")
            return location["lat"], location["lng"], primary_type, place_types
        else:
            logger.warning(f"Places API search failed for {place_name}: {data.get('status', 'Unknown')}")
            lat, lng = get_estimated_coordinates(city)
            return lat, lng, None, None
            
    except Exception as e:
        logger.error(f"Places API error for {place_name}: {e}")
        lat, lng = get_estimated_coordinates(city)
        return lat, lng, None, None
def get_estimated_coordinates(city):
    """Get estimated coordinates for major cities"""
    # Add small random offset to avoid exact duplicates
    base_lat, base_lng = CITY_COORDS.get(city.lower(), (48.8566, 2.3522))
    offset = random.uniform(-0.01, 0.01)
    return base_lat + offset, base_lng + offset

def enhance_with_geocoding(itinerary, city):
    """Add accurate coordinates and place type to each stop."""
    enhanced = {"days": []}
    
    for day in itinerary.get("days", []):
        enhanced_day = {
            "label": day.get("label", "Day"),
            "color": day.get("color", "#4285f4"),
            "stops": []
        }
        
        for stop in day.get("stops", []):
            place_name = stop.get("name", "Unknown Place")
            # Get lat, lng, primary_type, and all types
            lat, lng, primary_type, place_types = get_place_details(place_name, city)
            
            enhanced_stop = {
                "name": place_name,
                "lat": lat,
                "lng": lng,
                "placeType": primary_type,  # Send place type to frontend
                "types": place_types  # Send all types for more options
            }
            enhanced_day["stops"].append(enhanced_stop)
            
        enhanced["days"].append(enhanced_day)
    
    return enhanced
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\geocoding.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\llm.py:
# api/llm.py
"""OpenAI API integration for generating travel itineraries."""
import json
import re
import logging
from openai import OpenAI
from pitext_travel.api.config import get_openai_api_key
from pitext_travel.api.geocoding import enhance_with_geocoding, get_estimated_coordinates

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_client() -> OpenAI:
    """Return an OpenAI client initialized from the OPENAI_API_KEY env var."""
    api_key = get_openai_api_key()
    return OpenAI(api_key=api_key, timeout=30.0)

def generate_trip_itinerary(city, days=3):
    """
    Generate a multi-day itinerary using OpenAI + Google Geocoding for accurate coordinates.
    """
    logger.info(f"Starting enhanced itinerary generation for {city}, {days} days")
    
    try:
        client = get_client()
        
        # Enhanced prompt for better place names
        system_prompt = (
            "You are a knowledgeable travel expert. Generate a detailed day-by-day itinerary "
            "with specific, well-known attractions and landmarks. "
            "For each stop, provide the exact name as it would appear on Google Maps. "
            "Focus on must-see attractions, museums, landmarks, and popular areas. "
            "Keep each day to 3-4 stops maximum for a comfortable pace. "
            "Return ONLY a JSON object with this exact structure: "
            '{"days":[{"label":"Day 1","color":"#ff6b6b","stops":[{"name":"Exact Place Name"}]}]}'
        )
        
        user_prompt = (
            f"Create a {days}-day itinerary for {city}. Include specific landmark names, "
            f"famous attractions, and notable areas. Make sure place names are accurate "
            f"and would be recognized by Google Maps."
        )

        logger.info("Making OpenAI API call for itinerary...")
        response = client.chat.completions.create(
            model="gpt-4.1",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,  # Lower temperature for more consistent place names
            max_tokens=1500,
            timeout=25
        )
        
        text = response.choices[0].message.content.strip()
        logger.info(f"Received OpenAI response length: {len(text)} characters")
        
        # Log the full response for debugging
        if len(text) < 1000:
            logger.info(f"Full OpenAI response: {text}")
        else:
            logger.info(f"OpenAI response (first 500 chars): {text[:500]}...")
            logger.info(f"OpenAI response (last 500 chars): ...{text[-500:]}")
        
        # Clean and parse JSON
        text = re.sub(r'^```(?:json)?\s*', '', text, flags=re.MULTILINE)
        text = re.sub(r'```\s*$', '', text, flags=re.MULTILINE)
        text = text.strip()
        
        try:
            itinerary = json.loads(text)
            logger.info("Successfully parsed JSON response")
        except json.JSONDecodeError as e:
            logger.error(f"JSON parsing error: {e}")
            logger.error(f"Failed to parse text: {text}")
            
            # Try regex extraction as fallback
            json_match = re.search(r'\{.*\}', text, re.DOTALL)
            if json_match:
                try:
                    itinerary = json.loads(json_match.group(0))
                    logger.info("Successfully parsed JSON using regex extraction")
                except json.JSONDecodeError:
                    logger.error("Regex extraction also failed")
                    raise ValueError("No valid JSON found in response")
            else:
                raise ValueError("No JSON structure found in response")
        
        # Validate the structure
        if not isinstance(itinerary, dict) or 'days' not in itinerary:
            logger.error(f"Invalid itinerary structure: {itinerary}")
            raise ValueError("Invalid itinerary structure - missing 'days' key")
        
        # Enhance with Google geocoding
        logger.info("Enhancing itinerary with geocoding...")
        enhanced_itinerary = enhance_with_geocoding(itinerary, city)
        
        logger.info("Successfully generated enhanced itinerary")
        return enhanced_itinerary
        
    except Exception as e:
        logger.error(f"Error generating itinerary: {e}")
        logger.error(f"Error type: {type(e).__name__}")
        return get_fallback_itinerary(city, days)
def get_fallback_itinerary(city, days):
    """Generate a basic fallback itinerary"""
    colors = ["#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4", "#feca57", "#ff9ff3", "#54a0ff"]
    
    fallback = {"days": []}
    
    for i in range(days):
        lat, lng = get_estimated_coordinates(city)
        
        # Create slight variations for different stops
        stops = []
        for j in range(3):
            offset_lat = lat + (j * 0.01) - 0.01
            offset_lng = lng + (j * 0.01) - 0.01
            
            stops.append({
                "name": f"{city} Attraction {j+1}",
                "lat": offset_lat,
                "lng": offset_lng
            })
        
        fallback["days"].append({
            "label": f"Day {i+1}",
            "color": colors[i % len(colors)],
            "stops": stops
        })
    
    return fallback


# Testing
if __name__ == "__main__":
    result = generate_trip_itinerary("Prague", 3)
    print(json.dumps(result, indent=2))
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\llm.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\realtime\openai_client.py:
"""OpenAI Realtime WebSocket helper
===================================
A thin, asyncio‑friendly wrapper around the OpenAI Realtime API that:
    • opens one persistent WebSocket per user session
    • sends a *session.update* upon connect to configure modalities & voice
    • provides   push_pcm() / commit()  for streaming microphone audio
    • exposes   async for ev in client.events()   to consume server events

The class is deliberately transport‑agnostic: whatever part of your Flask
app owns the user’s Socket.IO connection can instantiate **RealtimeClient**
and stitch the two layers together.

Usage (inside a Socket.IO namespace):
-------------------------------------
client = RealtimeClient(api_key=OPENAI_KEY)
await client.connect()
...
await client.push_pcm(pcm_bytes)
...
async for event in client.events():
    process(event)
"""
from __future__ import annotations

import asyncio
import base64
import json
import os
import contextlib
from typing import AsyncGenerator, Dict, Optional

import websockets
from websockets.exceptions import ConnectionClosedOK, ConnectionClosedError

OPENAI_URL = os.getenv("OPENAI_REALTIME_URL", "wss://api.openai.com/v1/realtime")
DEFAULT_MODEL = os.getenv("OPENAI_REALTIME_MODEL", "gpt-4o-audio-preview")

# ---------------------------------------------------------------------------
# Helper — tiny base‑64 helper to avoid typing the same boilerplate
# ---------------------------------------------------------------------------
_b64encode = lambda b: base64.b64encode(b).decode()


class RealtimeClient:
    """Maintain a single WS connection to OpenAI Realtime."""

    def __init__(self, api_key: str, *, model: str = DEFAULT_MODEL):
        self._api_key = api_key
        self._model = model
        self._ws: Optional[websockets.WebSocketClientProtocol] = None
        self._ev_q: asyncio.Queue = asyncio.Queue()
        self._reader_task: Optional[asyncio.Task] = None

    # ------------------------------------------------------------------
    # Connection lifecycle
    # ------------------------------------------------------------------
    async def connect(self) -> None:
        headers = {"Authorization": f"Bearer {self._api_key}"}
        self._ws = await websockets.connect(
            OPENAI_URL,
            extra_headers=headers,
            max_size=2 ** 22,   # 4 MiB – big enough for long responses
        )

        # Configure session (24 kHz PCM in/out, alloy voice)
        await self._send({
            "type": "session.update",
            "session": {
                "modalities": ["audio", "text"],
                "model": self._model,
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "voice": {"name": "alloy"},
            },
        })

        # Spawn background reader
        self._reader_task = asyncio.create_task(self._reader())

    async def close(self) -> None:
        if self._ws and not self._ws.closed:
            await self._ws.close()
        if self._reader_task:
            self._reader_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._reader_task

    # ------------------------------------------------------------------
    # Public API – audio upload + event iterator
    # ------------------------------------------------------------------
    async def push_pcm(self, pcm_bytes: bytes) -> None:
        """Append raw 16‑bit PCM samples to the server buffer."""
        if not pcm_bytes:
            return
        await self._send({
            "type": "input_audio_buffer.append",
            "audio": _b64encode(pcm_bytes),
        })

    async def commit(self) -> None:
        """Flush the buffer so server‑side VAD can process the utterance."""
        await self._send({"type": "input_audio_buffer.commit"})

    async def events(self) -> AsyncGenerator[Dict, None]:
        """Iterate over OpenAI events as they arrive."""
        while True:
            ev = await self._ev_q.get()
            yield ev

    # ------------------------------------------------------------------
    # Internals
    # ------------------------------------------------------------------
    async def _send(self, payload: Dict) -> None:
        if not self._ws:
            raise RuntimeError("RealtimeClient not connected")
        await self._ws.send(json.dumps(payload))

    async def _reader(self) -> None:
        try:
            async for msg in self._ws:
                try:
                    ev = json.loads(msg)
                except json.JSONDecodeError:
                    continue  # skip garbage
                await self._ev_q.put(ev)
        except (ConnectionClosedOK, ConnectionClosedError):
            pass

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\api\realtime\openai_client.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\travel.py:
"""Flask routes for the travel planner application.
All routes are grouped under the /travel prefix.
"""
import os
from flask import Blueprint, render_template, jsonify, request
from pitext_travel.api.llm import generate_trip_itinerary
from pitext_travel.api.config import get_google_maps_config


def create_travel_blueprint(base_dir):
    """Create and configure the travel blueprint.
    
    Args:
        base_dir: Absolute path to the application directory
    
    Returns:
        Configured Flask Blueprint
    """
    travel_bp = Blueprint(
        "travel",
        __name__,
        url_prefix="/travel",
        template_folder=os.path.join(base_dir, 'templates')
    )

    @travel_bp.route("/", strict_slashes=False)
    def index():
        """Landing page for the Travel Planner micro-app."""
        return render_template("map.html")

    @travel_bp.route("/api/config", methods=["GET"])
    def get_config():
        """Serve configuration including Google Maps credentials."""
        config = get_google_maps_config()
        
        # Check for either API key or Client ID setup
        api_key = config["api_key"]
        client_id = config["client_id"]
        
        # Provide debugging info (without exposing full credentials)
        debug_info = {
            "has_api_key": bool(api_key and api_key.strip()),
            "has_client_id": bool(client_id and client_id.strip()),
            "api_key_length": len(api_key) if api_key else 0,
            "client_id_prefix": client_id[:10] + "..." if client_id and len(client_id) > 10 else client_id
        }
        
        print(f"Maps config debug: {debug_info}")
        
        return jsonify({
            "google_maps_api_key": api_key,
            "google_maps_client_id": client_id,
            "auth_type": "client_id" if client_id else "api_key",
            "debug": debug_info
        })

    @travel_bp.route("/api/itinerary", methods=["GET", "POST"])
    def get_itinerary():
        """Generate a travel itinerary using the OpenAI API."""
        if request.method == "POST":
            payload = request.get_json(force=True) or {}
            city = payload.get("city", "Paris")
            days = int(payload.get("days", 3))
        else:
            city, days = "Paris", 3

        try:
            itinerary = generate_trip_itinerary(city, days)
            return jsonify(itinerary)
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    return travel_bp
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\travel.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\websocket.py:
# ── imports ────────────────────────────────────────────────────────────────
import asyncio, logging, base64
from flask import current_app
from flask_socketio import Namespace, emit
from ..api.realtime.openai_client import RealtimeClient

log = logging.getLogger(__name__)

# ── namespace ──────────────────────────────────────────────────────────────
class TravelVoiceNS(Namespace):
    """
    Socket.IO ↔ OpenAI-Realtime bridge
    Path: /travel/voice
    """
    def __init__(self, namespace):
        super().__init__(namespace)
        self.rt = None     # RealtimeClient

    # -------- connects / disconnects --------------------------------------
    def on_connect(self):
        api_key = current_app.config['OPENAI_API_KEY']
        self.rt = RealtimeClient(api_key)
        asyncio.create_task(self.rt.connect())
        asyncio.create_task(self._fanout())
        log.info('Voice WS connected')

    def on_disconnect(self):
        if self.rt:
            asyncio.create_task(self.rt.close())
        log.info('Voice WS disconnected')

    # -------- browser → backend ------------------------------------------
    def on_audio_chunk(self, data):
        # data['pcm'] is an ArrayBuffer -> bytes on JS side
        asyncio.create_task(self.rt.push_pcm(data['pcm']))

    def on_audio_commit(self):
        asyncio.create_task(self.rt.push_pcm(b'', commit=True))

    # -------- backend → browser ------------------------------------------
    async def _fanout(self):
        async for ev in self.rt.events():
            t = ev.get('type', '')
            if t == 'conversation.item.created':
                emit('assistant_text', {'text': ev['item']['message']})
            elif t == 'output_audio_buffer.payload':
                emit('assistant_audio', {'audio': ev['audio']})
            # add other event types if you later use tools / function-calling

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\websocket.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\__init__.py:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\routes\__init__.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\dayColors.js:
// static/dayColors.js

// 1) Static palette for Days 1–7 (soft, warm, distinct)
export const DAY_COLOR_MAP = {
1: "#FFADAD", // pastel-red (Day 1)
2: "#FFD6A5", // pastel-apricot (Day 2)
3: "#FFCC99", // pastel-peach (Day 3)
4: "#FFC4E1", // pastel-pink (Day 4)
5: "#FDFFB6", // pastel-butter (Day 5)
6: "#FFB3AB", // pastel-coral (Day 6)
7: "#FFECB3", // pastel-gold (Day 7)
};

// 2) Helper to return a colour for any given day index.
//    If the day is not in the static map, fall back to an HSL-based pastel.
export function getColourForDay(dayIndex) {
  // If a static entry exists, return it
  if (DAY_COLOR_MAP.hasOwnProperty(dayIndex)) {
    return DAY_COLOR_MAP[dayIndex];
  }
  
  // Otherwise, generate a gentle pastel by spacing hues around the colour wheel.
  // This ensures undefined days (e.g., Day 8, Day 9, …) still get a soft, distinct hue.
  const hue = (dayIndex * 45) % 360;      // 45° increments around the circle
  const saturation = 70;                  // 70% saturation (pastel feel)
  const lightness = 85;                   // 85% lightness (very soft)
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\dayColors.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\base.css:
/* static/css/base.css - Global Resets & Base Styles */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: system-ui, Arial, sans-serif;
}

html, body {
  height: 100%;
  overflow: hidden;
  background-color: #000;
  background-size: cover;
  background-position: center;
  background-attachment: fixed;
  color: #333;
}

/* Utility Classes */
.hidden {
  display: none !important;
}

.visible {
  opacity: 1 !important;
}

/* Transitions */
* {
  transition: opacity 0.2s ease;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\base.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\chat.css:
/* static/css/chat.css */

/* Chat Panel Container */
.chat-panel {
  position: fixed;
  right: 1rem;
  bottom: 5rem;      /* Above the mic button */
  width: min(90vw, 420px);  /* Responsive width, max 420px */
  max-height: 60vh;
  overflow-y: auto;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  font-size: 15px;
  line-height: 1.5;
  display: none;  /* Hidden by default */
  flex-direction: column;
  gap: 0.75rem;
  z-index: 10020;
  transition: all 0.3s ease;
}

/* Show panel when it has content */
.chat-panel:not(:empty) {
  display: flex;
}

/* Chat Bubbles */
.chat-panel .bubble {
  padding: 0.75rem 1rem;
  border-radius: 18px;
  max-width: 85%;
  word-wrap: break-word;
  word-break: break-word;
  white-space: pre-wrap;
  animation: fadeIn 0.3s ease;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* User Messages (right-aligned) */
.chat-panel .bubble.user {
  background: #1976d2;
  color: white;
  align-self: flex-end;
  margin-left: auto;
  border-bottom-right-radius: 4px;
}

/* Assistant Messages (left-aligned) */
.chat-panel .bubble.assistant {
  background: #f0f0f0;
  color: #333;
  align-self: flex-start;
  margin-right: auto;
  border-bottom-left-radius: 4px;
}

/* Scrollbar Styling */
.chat-panel::-webkit-scrollbar {
  width: 6px;
}

.chat-panel::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
  border-radius: 3px;
}

.chat-panel::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

.chat-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.3);
}

/* Fade-in Animation */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Mic Button */
.mic-btn {
  position: fixed;
  right: 1rem;
  bottom: 1rem;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: #1976d2;
  color: white;
  border: none;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  cursor: pointer;
  z-index: 10025;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.mic-btn:hover {
  background: #1565c0;
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
}

.mic-btn:active {
  transform: scale(0.95);
}

.mic-btn.active {
  background: #d32f2f;
  animation: pulse 1.5s infinite;
}

.mic-btn svg {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* Pulse Animation for Active Recording */
@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7);
  }
  70% {
    box-shadow: 0 0 0 20px rgba(211, 47, 47, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(211, 47, 47, 0);
  }
}

/* Mobile Responsive Adjustments */
@media (max-width: 768px) {
  .chat-panel {
    right: 0.5rem;
    bottom: 4.5rem;
    width: calc(100vw - 1rem);
    max-width: none;
    font-size: 14px;
  }
  
  .chat-panel .bubble {
    max-width: 90%;
  }
  
  .mic-btn {
    right: 0.5rem;
    bottom: 0.5rem;
  }
}

/* Dark Mode Support (if needed) */
@media (prefers-color-scheme: dark) {
  .chat-panel {
    background: rgba(30, 30, 30, 0.95);
    color: #f0f0f0;
  }
  
  .chat-panel .bubble.assistant {
    background: #424242;
    color: #f0f0f0;
  }
}

/* Add these styles to the end of chat.css */

/* Disabled state when assistant is speaking */
.mic-btn.disabled {
  background: #9e9e9e;
  cursor: not-allowed;
  opacity: 0.6;
}

.mic-btn.disabled:hover {
  background: #9e9e9e;
  transform: none;
}

/* Visual feedback for when assistant is speaking */
.chat-panel .bubble.assistant.speaking {
  animation: pulse-soft 2s infinite;
}

@keyframes pulse-soft {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

/* Add a small status indicator */
.mic-status {
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  color: #666;
  white-space: nowrap;
  pointer-events: none;
}

/* Update the mic button to show state */
.mic-btn::after {
  content: '';
  position: absolute;
  bottom: -22px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  color: #666;
  white-space: nowrap;
}

.mic-btn.active::after {
  content: 'Listening...';
  color: #d32f2f;
}

.mic-btn.disabled::after {
  content: 'Assistant speaking';
  color: #9e9e9e;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\chat.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\controls.css:
/* static/css/controls.css - Form and Day Controls Styles */

/* Trip Form Styles */
#trip-form {
  display: flex;
  gap: 0.4rem;
  flex-wrap: wrap;
  margin-bottom: 0.5rem;
  background-color: transparent;
  padding: 0;
  position: relative;
  z-index: 10020;
}

#trip-form label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: bold;
}

#trip-form input[type="text"],
#trip-form input[type="number"] {
  flex: 1 1 120px;
  padding: 0.4rem 0.6rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.95rem;
  background: rgba(255, 255, 255, 0.8);
}

#trip-form button,
#trip-form input[type="submit"] {
  background-color: #87CEEB;
  color: #000;
  padding: 0.4rem 1rem;
  border: none;
  border-radius: 4px;
  font-size: 0.95rem;
  cursor: pointer;
  flex: 0 0 auto;
  transition: all 0.1s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  position: relative;
  z-index: 10020;
  pointer-events: auto;
}

#trip-form button:hover,
#trip-form input[type="submit"]:hover {
  background-color: #6BB6CD;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
  transform: translateY(-1px);
}

#trip-form button:active,
#trip-form input[type="submit"]:active {
  transform: translateY(1px);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  background-color: #5AA5BC;
}

/* Day Controls with Checkboxes */
#day-controls {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 0.5rem;
  padding: 0.5rem 0;
  position: relative;
  z-index: 10010;
}

#day-controls > div {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.3rem;
}

#day-controls label {
  font-weight: bold;
  font-size: 0.9rem;
  cursor: pointer;
  transition: opacity 0.2s ease;
}

#day-controls label:hover {
  opacity: 0.8;
}

#day-controls input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
  accent-color: #4285f4;
}

#day-controls input[type="checkbox"]:hover {
  transform: scale(1.1);
}

/* Old day toggle button styles (for backward compatibility) */
.day-toggle {
  background-color: #e74c3c;
  color: white;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 0.7;
}

.day-toggle:hover {
  opacity: 0.9;
  transform: translateY(-1px);
}

.day-toggle.active {
  opacity: 1;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\controls.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\map.css:
/* static/css/map.css - Map Container & Related Styles */

/* Full-Screen Map Container */
#map {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background-color: #e0e0e0;
}

/* Map Container (old structure compatibility) */
#map-container {
  position: relative;
  flex-grow: 1;
  margin: 1rem auto;
  max-width: 900px;
  height: 500px;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  background-color: #e0e0e0;
}

/* Initial loading message */
#map .loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #fff;
  text-align: center;
  font-size: 1.1rem;
}

#map .loading p {
  margin: 0.5rem 0;
}

#map .loading small {
  font-size: 0.85rem;
  opacity: 0.8;
}

/* Map Overlay for Loading/Errors */
#map-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.6);
  color: #f2f2f2;
  font-size: 1.1rem;
  text-align: center;
  z-index: 5;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  padding: 1rem;
}

#map-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}

/* Info Window Styling (Google Maps) */
.info-window {
  max-width: 280px;
  font-size: 0.9rem;
  line-height: 1.3;
}

.info-window h4 {
  margin: 0 0 8px 0;
  color: #1976d2;
  font-size: 1rem;
}

.info-window p {
  margin: 4px 0;
  font-size: 0.85rem;
  color: #333;
}
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\map.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\panel.css:
/* static/css/panel.css – 2025-06-08
   -- key changes --------------------------------------------------------
   • Panel width  : min(64vw, 336px)         ⟵ ~30 % narrower
   • Translucency : rgba(255,255,255,0.80)   ⟵ lighter glass effect
   ---------------------------------------------------------------------- */

/**************************
 * 1. PANEL POSITIONING
 *************************/
#panel {
  position: absolute;
  bottom: 1rem;
  left:   1rem;

  /* ↓-- narrower: 64 % of viewport or max 336 px (was 92 % / 480 px) */
  width: min(64vw, 336px);

  max-height: 80vh;
  z-index: 10030;
  overflow: visible;
}

/**************************
 * 2. INNER CARD LOOK & FEEL
 *************************/
#inner-panel {
  position: relative;
  padding: 0.75rem 1rem;

  /* ↓-- more see-through (alpha .80 instead of .95) */
  background: rgba(255, 255, 255, 0.80);
  backdrop-filter: blur(10px);

  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, .25);
  transition: all .3s ease;
}

/**************************
 * 3. DAY-CONTROLS ROW
 *************************/
#day-controls {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
  margin-bottom: 0.5rem;
}

/**************************
 * 4. TRIP FORM (inputs + button)
 *************************/
#trip-form input[type="text"],
#trip-form input[type="number"] {
  width: 100%;
  padding: 0.45rem 0.6rem;
  margin-bottom: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 0.95rem;
}

#trip-form button {
  display: block;
  width: 100%;
  padding: 0.5rem;
  font-size: 1rem;
  border: none;
  border-radius: 4px;
  background: #55a9d8;
  color: #fff;
  cursor: pointer;
  box-shadow: inset 0 -2px 2px rgba(0, 0, 0, .15);
}

/**************************
 * 5. MINIMISE / EXPAND BUTTON
 *************************/
#minimize-btn {
  position: absolute;
  top:  -14px;
  right: -14px;
  width: 28px;
  height: 28px;

  border: none;
  border-radius: 50%;
  background: #007bff;
  color: #fff;
  font-size: 20px;
  line-height: 1;

  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 0, 0, .25);
  z-index: 10040;
  transition: transform .1s;
}
#minimize-btn:active { transform: scale(0.9); }

/**************************
 * 6. COLLAPSED STATE
 *************************/
#panel.minimized #inner-panel {
  padding: 0.5rem 0.75rem;
  width: 100%;                /* keep whatever width we have */
}

/* show only the day controls when collapsed */
#panel.minimized #inner-panel > *:not(#day-controls):not(#minimize-btn) {
  display: none !important;
}
#panel.minimized #day-controls { margin-bottom: 0; }

/**************************
 * 7. OPTIONAL GLOBAL HELPERS
 *************************/
#app-container { display: flex; flex-direction: column; min-height: 100vh; }
header        { background:#007bff; color:#fff; padding:1rem; text-align:center; }
h1            { font-size:1.8rem; margin:0; }
footer        { background:#f8f9fa

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\css\panel.css ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\app.js:
// static/js/app.js - Main Application Entry Point

// Store trip data globally
let tripData = null;

/**
 * Initialize the application when DOM is ready
 */
document.addEventListener("DOMContentLoaded", () => {
    const { debugLog } = window.TravelHelpers;
    debugLog("DOM loaded, setting up travel planner...");
    
    // Initialize UI components
    window.TravelPanel.initializePanel();
    window.TravelForm.initializeForm();
    
    // Start loading Google Maps API
    loadGoogleMapsAPI();
});

/**
 * Load Google Maps API dynamically
 */
async function loadGoogleMapsAPI() {
    const { debugLog } = window.TravelHelpers;
    const { showError } = window.TravelOverlays;
    const { loadGoogleMapsConfig, createMapsScriptUrl, loadGoogleMapsScript } = window.TravelConfig;
    
    try {
        // Load configuration
        const config = await loadGoogleMapsConfig();
        
        // Create script URL
        const scriptUrl = createMapsScriptUrl(config);
        
        // Load the script
        await loadGoogleMapsScript(scriptUrl);
        
    } catch (error) {
        showError(`Failed to load Google Maps: ${error.message}`);
    }
}

/**
 * Initialize when Google Maps API is loaded (callback function)
 */
window.initializeApp = function() {
    const { debugLog } = window.TravelHelpers;
    const { initializeGoogleMap } = window.TravelGoogleMaps;
    
    debugLog('Google Maps API loaded successfully');
    
    try {
        initializeGoogleMap();
        
        // Load map modules after Google Maps is initialized
        if (window.loadMapModules) {
            debugLog('Loading map modules...');
            window.loadMapModules();
        } else {
            debugLog('loadMapModules function not found!');
        }
        
    } catch (error) {
        const { showError } = window.TravelOverlays;
        showError(`Map initialization failed: ${error.message}`);
    }
};

/**
 * Process itinerary data
 */
async function processItinerary(city, days) {
    const { debugLog } = window.TravelHelpers;
    const { showLoading, showError, hideOverlay } = window.TravelOverlays;
    const { isMapLoaded } = window.TravelGoogleMaps;
    const { fetchItinerary } = window.TravelAPI;
    
    if (!isMapLoaded()) {
        showError("Google Maps is still loading. Please wait a moment and try again.");
        return;
    }
    
    // Show loading
    showLoading("Generating your Holi :) Day plans!");
    
    try {
        // Fetch itinerary
        const data = await fetchItinerary(city, days);
        
        // Store trip data
        tripData = data;
        
        // Render on map
        renderTripOnMap(data);
        
        // Hide loading
        hideOverlay();
        
    } catch (error) {
        showError(`Failed to load itinerary: ${error.message}`);
    }
}

/**
 * Render the complete trip on Google Maps
 */
function renderTripOnMap(data) {
    const { debugLog } = window.TravelHelpers;
    const { showError } = window.TravelOverlays;
    const { fitMapToBounds } = window.TravelGoogleMaps;

    // If modules aren't ready yet, store the data and wait
    if (!window.mapModulesReady) {
        debugLog("Map modules not ready yet, storing pending render...");
        window.pendingRender = data;
        return;
    }

    debugLog("Map modules ready, rendering trip...");

    // Modules are loaded, proceed with rendering
    const { createAllMarkers, clearAllMarkers } = window.TravelMarkers;
    const { createAllRoutes, clearAllRoutes } = window.TravelRoutes;
    const { renderDayControls, clearDayControls } = window.TravelControls;
    
    debugLog("Rendering trip on Google Maps...", data);
    
    if (!data.days || data.days.length === 0) {
        showError("No itinerary data to display");
        return;
    }
    
    // Clear existing elements
    clearMapElements();
    
    // Create markers
    const { bounds, totalStops } = createAllMarkers(data);
    
    // Create routes
    createAllRoutes(data);
    
    // Hide all days except the first one
    data.days.forEach((_, index) => {
        if (index > 0) {
            const { toggleMarkersForDay } = window.TravelMarkers;
            const { toggleRoutesForDay } = window.TravelRoutes;
            toggleMarkersForDay(index, false);
            toggleRoutesForDay(index, false);
        }
    });
            
    // Fit map to bounds
    fitMapToBounds(bounds, totalStops);
    
    // Render day controls
    renderDayControls(data.days);
    
    debugLog("Trip rendering complete!");
}
/**
 * Clear all map elements
 */
function clearMapElements() {
    const { debugLog } = window.TravelHelpers;

    if (window.TravelMarkers && window.TravelMarkers.clearAllMarkers) {
        window.TravelMarkers.clearAllMarkers();
    }
    if (window.TravelRoutes && window.TravelRoutes.clearAllRoutes) {
        window.TravelRoutes.clearAllRoutes();
    }
    if (window.TravelControls && window.TravelControls.clearDayControls) {
        window.TravelControls.clearDayControls();
    }



    const { clearAllMarkers } = window.TravelMarkers;
    const { clearAllRoutes } = window.TravelRoutes;
    const { clearDayControls } = window.TravelControls;
    
    debugLog("Clearing map elements...");
    
    clearAllMarkers();
    clearAllRoutes();
    clearDayControls();
}

// Global error handler for Google Maps script loading issues
window.addEventListener('error', function (e) {
    if (e.filename && e.filename.includes('maps.googleapis.com')) {
        const { showError } = window.TravelOverlays;
        const errMsg = e.message || (e.error && e.error.message) || 'Unknown script error';
        console.error('Google Maps script error:', errMsg, e);

        showError(`
            <strong>Google Maps JavaScript failed to load</strong><br><br>
            <code>${errMsg}</code><br><br>
            • Check internet connectivity.<br>
            • Verify the API Key / Client ID.<br>
            • Ensure your quota hasn't been exceeded.<br><br>
            See the browser console for the full stack trace.
        `);
    }
}, true);

// Export for other modules
window.TravelApp = {
    processItinerary,
    renderTripOnMap,
    clearMapElements
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\app.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\chat.js:
// static/js/chat.js
// Handles voice transcripts and chat interactions

class Chat {
  constructor() {
    this.panel = document.getElementById('chat-panel');
    this.isSpeaking = false;
    this.voiceInitialized = false;
    
    // Initialize voice on first user interaction
    this.initializeVoice();
    
    // Set up voice integration
    if (window.voice) {
      window.voice.onTranscript = t => this.handleUser(t);
    }
  }

  initializeVoice() {
    // Many browsers require user interaction to enable speech synthesis
    const initHandler = () => {
      if (!this.voiceInitialized && 'speechSynthesis' in window) {
        // Get voices to initialize the speech synthesis
        const voices = window.speechSynthesis.getVoices();
        console.log(`Speech synthesis initialized with ${voices.length} voices`);
        
        // Test speech synthesis with empty utterance
        const testUtterance = new SpeechSynthesisUtterance('');
        testUtterance.volume = 0;
        window.speechSynthesis.speak(testUtterance);
        
        this.voiceInitialized = true;
        
        // Remove the event listeners after initialization
        document.removeEventListener('click', initHandler);
        document.removeEventListener('touchstart', initHandler);
      }
    };

    // Add event listeners for user interaction
    document.addEventListener('click', initHandler);
    document.addEventListener('touchstart', initHandler);
    
    // Also try to initialize immediately
    if ('speechSynthesis' in window) {
      // Load voices
      window.speechSynthesis.getVoices();
      
      // Chrome loads voices asynchronously
      if (window.speechSynthesis.onvoiceschanged !== undefined) {
        window.speechSynthesis.onvoiceschanged = () => {
          const voices = window.speechSynthesis.getVoices();
          console.log(`Voices loaded: ${voices.length} available`);
        };
      }
    }
  }

  async handleUser(text) {
    this.addBubble('user', text);

    try {
      const res = await fetch('/travel/api/chat', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({text}),
        credentials: 'include'
      });

      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }

      const data = await res.json();

      // Show reply
      this.addBubble('assistant', data.reply);
      
      // Speak the reply
      this.speakText(data.reply);

      // Handle itinerary if present AND it's a new trip
      if (data.itinerary && window.TravelApp) {
        // Only render if it's a new itinerary (check if city/days changed)
        const isNewTrip = data.reply.includes("I've created") || 
                          data.reply.includes("planned") ||
                          data.reply.includes("itinerary for");
        
        if (isNewTrip) {
          window.TravelApp.renderTripOnMap(data.itinerary);
        }
      }

    } catch (error) {
      console.error('Chat error:', error);
      this.addBubble('assistant', 'Sorry, I encountered an error. Please try again.');
    }
  }

  speakText(text) {
    if (!('speechSynthesis' in window)) {
      console.warn('Speech synthesis not supported');
      return;
    }

    // Notify voice controller that assistant is about to speak
    if (window.voice && window.voice.setAssistantSpeaking) {
      window.voice.setAssistantSpeaking(true);
    }

    // Cancel any ongoing speech
    window.speechSynthesis.cancel();

    // Wait a bit for cancel to complete
    setTimeout(() => {
      // Remove markdown formatting for cleaner speech
      const cleanText = text
        .replace(/\*\*(.*?)\*\*/g, '$1')  // Remove bold **text**
        .replace(/\*(.*?)\*/g, '$1')      // Remove italic *text*
        .replace(/\n+/g, '. ')            // Replace newlines with periods
        .replace(/[#_~`]/g, '');          // Remove other markdown chars

      const utterance = new SpeechSynthesisUtterance(cleanText);
      
      // Configure the utterance
      utterance.rate = 0.9;     // Slightly slower for clarity
      utterance.pitch = 1.0;
      utterance.volume = 0.8;   // Slightly lower volume to reduce pickup
      utterance.lang = 'en-US';
      
      // Select a voice if available
      const voices = window.speechSynthesis.getVoices();
      if (voices.length > 0) {
        // Try to find an English voice
        const englishVoice = voices.find(voice => 
          voice.lang.startsWith('en') && !voice.name.includes('Google')
        ) || voices[0];
        utterance.voice = englishVoice;
        console.log(`Using voice: ${englishVoice.name}`);
      }
      
      // Handle events
      utterance.onstart = () => {
        this.isSpeaking = true;
        console.log('Started speaking:', cleanText.substring(0, 50) + '...');
      };
      
      utterance.onend = () => {
        this.isSpeaking = false;
        console.log('Finished speaking');
        
        // Notify voice controller that assistant finished speaking
        if (window.voice && window.voice.setAssistantSpeaking) {
          window.voice.setAssistantSpeaking(false);
        }
        
        // DO NOT automatically restart voice recognition
        // User must click the mic button to speak again
        console.log('Click the mic button to speak again');
      };
      
      utterance.onerror = (event) => {
        console.error('Speech synthesis error:', event.error, event);
        this.isSpeaking = false;
        
        // Notify voice controller on error too
        if (window.voice && window.voice.setAssistantSpeaking) {
          window.voice.setAssistantSpeaking(false);
        }
        
        // Try to help debug common issues
        if (event.error === 'not-allowed') {
          console.error('Speech synthesis not allowed. User interaction may be required.');
        }
      };

      // Speak
      try {
        window.speechSynthesis.speak(utterance);
        console.log('Speech synthesis started');
      } catch (error) {
        console.error('Failed to start speech:', error);
        // Notify voice controller on failure
        if (window.voice && window.voice.setAssistantSpeaking) {
          window.voice.setAssistantSpeaking(false);
        }
      }
    }, 100);
  }
  
  addBubble(role, text) {
    const div = document.createElement('div');
    div.className = `bubble ${role}`;
    
    // Parse markdown-style formatting for display
    const formattedText = text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // Bold
      .replace(/\n/g, '<br>');                           // Line breaks
    
    div.innerHTML = formattedText;
    this.panel.appendChild(div);
    
    // Ensure panel is visible
    this.panel.style.display = 'block';
    
    // Smooth scroll to latest message
    setTimeout(() => {
      div.scrollIntoView({behavior: 'smooth', block: 'end'});
    }, 100);
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.chatInstance = new Chat();
  console.log('Chat system initialized');
});
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\chat.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\voice.js:
// static/js/voice.js
// ---------------------------------------------------------------------------
// Web‑Audio voice controller for OpenAI Realtime
// ---------------------------------------------------------------------------
// Responsibilities
//   • Capture microphone at 24 kHz mono PCM using an AudioWorklet
//   • Stream raw PCM chunks to the backend through Socket.IO
//   • Send a commit signal when the user stops speaking (mic toggle)
//   • Receive base‑64 PCM from the backend (`assistant_audio`) and play it
//   • Expose a global `window.voice` object so existing UI code can call
//       voice.start(), voice.stop(), voice.toggle(), etc.
//
// Assumptions
//   • The backend Socket.IO namespace is `/travel/voice` (see websocket.py)
//   • `socket.io.js` (or ESM) is already loaded on the page and exposes `io`
//   • `input-pcm-processor.js` (AudioWorklet) is served at
//         /static/js/audio/input-pcm-processor.js
//   • A mic button exists with id `#mic-btn`
// ---------------------------------------------------------------------------
/* global io */

(function () {
  class VoiceController {
    constructor (buttonSelector = '#mic-btn') {
      // ---------------------------------------------------------------------
      // 1  UI: mic button ----------------------------------------------------
      // ---------------------------------------------------------------------
      this.button = document.querySelector(buttonSelector)
      if (!this.button) {
        console.warn('Mic button not found – voice disabled')
        return
      }
      this.button.addEventListener('click', () => this.toggle())

      // ---------------------------------------------------------------------
      // 2  Socket.IO connection to backend ----------------------------------
      // ---------------------------------------------------------------------
      this.socket = io('/travel/voice')

      // Playback handler (assistant → audio chunks)
      this.socket.on('assistant_audio', ({ audio }) => this._playAssistant(b64ToPCM(audio)))

      // Optional: assistant text (hook for chat bubble ‑ only if you want it)
      this.socket.on('assistant_text', ({ text }) => {
        if (window.TravelChat) window.TravelChat.addAssistantMessage(text)
      })

      // ---------------------------------------------------------------------
      // 3  Audio context / worklet ------------------------------------------
      // ---------------------------------------------------------------------
      this.audioCtx = null         // lazy‑init after first click
      this.worklet = null
      this.isRecording = false
    }

    // ---------------------------------------------------------------------
    // Public API (used by other JS modules if needed) ----------------------
    // ---------------------------------------------------------------------
    async start () {
      if (this.isRecording) return

      await this._ensureAudioPipeline()
      await this.audioCtx.resume()       // required after a user gesture
      this.button.classList.add('active')
      this.isRecording = true
    }

    stop () {
      if (!this.isRecording) return
      this.button.classList.remove('active')
      this.isRecording = false
      // Tell backend to commit what we just said so server‑side VAD can act
      this.socket.emit('audio_commit')
    }

    toggle () {
      this.isRecording ? this.stop() : this.start()
    }

    // ---------------------------------------------------------------------
    // Private helpers ------------------------------------------------------
    // ---------------------------------------------------------------------
    async _ensureAudioPipeline () {
      if (this.audioCtx) return

      // Create AudioContext matching OpenAI 24 kHz sample rate
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: 24000
      })

      // Load the AudioWorklet that converts float‑32 to 16‑bit PCM LE
      try {
        await this.audioCtx.audioWorklet.addModule('/static/js/audio/input-pcm-processor.js')
      } catch (err) {
        console.error('Failed to load AudioWorklet:', err)
        return
      }

      // Open microphone stream (prompts the user the first time)
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const src = this.audioCtx.createMediaStreamSource(this.stream)

      // Worklet node that receives Float32 chunks and sends ArrayBuffer via port
      this.worklet = new AudioWorkletNode(this.audioCtx, 'input-pcm')

      // Forward PCM to backend in small chunks (~128 frames = ~5 ms)
      this.worklet.port.onmessage = ({ data }) => {
        this.socket.emit('audio_chunk', { pcm: data })
      }

      // Mic → worklet (no need to monitor output)
      src.connect(this.worklet)
    }

    _playAssistant ({ float32, sampleRate = 24000 }) {
      // Ensure AudioContext exists (might be closed if user never spoke yet)
      if (!this.audioCtx) {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate
        })
      }

      const buf = this.audioCtx.createBuffer(1, float32.length, sampleRate)
      buf.copyToChannel(float32, 0)
      const src = this.audioCtx.createBufferSource()
      src.buffer = buf
      src.connect(this.audioCtx.destination)
      src.start()
    }
  }

  // -----------------------------------------------------------------------
  // Helper: base‑64 → Float32Array (normalised −1 … +1) -------------------
  // -----------------------------------------------------------------------
  function b64ToPCM (b64) {
    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0))
    const int16 = new Int16Array(bytes.buffer)
    const float32 = Float32Array.from(int16, s => s / 0x7fff)
    return { float32, sampleRate: 24000 }
  }

  // Attach globally so other scripts can call voice.toggle(), etc.
  window.voice = new VoiceController()
})()

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\voice.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\client.js:
// static/js/api/client.js - API Communication

/**
 * Fetch itinerary from Flask backend
 */
async function fetchItinerary(city = "Paris", days = 3) {
    const { debugLog, errorLog } = window.TravelHelpers;
    const { API_ENDPOINTS } = window.TravelConstants;
    
    debugLog(`Fetching itinerary for ${city}, ${days} days...`);
    
    const endpoint = API_ENDPOINTS.ITINERARY;
    const fetchOptions = city && days ? {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ city, days })
    } : undefined;

    try {
        const response = await fetch(endpoint, fetchOptions);
        
        debugLog("API response status:", response.status);
        if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
        }
        
        const data = await response.json();
        debugLog("API response data:", data);
        
        if (!data.days || !Array.isArray(data.days)) {
            errorLog("Invalid data structure:", data);
            throw new Error("Invalid itinerary data received from server");
        }
        
        if (data.days.length === 0) {
            throw new Error("No itinerary data returned");
        }
        
        return data;
    } catch (error) {
        errorLog("Fetch error:", error);
        throw error;
    }
}

// Export for other modules
window.TravelAPI = {
    fetchItinerary
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\client.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\config.js:
// static/js/api/config.js - Frontend Configuration Loading

/**
 * Load Google Maps configuration from backend
 */
async function loadGoogleMapsConfig() {
    const { debugLog, errorLog } = window.TravelHelpers;
    const { API_ENDPOINTS } = window.TravelConstants;
    
    debugLog("Loading Google Maps API configuration...");
    
    try {
        const response = await fetch(API_ENDPOINTS.CONFIG);
        
        if (!response.ok) {
            throw new Error(`Config request failed: ${response.status}`);
        }
        
        const config = await response.json();
        debugLog("Config loaded:", config);
        
        return config;
    } catch (error) {
        errorLog('Failed to load config:', error);
        throw error;
    }
}

/**
 * Create Google Maps script URL based on configuration
 */
function createMapsScriptUrl(config) {
    const { debugLog } = window.TravelHelpers;
    let scriptUrl;
    
    if (config.auth_type === "client_id" && config.google_maps_client_id && config.google_maps_client_id.trim()) {
        // Use Client ID authentication
        const clientId = config.google_maps_client_id;
        
        // Validate Client ID format
        if (!clientId.startsWith('gme-') && clientId.length < 20) {
            throw new Error("Invalid Client ID format. Expected format: gme-company or long client ID");
        }
        
        scriptUrl = `https://maps.googleapis.com/maps/api/js?key=${config.google_maps_api_key}&libraries=places,marker,geometry&callback=initializeApp`;
        debugLog("Using Google Maps Client ID authentication");
    } else if (config.google_maps_api_key && config.google_maps_api_key.trim()) {
        // Use API Key authentication
        scriptUrl = `https://maps.googleapis.com/maps/api/js?key=${config.google_maps_api_key}&libraries=places,marker&callback=initializeApp`;        debugLog("Using Google Maps API Key authentication");
    } else {
        throw new Error("No valid Google Maps credentials found. Please check your environment variables.");
    }
    
    return scriptUrl;
}

/**
 * Load Google Maps API script
 */
function loadGoogleMapsScript(scriptUrl) {
    const { debugLog, errorLog } = window.TravelHelpers;
    
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = scriptUrl;
        script.async = true;
        script.defer = true;
        
        script.onload = () => {
            debugLog("Google Maps script loaded successfully");
            resolve();
        };
        
        script.onerror = () => {
            errorLog("Failed to load Google Maps script");
            reject(new Error('Failed to load Google Maps script'));
        };
        
        document.head.appendChild(script);
        debugLog("Google Maps script added to page");
    });
}

// Export for other modules
window.TravelConfig = {
    loadGoogleMapsConfig,
    createMapsScriptUrl,
    loadGoogleMapsScript
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\api\config.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\audio\input-pcm-processor.js:
// static/js/audio/input-pcm-processor.js
// AudioWorkletProcessor that converts Float32 input frames (-1..1) into
// a transferable ArrayBuffer containing 16‑bit little‑endian PCM samples.
// Each `process()` call typically handles 128 frames (~5.3 ms at 24 kHz),
// which keeps latency low enough for the Realtime API.
//
// The main thread attaches a message handler to `port.onmessage` to receive
// the ArrayBuffer and forward it (e.g. via Socket.IO) to the backend.
// ---------------------------------------------------------------------------
/* eslint-disable no-undef */
class InputPCMProcessor extends AudioWorkletProcessor {
  process (inputs) {
    const input = inputs[0]
    if (!input || !input[0]) return true // no data yet

    const float32 = input[0] // Float32Array of [-1..1]
    const pcm = new Int16Array(float32.length)

    // Convert float [-1,1] → int16
    for (let i = 0; i < float32.length; i++) {
      let s = float32[i] * 0x7fff
      // clamp just in case
      if (s > 0x7fff) s = 0x7fff
      else if (s < -0x8000) s = -0x8000
      pcm[i] = s
    }

    // Transfer the underlying buffer to main thread (zero‑copy)
    this.port.postMessage(pcm.buffer, [pcm.buffer])
    return true // keep processor alive
  }
}

registerProcessor('input-pcm', InputPCMProcessor)

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\audio\input-pcm-processor.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\controls.js:
// static/js/map/controls.js
// ----------------------------
//  • Renders "Day 1 / Day 2 / …" toggle checkboxes.
//  • Each label's text colour is taken from getColourForDay(dayIndex + 1),
//    so it will match the corresponding marker & route colour.
// ----------------------------
(function() {
    if (!window.google || !window.google.maps) {
        console.error('Google Maps API not fully loaded yet for controls.js - retrying...');
        setTimeout(function() {
            const script = document.createElement('script');
            script.src = '/travel/static/js/map/controls.js';
            document.head.appendChild(script);
        }, 100);
        return;
    }

// Store current visibility state globally
window.currentDayVisibility = window.currentDayVisibility || {};

// Track which days are visible
let dayVisibility = {};

/**
 * Render day control checkboxes
 *
 * @param {Array<Object>} days
 *   Each element is { label?: string, color?: string, stops: [...] }.
 *   We will ignore `day.color` here, and instead use getColourForDay().
 */
function renderDayControls(days) {
  const { debugLog } = window.TravelHelpers;
  debugLog("Rendering day controls for", days.length, "days");

  const controls = document.getElementById("day-controls");
  if (!controls) {
    debugLog("Day controls container not found");
    return;
  }

  // Initialize visibility: restore previous state or default to Day 1 only
  dayVisibility = window.currentDayVisibility || {};
  if (Object.keys(dayVisibility).length === 0) {
    days.forEach((_, index) => {
      dayVisibility[index] = index === 0;
    });
  }
  window.currentDayVisibility = dayVisibility;

  controls.innerHTML = "";
  controls.style.display = "flex";
  controls.style.gap = "1rem";
  controls.style.alignItems = "flex-start";

  days.forEach((day, i) => {
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.alignItems = "center";
    wrapper.style.gap = "0.3rem";

    // 1) Create the <label> for Day (i+1)
    const label = document.createElement("label");

    // Instead of using day.color, grab from our shared helper:
    const colour = window.TravelGoogleMaps.getColourForDay(i + 1);

    label.style.color = colour;          // e.g. "#FFADAD" for Day 1, "#FFD6A5" for Day 2, etc.
    label.style.fontWeight = "bold";
    label.style.fontSize = "0.9rem";
    label.textContent = day.label || `Day ${i + 1}`;
    label.style.cursor = "pointer";
    label.setAttribute("for", `day-checkbox-${i}`);

    // 2) Create the checkbox itself
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.id = `day-checkbox-${i}`;
    checkbox.checked = dayVisibility[i] !== false;  // Use restored state
    checkbox.style.cursor = "pointer";
    checkbox.style.width = "18px";
    checkbox.style.height = "18px";

    // When toggled, this will show/hide markers & routes for this day
    checkbox.onchange = () => toggleDay(i);

    // 3) Assemble & append
    wrapper.appendChild(label);
    wrapper.appendChild(checkbox);
    controls.appendChild(wrapper);
  });

  debugLog(`Created ${days.length} day control checkboxes`);
}

/**
 * Toggle visibility for a specific day
 *
 * @param {number} dayIndex
 *   Zero-based index (0 → Day 1, 1 → Day 2, etc.)
 */
function toggleDay(dayIndex) {
  const { debugLog } = window.TravelHelpers;
  const { toggleMarkersForDay } = window.TravelMarkers;
  const { toggleRoutesForDay } = window.TravelRoutes;

  debugLog(`Toggling day ${dayIndex + 1}`);

  dayVisibility[dayIndex] = !dayVisibility[dayIndex];
  
  // Save state globally
  window.currentDayVisibility = dayVisibility;

  // Update markers and routes visibility
  toggleMarkersForDay(dayIndex, dayVisibility[dayIndex]);
  toggleRoutesForDay(dayIndex, dayVisibility[dayIndex]);
}

/**
 * Get whether a given day is currently visible
 *
 * @param {number} dayIndex
 *   Zero-based index of the day
 * @returns {boolean}
 */
function isDayVisible(dayIndex) {
  return dayVisibility[dayIndex] !== false;
}

/**
 * Clear all day‐control checkboxes (for re‐rendering)
 */
function clearDayControls() {
  const controls = document.getElementById("day-controls");
  if (controls) {
    controls.innerHTML = "";
  }
  // Don't clear visibility state here - we want to preserve it
}

// Export these functions for other modules to use
window.TravelControls = {
  renderDayControls,
  toggleDay,
  isDayVisible,
  clearDayControls
};
})();
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\controls.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\google-maps.js:
// static/js/map/google-maps.js
// -------------------------------------------------------------
//  PiText Travel – Google-Maps bootstrap + "always-on" attractions
//  (with dynamic clusterer detection at use-time)
// -------------------------------------------------------------

/* ----------  DAY-COLOUR HELPER  ---------- */
const DAY_COLOR_MAP = {
  1: '#FFADAD', 2: '#FFD6A5', 3: '#FDFFB6',
  4: '#FFC4E1', 5: '#FFCC99', 6: '#FFB3AB', 7: '#FFECB3'
};
function getColourForDay(dayIndex) {
  if (DAY_COLOR_MAP[dayIndex]) return DAY_COLOR_MAP[dayIndex];
  const hue = (dayIndex * 45) % 360;
  return `hsl(${hue},70%,85%)`;
}

/* ----------  MAP / SERVICES  ---------- */
let map, directionsService, isGoogleMapsLoaded = false;

/* ----------  CLUSTERER DETECTION  ---------- */
/** 
 * At runtime, pick up whichever clusterer is loaded:
 *  - window.MarkerClusterer   (legacy)
 *  - google.maps.markerclusterer.MarkerClusterer (@googlemaps/markerclusterer)
 */
function getClustererCtor() {
  if (window.MarkerClusterer) {
    return window.MarkerClusterer;
  }
  if (window.google
      && google.maps.markerclusterer
      && google.maps.markerclusterer.MarkerClusterer) {
    return google.maps.markerclusterer.MarkerClusterer;
  }
  return null;
}

/* ----------  TOURIST POI MARKERS  ---------- */
let poiMarkers   = [];      // google.maps.Marker[]
let poiClusterer = null;
const CLUSTER_OPTIONS = {
  imagePath : 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m',
  maxZoom   : 11,   //  ≤ 11  → cluster   |   ≥ 12  → no cluster,   // ⬅️  stop clustering at zoom 13+
  // Optional fine-tuning ↓
  gridSize  : 50,   // cluster radius in px (smaller ⇒ fewer clusters)
  minimumClusterSize : 4   // don't collapse 2-or-3 markers anymore
};

/** remove existing markers & clusters */
function clearPoiMarkers() {
  if (poiClusterer) poiClusterer.clearMarkers();
  poiMarkers.forEach(m => m.setMap(null));
  poiMarkers = [];
}

/* ----------  TOURIST POI FETCHER  ---------- */
const TOURIST_TYPES = [
  'tourist_attraction','museum','art_gallery','church','hindu_temple','synagogue',
  'mosque','place_of_worship','park','zoo','aquarium','stadium','casino',
  'amusement_park','campground','cemetery','library','city_hall','rv_park',
  'university','point_of_interest'
];
const poiCache = new Map(); // key=`${type}_${lat}_${lng}_${zoom}`

function splitBounds(bounds, segments = 3) {
  const ne = bounds.getNorthEast(), sw = bounds.getSouthWest();
  const latStep = (ne.lat() - sw.lat()) / segments;
  const lngStep = (ne.lng() - sw.lng()) / segments;
  const tiles = [];
  for (let r = 0; r < segments; r++) {
    for (let c = 0; c < segments; c++) {
      const tileSw = new google.maps.LatLng(
        sw.lat() + r * latStep, sw.lng() + c * lngStep
      );
      const tileNe = new google.maps.LatLng(
        sw.lat() + (r + 1) * latStep, sw.lng() + (c + 1) * lngStep
      );
      tiles.push(new google.maps.LatLngBounds(tileSw, tileNe));
    }
  }
  return tiles;
}

function fetchTouristPois() {
  if (!map) return;
  clearPoiMarkers();

  const svc   = new google.maps.places.PlacesService(map);
  const zoom  = map.getZoom();
  const tiles = (zoom <= 14)
    ? splitBounds(map.getBounds(), 3)
    : [map.getBounds()];

  tiles.forEach(bounds => {
    TOURIST_TYPES.forEach(type => {
      const key = `${type}_${bounds.getCenter().lat().toFixed(3)}_${bounds.getCenter().lng().toFixed(3)}_${zoom}`;
      if (poiCache.has(key)) {
        poiMarkers.push(...poiCache.get(key));
        return;
      }
      svc.nearbySearch({ bounds, type }, (results, status) => {
        if (status !== google.maps.places.PlacesServiceStatus.OK || !results) return;

        const fresh = results.map(place => {
          const iconUrl = place.icon
            || 'https://maps.gstatic.com/mapfiles/place_api/icons/v1/png_71/generic_business-71.png';
          return new google.maps.Marker({
            position: place.geometry.location,
            icon:     { url: iconUrl, scaledSize: new google.maps.Size(22, 22) },
            title:    place.name,
            map
          });
        });

        poiMarkers.push(...fresh);
        poiCache.set(key, fresh);
        if (poiClusterer) poiClusterer.repaint();
      });
    });
  });

  // now cluster, if a clusterer is loaded
  const ClusterCtor = getClustererCtor();
  if (ClusterCtor) {
    if (!poiClusterer) {
      poiClusterer = new ClusterCtor(map, poiMarkers, CLUSTER_OPTIONS);
    } else {
      poiClusterer.clearMarkers();
      poiClusterer.addMarkers(poiMarkers, /* noDraw= */ true);
    }
  }
}

/* ----------  DEBOUNCE  ---------- */
function debounce(fn, ms = 400) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
}
const debouncedFetchPois = debounce(fetchTouristPois, 500);

/* ----------  MAIN INITIALIZATION  ---------- */
function initializeGoogleMap() {
  const { MAP_CONFIG, MAP_STYLES } = window.TravelConstants;
  const el = document.getElementById('map');
  
  // Create the map
// Create the map
map = new google.maps.Map(el, {
  center: MAP_CONFIG.DEFAULT_CENTER,
  zoom: MAP_CONFIG.DEFAULT_ZOOM,
  mapId: MAP_CONFIG.MAP_ID,
  mapTypeControl: true,
  zoomControl: true,
  scaleControl: true,
  streetViewControl: true,
  fullscreenControl: true,
  styles: MAP_STYLES  // Use styles from constants
});  
  // Initialize directions service
  directionsService = new google.maps.DirectionsService();
  
  // Set up event listeners for POI loading
  //map.addListener('bounds_changed', debouncedFetchPois);
 // map.addListener('zoom_changed', debouncedFetchPois);
  
  // Load initial POIs
 // google.maps.event.addListenerOnce(map, 'idle', fetchTouristPois);
  
  // Mark as loaded
  isGoogleMapsLoaded = true;
  
  console.log('Google Maps initialized successfully');
}

/* ----------  FIT BOUNDS  ---------- */
function fitMapToBounds(bounds, totalStops) {
  const { MAP_CONFIG } = window.TravelConstants;
  if (!bounds.isEmpty() && totalStops) {
    map.fitBounds(bounds);
    google.maps.event.addListenerOnce(map, 'bounds_changed', () => {
      const z = map.getZoom();
      if (z > MAP_CONFIG.MAX_ZOOM)     map.setZoom(MAP_CONFIG.COMFORTABLE_ZOOM);
      else if (z < MAP_CONFIG.MIN_ZOOM) map.setZoom(MAP_CONFIG.OVERVIEW_ZOOM);
    });
  } else {
    map.setCenter(MAP_CONFIG.DEFAULT_CENTER);
    map.setZoom(  MAP_CONFIG.DEFAULT_ZOOM);
  }
}

/* ----------  EXPORT  ---------- */
window.TravelGoogleMaps = {
  initializeGoogleMap,
  getMap:               () => map,
  getDirectionsService: () => directionsService,
  isMapLoaded:          () => isGoogleMapsLoaded,
  fitMapToBounds,
  getColourForDay,
  fetchTouristPois  
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\google-maps.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\markers.js:
// static/js/map/markers.js
// ---------------------------------------------------------
//  • Uses official Google Places icons when available via
//    `stop.iconUrl`; falls back to coloured circles.
//  • getColourForDay(dayIndex) keeps per-day hues consistent.
//  • Exposes window.showPOIs so other modules can drop
//    ad-hoc points of interest onto the same map layer.
// ---------------------------------------------------------

(function() {
    // Check if Google Maps API is loaded
    if (!window.google || !window.google.maps || !window.google.maps.marker) {
        console.error('Google Maps API not fully loaded yet for markers.js - retrying...');
        setTimeout(function() {
            // Retry loading this script
            const script = document.createElement('script');
            script.src = '/travel/static/js/map/markers.js';
            document.head.appendChild(script);
        }, 100);
        return;
    }

    // ---------- Trip-stop markers ----------// ---------- Trip-stop markers ----------


let currentMarkers = [];

/**
 * Create a marker for one itinerary stop (Advanced Markers API)
 */
// Make sure the object exists even if something later throws
if (!window.TravelMarkers) window.TravelMarkers = {};

function createMarker(stop, day, dayIndex, stopIndex) {
  const { isValidCoordinate, createLatLng, debugLog } = window.TravelHelpers;
  const { getMap, getColourForDay } = window.TravelGoogleMaps;
  const { isDayVisible } = window.TravelControls;

  if (!isValidCoordinate(stop.lat, stop.lng)) {
    debugLog(`Skipping stop ${stop.name} – invalid coordinates`, stop);
    return null;
  }

  const position = createLatLng(stop.lat, stop.lng);
  const map      = getMap();

  // Colour code for this day
  const dayColor = getColourForDay(dayIndex);

  const pinElement = new google.maps.marker.PinElement({
    background: dayColor,
    borderColor: '#FFFFFF',
    glyphColor:  '#FFFFFF',
    scale: 1.0
  });
  pinElement.element.style.opacity = '0.8';

  const marker = new google.maps.marker.AdvancedMarkerElement({
    position,
    map: isDayVisible(dayIndex) ? map : null,
    title: stop.name,
    content: pinElement.element,
    gmpClickable: true,
    zIndex: -1000 - stopIndex
  });

  // InfoWindow
  const placeTypeDisplay = stop.placeType
      ? stop.placeType.replace(/_/g, ' ')
      : 'attraction';

  marker.infoWindow = new google.maps.InfoWindow({
    content: `
      <div class="info-window-content" style="
        background:${dayColor};
        border-radius:8px;
        padding:12px;
        box-shadow:0 2px 6px rgba(0,0,0,0.2);
        min-width:200px;">
        <h4 style="margin:0 0 8px 0;font-size:1.1rem;color:#222;">
          ${stop.name}
        </h4>
        <p style="margin:4px 0;font-size:0.9rem;color:#444;">
          ${day.label || `Day ${dayIndex + 1}`} • Stop ${stopIndex + 1} of ${day.stops.length}<br>
          <small style="text-transform:capitalize;color:#666;">
            ${placeTypeDisplay}
          </small>
        </p>
      </div>`
  });

  marker.addListener('click', () => {
    closeAllInfoWindows();
    marker.infoWindow.open(map, marker);
  });

  marker.dayIndex = dayIndex;
  return marker;
}

/**
 * Build all itinerary markers and return viewport bounds
 */
function createAllMarkers(tripData) {
  const { debugLog } = window.TravelHelpers;
  const bounds = new google.maps.LatLngBounds();
  let totalStops = 0;

  clearAllMarkers();

  tripData.days.forEach((day, dayIndex) => {
    debugLog(`Processing day ${dayIndex + 1}: ${day.label}`, day);
    if (!Array.isArray(day.stops)) {
      debugLog(`Day ${dayIndex + 1} has no stops`);
      return;
    }

    day.stops.forEach((stop, stopIndex) => {
      const marker = createMarker(stop, day, dayIndex, stopIndex);
      if (marker) {
        currentMarkers.push(marker);
        bounds.extend(marker.position);
        totalStops += 1;
      }
    });
  });

  debugLog(`Created ${currentMarkers.length} markers for ${totalStops} stops`);
  return { bounds, totalStops };
}

function clearAllMarkers() {
  currentMarkers.forEach(m => {
    m.infoWindow?.close();
    m.map = null;
  });
  currentMarkers = [];
}

function closeAllInfoWindows() {
  currentMarkers.forEach(m => m.infoWindow?.close());
}

function toggleMarkersForDay(dayIndex, visible) {
  const { getMap } = window.TravelGoogleMaps;
  currentMarkers.forEach(m => {
    if (m.dayIndex === dayIndex) {
      m.map = visible ? getMap() : null;
      if (!visible) m.infoWindow?.close();
    }
  });
}

function getAllMarkers() {
  return currentMarkers;
}

// ---------- “Ad-hoc” POI markers for voice chat ----------

let poiMarkers = [];

/**
 * Drop an arbitrary list of POIs on the map (clears previous POI layer)
 * list = [ {name, lat, lng}, … ]
 */
function showPOIs(list) {
  const { getMap } = window.TravelGoogleMaps;
  const map = getMap();

  // clear previous batch
  poiMarkers.forEach(m => m.setMap(null));
  poiMarkers = [];

  list.forEach(({ name, lat, lng }) => {
    const marker = new google.maps.Marker({
      position: { lat, lng },
      title: name,
      map,
      icon: {
        url: '/travel/static/img/poi.svg',
        scaledSize: new google.maps.Size(28, 28)
      }
    });
    poiMarkers.push(marker);
  });
}

// ---------- Exports ----------

Object.assign(window.TravelMarkers, {
  createMarker,
  createAllMarkers,
  clearAllMarkers,
  closeAllInfoWindows,
  toggleMarkersForDay,
  getAllMarkers,
  showPOIs
});

// quick global handles for modules that don’t import TravelMarkers
window.showPOIs = showPOIs;
})();
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\markers.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\routes.js:
// static/js/map/routes.js
// -------------------------------------------------------------
//  • Draws a walking route (Directions API) or, if that fails,
//    a simple geodesic Polyline for each day.
//  • Keeps a per-day colour in sync with marker colours.
//  • Adds drawRoute(encodedPolyline[, day]) so voice-chat
//    can drop a ready-made route on the map in one call.
// -------------------------------------------------------------

(function() {
    if (!window.google || !window.google.maps) {
        console.error('Google Maps API not fully loaded yet for routes.js - retrying...');
        setTimeout(function() {
            const script = document.createElement('script');
            script.src = '/travel/static/js/map/routes.js';
            document.head.appendChild(script);
        }, 100);
        return;
    }

// ---------- internal state ----------

// collection of DirectionsRenderers *and* fallback Polylines
let currentPaths = [];

/** Return the same colour the markers use for this day (0-based index). */
function getRouteColour(dayIndex) {
  return window.TravelGoogleMaps.getColourForDay(dayIndex + 1);
}

// ---------- main “create all” entry point ----------

/**
 * Build routes for every day in a trip data object.
 * tripData = { days:[ {label, stops:[{name,lat,lng}, …]}, … ] }
 */
function createAllRoutes(tripData) {
  const { debugLog } = window.TravelHelpers;

  debugLog('Creating routes for all days …');
  clearAllRoutes();

  tripData.days.forEach((day, dayIndex) => {
    if (Array.isArray(day.stops) && day.stops.length > 1) {
      createDayRoute(day, dayIndex);
    }
  });
}

// ---------- one-day route builder ----------

function createDayRoute(day, dayIndex) {
  const {
    debugLog,
    isValidCoordinate,
    createLatLng
  } = window.TravelHelpers;
  const {
    getMap,
    getDirectionsService
  } = window.TravelGoogleMaps;
  const { TRAVEL_MODE } = window.TravelConstants;
  const { isDayVisible } = window.TravelControls;

  debugLog(`Creating route for Day ${dayIndex + 1} (“${day.label || ''}”)`);

  const validStops = (day.stops || []).filter(s =>
    isValidCoordinate(s.lat, s.lng)
  );
  if (validStops.length < 2) {
    debugLog(`  Day ${dayIndex + 1} has <2 valid stops → no route.`);
    return;
  }

  // Directions-API request
  const origin      = createLatLng(validStops[0].lat, validStops[0].lng);
  const destination = createLatLng(
    validStops[validStops.length - 1].lat,
    validStops[validStops.length - 1].lng
  );
  const waypoints = validStops.slice(1, -1).map(s => ({
    location: createLatLng(s.lat, s.lng),
    stopover: true
  }));

  const request = {
    origin,
    destination,
    waypoints,
    travelMode: TRAVEL_MODE.WALKING,
    optimizeWaypoints: false,
    avoidHighways: true,
    avoidTolls: true
  };

  const directionsService = getDirectionsService();
  const map          = getMap();
  const routeColour  = getRouteColour(dayIndex);

  directionsService.route(request, (result, status) => {
    debugLog(
      `  Directions API response for Day ${dayIndex + 1}: ${status}`
    );

    if (status === 'OK' && result) {
      // use DirectionsRenderer
      const renderer = new google.maps.DirectionsRenderer({
        suppressMarkers: true,
        polylineOptions: {
          strokeColor: routeColour,
          strokeWeight: 4,
          strokeOpacity: 0.8
        },
        suppressInfoWindows: true
      });

      renderer.setDirections(result);
      renderer.dayIndex = dayIndex;
      renderer.setMap(isDayVisible(dayIndex) ? map : null);

      currentPaths.push(renderer);
    } else {
      // fallback
      debugLog(
        `  Directions failed (${status}); using fallback polyline.`
      );
      createSimplePolyline(validStops, dayIndex);
    }
  });
}

// ---------- fallback polyline ----------

function createSimplePolyline(stops, dayIndex) {
  const { debugLog, createLatLng } = window.TravelHelpers;
  const { getMap }                 = window.TravelGoogleMaps;
  const { isDayVisible }           = window.TravelControls;

  debugLog(`  Drawing fallback polyline for Day ${dayIndex + 1}`);

  const pathCoords  = stops.map(s => createLatLng(s.lat, s.lng));
  const routeColour = getRouteColour(dayIndex);
  const map         = getMap();

  const polyline = new google.maps.Polyline({
    path: pathCoords,
    geodesic: true,
    strokeColor: routeColour,
    strokeOpacity: 0.8,
    strokeWeight: 4
  });

  polyline.dayIndex = dayIndex;
  polyline.setMap(isDayVisible(dayIndex) ? map : null);

  currentPaths.push(polyline);
}

// ---------- utilities ----------

function clearAllRoutes() {
  currentPaths.forEach(p => p.setMap?.(null));
  currentPaths = [];
}

function toggleRoutesForDay(dayIndex, visible) {
  const { debugLog } = window.TravelHelpers;
  const { getMap }   = window.TravelGoogleMaps;

  debugLog(
    `Toggling routes for Day ${dayIndex + 1} → ${visible ? 'show' : 'hide'}`
  );

  currentPaths.forEach(p => {
    if (p.dayIndex === dayIndex) {
      p.setMap(visible ? getMap() : null);
    }
  });
}

// ---------- “voice chat” helper ----------
//
// drawRoute(encodedPolyline[, dayIndex = 0])
// ------------------------------------------------
// Called by chat.js when the back-end returns an
// already-computed polyline.

const dayLayers = []; // one Polyline per day

function drawRoute(encoded, day = 0) {
  const map = window.TravelGoogleMaps.getMap();

  // remove old layer for that day, if any
  if (dayLayers[day]) dayLayers[day].setMap(null);

  const path = google.maps.geometry.encoding.decodePath(encoded);
  const line = new google.maps.Polyline({
    path,
    strokeOpacity: 0.9,
    strokeWeight: 4,
    geodesic: true,
    map
  });

  dayLayers[day] = line;

  // fit viewport
  const bounds = new google.maps.LatLngBounds();
  path.forEach(p => bounds.extend(p));
  map.fitBounds(bounds, 80);
}

// ---------- export to global namespace ----------

window.TravelRoutes = {
  createAllRoutes,
  createDayRoute,
  clearAllRoutes,
  toggleRoutesForDay
};

// Make the quick helper globally reachable (e.g. from chat.js)
window.drawRoute = drawRoute;
})();
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\map\routes.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\form.js:
// static/js/ui/form.js - Form Handling

/**
 * Initialize form event handlers
 */
function initializeForm() {
    const { debugLog } = window.TravelHelpers;
    const form = document.getElementById("trip-form");
    
    if (form) {
        form.addEventListener("submit", handleFormSubmit);
        debugLog("Form handler initialized");
    }
}

/**
 * Handle form submission
 */
async function handleFormSubmit(e) {
    e.preventDefault();
    
    const { debugLog } = window.TravelHelpers;
    const { showError } = window.TravelOverlays;
    const { processItinerary } = window.TravelApp;
    
    const city = document.getElementById("city").value.trim();
    const days = parseInt(document.getElementById("days").value, 10);
    
    debugLog(`Planning trip: ${city}, ${days} days`);
    
    if (city && days > 0) {
        try {
            await processItinerary(city, days);
        } catch (error) {
            showError(`Failed to process itinerary: ${error.message}`);
        }
    } else {
        showError("Please enter a valid city name and number of days");
    }
}

// Export for other modules
window.TravelForm = {
    initializeForm
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\form.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\overlays.js:
// static/js/ui/overlays.js - Loading and Error Overlays

/**
 * Show loading overlay on top of the map
 */
function showLoading(message) {
    const { ensureRelativePosition } = window.TravelHelpers;
    const mapElement = document.getElementById("map");
    if (!mapElement) return;
    ensureRelativePosition(mapElement);

    let overlay = document.getElementById("map-overlay");
    if (!overlay) {
        overlay = document.createElement("div");
        overlay.id = "map-overlay";
        overlay.style.cssText = `
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            color: #f2f2f2;
            font-size: 1.1rem;
            text-align: center;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        `;
        mapElement.appendChild(overlay);
    }
    
    overlay.innerHTML = `
        <p style="margin: 0 0 0.5rem;">🔄 ${message}</p>
        <p><small>This may take a few moments…</small></p>
    `;
    overlay.classList.add("visible");
}

/**
 * Show error overlay on top of the map
 */
function showError(message) {
    const { ensureRelativePosition, errorLog } = window.TravelHelpers;
    errorLog("Showing error:", message);
    
    const mapElement = document.getElementById("map");
    if (!mapElement) return;
    ensureRelativePosition(mapElement);

    let overlay = document.getElementById("map-overlay");
    if (!overlay) {
        overlay = document.createElement("div");
        overlay.id = "map-overlay";
        overlay.style.cssText = `
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            color: #c0392b;
            font-size: 1.1rem;
            text-align: center;
            z-index: 5;
            pointer-events: auto;
            transition: opacity 0.2s ease;
        `;
        mapElement.appendChild(overlay);
    } else {
        // If overlay existed from showLoading, override styling
        overlay.style.background = "rgba(255, 255, 255, 0.9)";
        overlay.style.color = "#c0392b";
        overlay.style.pointerEvents = "auto";
    }

    overlay.innerHTML = `
        <h3 style="margin-top: 0;">⚠️ Error</h3>
        <div style="max-width: 500px; text-align: left; margin: 0 auto;">
            ${message}
        </div>
        <button onclick="location.reload()"
                style="margin-top: 1rem;
                       padding: 0.4rem 1rem;
                       background: #007bff;
                       color: white;
                       border: none;
                       border-radius: 4px;
                       cursor: pointer;">
            Reload
        </button>
    `;
    overlay.classList.add("visible");
}

/**
 * Hide any loading/error overlay
 */
function hideOverlay() {
    const el = document.getElementById("map-overlay");
    if (el) {
        el.classList.remove("visible");
        el.innerHTML = "";
    }
}

// Export for other modules
window.TravelOverlays = {
    showLoading,
    showError,
    hideOverlay
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\overlays.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\panel.js:
// static/js/ui/panel.js  – Minimise / expand logic
// -------------------------------------------------
// • Adds / removes the class "minimized" on #panel.
// • CSS in panel.css already hides the form inputs and
//   keeps only the Day-controls row visible in that state.

function initializePanel() {
  const panel       = document.getElementById('panel');
  const minimizeBtn = document.getElementById('minimize-btn');

  // defensive – if markup missing, bail early
  if (!panel || !minimizeBtn) return;

  let isMinimized = false;

  minimizeBtn.addEventListener('click', () => {
    isMinimized = !isMinimized;

    // ↓ this is the only class the CSS cares about
    panel.classList.toggle('minimized', isMinimized);

    // update button glyph & tooltip
    minimizeBtn.textContent = isMinimized ? '+' : '−';
    minimizeBtn.title       = isMinimized ? 'Expand' : 'Minimize';
  });
}

// expose for main app bootstrap
window.TravelPanel = { initializePanel };

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\ui\panel.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\constants.js:
// static/js/utils/constants.js – Shared constants (vector-map ready)
// -----------------------------------------------------------------

// 1) Map configuration
const MAP_CONFIG = {
  DEFAULT_CENTER   : { lat: 48.8566, lng: 2.3522 },
  DEFAULT_ZOOM     : 13,
  MAX_ZOOM         : 16,
  MIN_ZOOM         : 10,
  COMFORTABLE_ZOOM : 14,
  OVERVIEW_ZOOM    : 12,
  
  // Comment out or remove the MAP_ID
  MAP_ID: 'c3bdabd61cc122adbb5aee9d'
};

// 2) Travel mode
const TRAVEL_MODE = { WALKING: 'WALKING' };

// 3) UI colours
const COLORS = {
  DEFAULT_ROUTE : '#4285f4',
  DAY_COLORS    : [
    '#ff6b6b', '#4ecdc4', '#45b7d1',
    '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'
  ]
};

// 4) API endpoints
const API_ENDPOINTS = {
  CONFIG   : '/travel/api/config',
  ITINERARY: '/travel/api/itinerary'
};

// 5) Comprehensive map styles - hide only road labels, keep everything else
const MAP_STYLES = [
  /* ----- POI visibility ----- */
  // Hide ALL POI text labels
  {
    featureType: 'poi',
    elementType: 'labels.text',
    stylers: [{ visibility: 'off' }]
  },
  // Show POI icons (museums, parks, attractions, etc.)
  {
    featureType: 'poi',
    elementType: 'labels.icon',
    stylers: [{ visibility: 'on' }]
  },
  // … except for generic businesses, which we still hide:
  {
    featureType: 'poi.business',
    elementType: 'labels.icon',
    stylers: [{ visibility: 'off' }]
  },

  /* ----- Road / transit / neighbourhood clutter ----- */
  { featureType: 'road.local',           elementType: 'labels',       stylers: [{ visibility: 'off' }] },
  { featureType: 'road.arterial',        elementType: 'labels.text',  stylers: [{ visibility: 'off' }] },
  { featureType: 'road.highway',         elementType: 'labels.icon',  stylers: [{ visibility: 'off' }] },
  { featureType: 'road.arterial',        elementType: 'labels.icon',  stylers: [{ visibility: 'off' }] },
  { featureType: 'road.local',           elementType: 'labels.icon',  stylers: [{ visibility: 'off' }] },
  { featureType: 'transit',              elementType: 'labels',       stylers: [{ visibility: 'off' }] },
  { featureType: 'administrative.neighborhood', elementType: 'labels', stylers: [{ visibility: 'off' }] },

  /* ----- Subtle visual tweaks ----- */
  { elementType: 'labels.text.fill',   stylers: [{ lightness: 35 }] },
  { elementType: 'labels.text.stroke', stylers: [{ visibility: 'on' }, { lightness: 65 }] },
  { elementType: 'geometry',           stylers: [{ lightness: 10 }] }
];
// 6) Export everything
window.TravelConstants = {
  MAP_CONFIG,
  TRAVEL_MODE,
  COLORS,
  API_ENDPOINTS,
  MAP_STYLES
};

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\constants.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\helpers.js:
// static/js/utils/helpers.js - Utility Functions

/**
 * Ensure an element has relative positioning for overlays
 */
function ensureRelativePosition(el) {
    const pos = getComputedStyle(el).position;
    if (pos === 'static' || !pos) {
        el.style.position = 'relative';
    }
}

/**
 * Validate coordinates
 */
function isValidCoordinate(lat, lng) {
    return lat && lng && !isNaN(lat) && !isNaN(lng) && 
           lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
}

/**
 * Create a Google Maps LatLng object
 */
function createLatLng(lat, lng) {
    return { lat: Number(lat), lng: Number(lng) };
}

/**
 * Debug logging helper
 */
function debugLog(message, data = null) {
    if (console && console.log) {
        if (data) {
            console.log(message, data);
        } else {
            console.log(message);
        }
    }
}

/**
 * Error logging helper
 */
function errorLog(message, error = null) {
    if (console && console.error) {
        if (error) {
            console.error(message, error);
        } else {
            console.error(message);
        }
    }
}

/**
 * Create a promise that resolves after a delay
 */
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Export for other modules
window.TravelHelpers = {
    ensureRelativePosition,
    isValidCoordinate,
    createLatLng,
    debugLog,
    errorLog,
    delay
};
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\helpers.js ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\temp.txt:

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\static\js\utils\temp.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\templates\map.html:
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PiText - Travel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/x-icon" href="/travel/static/PiText_favicon.ico" />

  <!-- CSS Files -->
  <link rel="stylesheet" href="/travel/static/css/base.css" />
  <link rel="stylesheet" href="/travel/static/css/map.css" />
  <link rel="stylesheet" href="/travel/static/css/controls.css" />
  <link rel="stylesheet" href="/travel/static/css/panel.css" />
  <link rel="stylesheet" href="/travel/static/css/chat.css"/>
</head>
<body>
  <!-- Full-Screen Map Container -->
  <div id="map">
    <!-- Initial "Ready" message -->
    <div class="loading">
      <p>🗺️ Ready to plan your trip?</p>
      <p><small>Enter a city &amp; days, then click "Start Planning".</small></p>
    </div>
  </div>
  <!-- Voice-chat mic button -->
<button id="mic-btn" class="mic-btn" aria-label="Start voice chat">

  <!-- Sliding chat panel -->
  <aside id="chat-panel" class="chat-panel" aria-live="polite"></aside>

  <!-- simple SVG icon keeps it self-contained -->
  <svg viewBox="0 0 24 24" width="24" height="24">
    <path d="M12 2a4 4 0 0 1 4 4v6a4 4 0 1 1-8 0V6a4 4 0 0 1 4-4zM5 11h2a5 5 0 0 0 10 0h2a7 7 0 0 1-14 0zm7 9v-3h-2v3H8v2h8v-2h-4z"/>
  </svg>
</button>


  <!-- Transparent Outer Panel -->
  <div id="panel">
    <button id="minimize-btn" title="Minimize/Expand">−</button>
    <!-- Inner Panel: blur  white background  rounding -->
    <div id="inner-panel">
    <div id="day-controls"></div>

      <form id="trip-form">
        <input id="city" type="text" placeholder="Enter city name" value="Paris" required />
        <input id="days" type="number" min="1" max="14" value="3" required />
        <button type="submit">Start Planning</button>
      </form>
    </div>
  </div>



  <!-- Loading / Error Overlay (injected by JS) -->
  <div id="map-overlay"></div>

  <!-- JavaScript Files - Load in dependency order -->
  <!-- Utilities first -->
  <script src="/travel/static/js/utils/constants.js"></script>
  <script src="/travel/static/js/utils/helpers.js"></script>
  
  <!-- API Layer -->
  <script src="/travel/static/js/api/config.js"></script>
  <script src="/travel/static/js/api/client.js"></script>
  
  <!-- UI Components -->
  <script src="/travel/static/js/ui/overlays.js"></script>
  <script src="/travel/static/js/ui/panel.js"></script>
  <script src="/travel/static/js/ui/form.js"></script>
  
<!-- Map components (must stay in this order) -->
<!-- Map components (must stay in this order) -->
<!-- Map components (must stay in this order) -->
<script src="/travel/static/js/map/google-maps.js"></script>

<!-- Dynamically load map modules after Google Maps is ready -->
<script>
window.mapModulesLoaded = false;
window.mapModulesReady = false;

window.loadMapModules = function() {
    if (window.mapModulesLoaded) return;
    
    // Ensure Google Maps is fully ready
    if (!window.google || !window.google.maps || !window.google.maps.marker) {
        console.log('Waiting for Google Maps to be fully ready...');
        setTimeout(window.loadMapModules, 100);
        return;
    }
    
    const scripts = [
        '/travel/static/js/map/markers.js',
        '/travel/static/js/map/routes.js', 
        '/travel/static/js/map/controls.js'
    ];
    
    let loadedCount = 0;
    
    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    // Load scripts sequentially to ensure proper order
    Promise.all(scripts.map(loadScript))
        .then(() => {
            window.mapModulesLoaded = true;
            window.mapModulesReady = true;
            console.log('All map modules loaded successfully');
            
            // Trigger any pending renders
            if (window.pendingRender) {
                window.TravelApp.renderTripOnMap(window.pendingRender);
                window.pendingRender = null;
            }
        })
        .catch(err => {
            console.error('Failed to load map modules:', err);
        });
};
</script>
<!-- Marker-clusterer library -->
<script src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js"></script>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>


<!-- Voice/chat helpers -->
<script src="/travel/static/js/voice.js"></script>
<script src="/travel/static/js/chat.js"></script>

<!-- Main app (calls renderTripOnMap) – must be last, NO DEFER -->
<script src="/travel/static/js/app.js"></script>

</body>
</html>
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\pitext_travel\templates\map.html ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\.env.example:
PORT=10000
# Any other env variables you may use in future, e.g.:
# OPENAI_API_KEY=your_api_key_here

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\.env.example ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\requirements.txt:
fastapi==0.104.1
uvicorn[standard]==0.24.0
openai==1.12.0
anthropic==0.18.1
python-dotenv==1.0.0
playwright==1.40.0
pillow==10.1.0
python-multipart==0.0.6
httpx==0.25.2
--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\requirements.txt ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\router_app.py:
import sys
import importlib.util
from pathlib import Path

from fastapi.responses import RedirectResponse, Response
from starlette.types import ASGIApp, Receive, Scope, Send

BASE_DIR = Path(__file__).parent.parent

# ---------------------------------------------------------------------------
# Helper: dynamically load a FastAPI/Flask app from a folder
# ---------------------------------------------------------------------------
def load_app_module(app_path: Path, module_name: str, asgi_name="asgi_app") -> ASGIApp:
    """
    Dynamically load a FastAPI or Flask app as ASGI.
    Prefers `asgi_app` if present, else falls back to `app`.
    """
    main_file = app_path / "main.py"
    if not main_file.exists():
        raise FileNotFoundError(f"main.py not found in {app_path}")

    spec = importlib.util.spec_from_file_location(module_name, main_file)
    module = importlib.util.module_from_spec(spec)
    sys.path.insert(0, str(app_path))
    spec.loader.exec_module(module)
    sys.path.remove(str(app_path))
    # Prefer 'asgi_app', fallback to 'app'
    return getattr(module, asgi_name, getattr(module, "app", None))

print(f"Loading desktop app from: {BASE_DIR / 'pitext-desktop'}")
desktop_app = load_app_module(BASE_DIR / "pitext-desktop", "desktop_main")

print(f"Loading mobile app from: {BASE_DIR / 'pitext-mobile'}")
mobile_app = load_app_module(BASE_DIR / "pitext-mobile", "mobile_main")

print(f"Loading codegen app from: {BASE_DIR / 'pitext_codegen'}")
codegen_app = load_app_module(BASE_DIR / "pitext_codegen", "codegen_main")

# NEW: Load travel app
print(f"Loading travel app from: {BASE_DIR / 'pitext_travel'}")
travel_app = load_app_module(BASE_DIR / "pitext_travel", "travel_main")

# ---------------------------------------------------------------------------
# Helper: determine mobile by User-Agent header
# ---------------------------------------------------------------------------
def is_mobile(scope: Scope) -> bool:
    headers = dict(scope.get("headers") or [])
    ua_bytes = headers.get(b"user-agent", b"").lower()
    return any(x in ua_bytes for x in [b"android", b"mobi", b"iphone"])

# ---------------------------------------------------------------------------
# Main ASGI router - Clean routing logic only
# ---------------------------------------------------------------------------
class RouterApp:
    def __init__(self, desktop: ASGIApp, mobile: ASGIApp, codegen: ASGIApp, travel: ASGIApp):
        self.desktop = desktop
        self.mobile = mobile
        self.codegen = codegen
        self.travel = travel

    async def __call__(self, scope: Scope, receive: Receive, send: Send):
        if scope["type"] != "http":
            await self.desktop(scope, receive, send)
            return

        path = scope.get("path", "")

        # Route to CodeGen service
        if path.startswith("/codegen"):
            await self.codegen(scope, receive, send)
            return

        # Route to travel app
        if path.startswith("/travel"):
            print("Routing to travel app:", path)
            await self.travel(scope, receive, send)
            return

        # Redirect root to mobile/desktop based on User-Agent
        if path == "/":
            target_path = "/mobile" if is_mobile(scope) else "/desktop"
            response = RedirectResponse(url=target_path)
            await response(scope, receive, send)
            return

        # Route to desktop app
        if path.startswith("/desktop"):
            await self.desktop(scope, receive, send)
            return

        # Route to mobile app
        if path.startswith("/mobile"):
            await self.mobile(scope, receive, send)
            return

        # 404 for anything else
        response = Response(
            content='{"detail":"Not Found"}',
            media_type="application/json",
            status_code=404,
        )
        await response(scope, receive, send)

# Instantiate the ASGI app that Render will pick up
app = RouterApp(desktop_app, mobile_app, codegen_app, travel_app)

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\router_app.py ---

C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\__init__.py:
# This file makes router-backend a Python package

--- End of C:\Users\prabh\OneDrive\Documents\GitHub\pitext-root\router-backend\__init__.py ---

